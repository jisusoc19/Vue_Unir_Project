{"version":3,"file":"js/chunk-vendors.62be9215.js","mappings":"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","sources":["webpack://trabjounir/./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","webpack://trabjounir/./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js","webpack://trabjounir/./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js","webpack://trabjounir/./node_modules/@vue/shared/dist/shared.esm-bundler.js","webpack://trabjounir/./node_modules/vue-loader/dist/exportHelper.js","webpack://trabjounir/./node_modules/core-js/internals/a-callable.js","webpack://trabjounir/./node_modules/core-js/internals/an-object.js","webpack://trabjounir/./node_modules/core-js/internals/array-includes.js","webpack://trabjounir/./node_modules/core-js/internals/array-set-length.js","webpack://trabjounir/./node_modules/core-js/internals/classof-raw.js","webpack://trabjounir/./node_modules/core-js/internals/copy-constructor-properties.js","webpack://trabjounir/./node_modules/core-js/internals/create-non-enumerable-property.js","webpack://trabjounir/./node_modules/core-js/internals/create-property-descriptor.js","webpack://trabjounir/./node_modules/core-js/internals/define-built-in.js","webpack://trabjounir/./node_modules/core-js/internals/define-global-property.js","webpack://trabjounir/./node_modules/core-js/internals/descriptors.js","webpack://trabjounir/./node_modules/core-js/internals/document-create-element.js","webpack://trabjounir/./node_modules/core-js/internals/does-not-exceed-safe-integer.js","webpack://trabjounir/./node_modules/core-js/internals/engine-user-agent.js","webpack://trabjounir/./node_modules/core-js/internals/engine-v8-version.js","webpack://trabjounir/./node_modules/core-js/internals/enum-bug-keys.js","webpack://trabjounir/./node_modules/core-js/internals/export.js","webpack://trabjounir/./node_modules/core-js/internals/fails.js","webpack://trabjounir/./node_modules/core-js/internals/function-bind-native.js","webpack://trabjounir/./node_modules/core-js/internals/function-call.js","webpack://trabjounir/./node_modules/core-js/internals/function-name.js","webpack://trabjounir/./node_modules/core-js/internals/function-uncurry-this.js","webpack://trabjounir/./node_modules/core-js/internals/get-built-in.js","webpack://trabjounir/./node_modules/core-js/internals/get-method.js","webpack://trabjounir/./node_modules/core-js/internals/global.js","webpack://trabjounir/./node_modules/core-js/internals/has-own-property.js","webpack://trabjounir/./node_modules/core-js/internals/hidden-keys.js","webpack://trabjounir/./node_modules/core-js/internals/ie8-dom-define.js","webpack://trabjounir/./node_modules/core-js/internals/indexed-object.js","webpack://trabjounir/./node_modules/core-js/internals/inspect-source.js","webpack://trabjounir/./node_modules/core-js/internals/internal-state.js","webpack://trabjounir/./node_modules/core-js/internals/is-array.js","webpack://trabjounir/./node_modules/core-js/internals/is-callable.js","webpack://trabjounir/./node_modules/core-js/internals/is-forced.js","webpack://trabjounir/./node_modules/core-js/internals/is-null-or-undefined.js","webpack://trabjounir/./node_modules/core-js/internals/is-object.js","webpack://trabjounir/./node_modules/core-js/internals/is-pure.js","webpack://trabjounir/./node_modules/core-js/internals/is-symbol.js","webpack://trabjounir/./node_modules/core-js/internals/length-of-array-like.js","webpack://trabjounir/./node_modules/core-js/internals/make-built-in.js","webpack://trabjounir/./node_modules/core-js/internals/math-trunc.js","webpack://trabjounir/./node_modules/core-js/internals/object-define-property.js","webpack://trabjounir/./node_modules/core-js/internals/object-get-own-property-descriptor.js","webpack://trabjounir/./node_modules/core-js/internals/object-get-own-property-names.js","webpack://trabjounir/./node_modules/core-js/internals/object-get-own-property-symbols.js","webpack://trabjounir/./node_modules/core-js/internals/object-is-prototype-of.js","webpack://trabjounir/./node_modules/core-js/internals/object-keys-internal.js","webpack://trabjounir/./node_modules/core-js/internals/object-property-is-enumerable.js","webpack://trabjounir/./node_modules/core-js/internals/ordinary-to-primitive.js","webpack://trabjounir/./node_modules/core-js/internals/own-keys.js","webpack://trabjounir/./node_modules/core-js/internals/require-object-coercible.js","webpack://trabjounir/./node_modules/core-js/internals/shared-key.js","webpack://trabjounir/./node_modules/core-js/internals/shared-store.js","webpack://trabjounir/./node_modules/core-js/internals/shared.js","webpack://trabjounir/./node_modules/core-js/internals/symbol-constructor-detection.js","webpack://trabjounir/./node_modules/core-js/internals/to-absolute-index.js","webpack://trabjounir/./node_modules/core-js/internals/to-indexed-object.js","webpack://trabjounir/./node_modules/core-js/internals/to-integer-or-infinity.js","webpack://trabjounir/./node_modules/core-js/internals/to-length.js","webpack://trabjounir/./node_modules/core-js/internals/to-object.js","webpack://trabjounir/./node_modules/core-js/internals/to-primitive.js","webpack://trabjounir/./node_modules/core-js/internals/to-property-key.js","webpack://trabjounir/./node_modules/core-js/internals/try-to-string.js","webpack://trabjounir/./node_modules/core-js/internals/uid.js","webpack://trabjounir/./node_modules/core-js/internals/use-symbol-as-uid.js","webpack://trabjounir/./node_modules/core-js/internals/v8-prototype-define-bug.js","webpack://trabjounir/./node_modules/core-js/internals/weak-map-basic-detection.js","webpack://trabjounir/./node_modules/core-js/internals/well-known-symbol.js","webpack://trabjounir/./node_modules/core-js/modules/es.array.push.js","webpack://trabjounir/./node_modules/@kurkle/color/dist/color.esm.js","webpack://trabjounir/./node_modules/chart.js/dist/chunks/helpers.segment.js","webpack://trabjounir/./node_modules/chart.js/dist/chart.js","webpack://trabjounir/./node_modules/chart.js/auto/auto.js"],"sourcesContent":["/**\n* @vue/reactivity v3.4.27\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { NOOP, extend, isArray, isSymbol, isMap, isIntegerKey, hasOwn, hasChanged, isObject, makeMap, capitalize, toRawType, def, isFunction } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeEffect;\nclass ReactiveEffect {\n  constructor(fn, trigger, scheduler, scope) {\n    this.fn = fn;\n    this.trigger = trigger;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    /**\n     * @internal\n     */\n    this._dirtyLevel = 4;\n    /**\n     * @internal\n     */\n    this._trackId = 0;\n    /**\n     * @internal\n     */\n    this._runnings = 0;\n    /**\n     * @internal\n     */\n    this._shouldSchedule = false;\n    /**\n     * @internal\n     */\n    this._depsLength = 0;\n    recordEffectScope(this, scope);\n  }\n  get dirty() {\n    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {\n      this._dirtyLevel = 1;\n      pauseTracking();\n      for (let i = 0; i < this._depsLength; i++) {\n        const dep = this.deps[i];\n        if (dep.computed) {\n          triggerComputed(dep.computed);\n          if (this._dirtyLevel >= 4) {\n            break;\n          }\n        }\n      }\n      if (this._dirtyLevel === 1) {\n        this._dirtyLevel = 0;\n      }\n      resetTracking();\n    }\n    return this._dirtyLevel >= 4;\n  }\n  set dirty(v) {\n    this._dirtyLevel = v ? 4 : 0;\n  }\n  run() {\n    this._dirtyLevel = 0;\n    if (!this.active) {\n      return this.fn();\n    }\n    let lastShouldTrack = shouldTrack;\n    let lastEffect = activeEffect;\n    try {\n      shouldTrack = true;\n      activeEffect = this;\n      this._runnings++;\n      preCleanupEffect(this);\n      return this.fn();\n    } finally {\n      postCleanupEffect(this);\n      this._runnings--;\n      activeEffect = lastEffect;\n      shouldTrack = lastShouldTrack;\n    }\n  }\n  stop() {\n    if (this.active) {\n      preCleanupEffect(this);\n      postCleanupEffect(this);\n      this.onStop && this.onStop();\n      this.active = false;\n    }\n  }\n}\nfunction triggerComputed(computed) {\n  return computed.value;\n}\nfunction preCleanupEffect(effect2) {\n  effect2._trackId++;\n  effect2._depsLength = 0;\n}\nfunction postCleanupEffect(effect2) {\n  if (effect2.deps.length > effect2._depsLength) {\n    for (let i = effect2._depsLength; i < effect2.deps.length; i++) {\n      cleanupDepEffect(effect2.deps[i], effect2);\n    }\n    effect2.deps.length = effect2._depsLength;\n  }\n}\nfunction cleanupDepEffect(dep, effect2) {\n  const trackId = dep.get(effect2);\n  if (trackId !== void 0 && effect2._trackId !== trackId) {\n    dep.delete(effect2);\n    if (dep.size === 0) {\n      dep.cleanup();\n    }\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn, NOOP, () => {\n    if (_effect.dirty) {\n      _effect.run();\n    }\n  });\n  if (options) {\n    extend(_effect, options);\n    if (options.scope)\n      recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nlet pauseScheduleStack = 0;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction pauseScheduling() {\n  pauseScheduleStack++;\n}\nfunction resetScheduling() {\n  pauseScheduleStack--;\n  while (!pauseScheduleStack && queueEffectSchedulers.length) {\n    queueEffectSchedulers.shift()();\n  }\n}\nfunction trackEffect(effect2, dep, debuggerEventExtraInfo) {\n  var _a;\n  if (dep.get(effect2) !== effect2._trackId) {\n    dep.set(effect2, effect2._trackId);\n    const oldDep = effect2.deps[effect2._depsLength];\n    if (oldDep !== dep) {\n      if (oldDep) {\n        cleanupDepEffect(oldDep, effect2);\n      }\n      effect2.deps[effect2._depsLength++] = dep;\n    } else {\n      effect2._depsLength++;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));\n    }\n  }\n}\nconst queueEffectSchedulers = [];\nfunction triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {\n  var _a;\n  pauseScheduling();\n  for (const effect2 of dep.keys()) {\n    let tracking;\n    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {\n      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);\n      effect2._dirtyLevel = dirtyLevel;\n    }\n    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        (_a = effect2.onTrigger) == null ? void 0 : _a.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));\n      }\n      effect2.trigger();\n      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {\n        effect2._shouldSchedule = false;\n        if (effect2.scheduler) {\n          queueEffectSchedulers.push(effect2.scheduler);\n        }\n      }\n    }\n  }\n  resetScheduling();\n}\n\nconst createDep = (cleanup, computed) => {\n  const dep = /* @__PURE__ */ new Map();\n  dep.cleanup = cleanup;\n  dep.computed = computed;\n  return dep;\n};\n\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"iterate\" : \"\");\nconst MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map key iterate\" : \"\");\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));\n    }\n    trackEffect(\n      activeEffect,\n      dep,\n      !!(process.env.NODE_ENV !== \"production\") ? {\n        target,\n        type,\n        key\n      } : void 0\n    );\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  let deps = [];\n  if (type === \"clear\") {\n    deps = [...depsMap.values()];\n  } else if (key === \"length\" && isArray(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || !isSymbol(key2) && key2 >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  pauseScheduling();\n  for (const dep of deps) {\n    if (dep) {\n      triggerEffects(\n        dep,\n        4,\n        !!(process.env.NODE_ENV !== \"production\") ? {\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        } : void 0\n      );\n    }\n  }\n  resetScheduling();\n}\nfunction getDepFromReactive(object, key) {\n  const depsMap = targetMap.get(object);\n  return depsMap && depsMap.get(key);\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nconst arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      pauseTracking();\n      pauseScheduling();\n      const res = toRaw(this)[key].apply(this, args);\n      resetScheduling();\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  if (!isSymbol(key))\n    key = String(key);\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _isShallow = false) {\n    this._isReadonly = _isReadonly;\n    this._isShallow = _isShallow;\n  }\n  get(target, key, receiver) {\n    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return isShallow2;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the reciever is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (isShallow2) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(false, isShallow2);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._isShallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(isShallow2 = false) {\n    super(true, isShallow2);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(\n  true\n);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  target = target[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (hasChanged(key, rawKey)) {\n      track(rawTarget, \"get\", key);\n    }\n    track(rawTarget, \"get\", rawKey);\n  }\n  const { has: has2 } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly = false) {\n  const target = this[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (hasChanged(key, rawKey)) {\n      track(rawTarget, \"has\", key);\n    }\n    track(rawTarget, \"has\", rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\n    \"keys\",\n    \"values\",\n    \"entries\",\n    Symbol.iterator\n  ];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations2[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations2[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      true\n    );\n  });\n  return [\n    mutableInstrumentations2,\n    readonlyInstrumentations2,\n    shallowInstrumentations2,\n    shallowReadonlyInstrumentations2\n  ];\n}\nconst [\n  mutableInstrumentations,\n  readonlyInstrumentations,\n  shallowInstrumentations,\n  shallowReadonlyInstrumentations\n] = /* @__PURE__ */ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return value ? !!value[\"__v_raw\"] : false;\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nconst COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this.getter = getter;\n    this._setter = _setter;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = false;\n    this.effect = new ReactiveEffect(\n      () => getter(this._value),\n      () => triggerRefValue(\n        this,\n        this.effect._dirtyLevel === 2 ? 2 : 3\n      )\n    );\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"] = isReadonly;\n  }\n  get value() {\n    const self = toRaw(this);\n    if ((!self._cacheable || self.effect.dirty) && hasChanged(self._value, self._value = self.effect.run())) {\n      triggerRefValue(self, 4);\n    }\n    trackRefValue(self);\n    if (self.effect._dirtyLevel >= 2) {\n      if (!!(process.env.NODE_ENV !== \"production\") && this._warnRecursive) {\n        warn(COMPUTED_SIDE_EFFECT_WARN, `\n\ngetter: `, this.getter);\n      }\n      triggerRefValue(self, 2);\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x\n  get _dirty() {\n    return this.effect.dirty;\n  }\n  set _dirty(v) {\n    this.effect.dirty = v;\n  }\n  // #endregion\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = isFunction(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = !!(process.env.NODE_ENV !== \"production\") ? () => {\n      warn(\"Write operation failed: computed value is readonly\");\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nfunction trackRefValue(ref2) {\n  var _a;\n  if (shouldTrack && activeEffect) {\n    ref2 = toRaw(ref2);\n    trackEffect(\n      activeEffect,\n      (_a = ref2.dep) != null ? _a : ref2.dep = createDep(\n        () => ref2.dep = void 0,\n        ref2 instanceof ComputedRefImpl ? ref2 : void 0\n      ),\n      !!(process.env.NODE_ENV !== \"production\") ? {\n        target: ref2,\n        type: \"get\",\n        key: \"value\"\n      } : void 0\n    );\n  }\n}\nfunction triggerRefValue(ref2, dirtyLevel = 4, newVal) {\n  ref2 = toRaw(ref2);\n  const dep = ref2.dep;\n  if (dep) {\n    triggerEffects(\n      dep,\n      dirtyLevel,\n      !!(process.env.NODE_ENV !== \"production\") ? {\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: newVal\n      } : void 0\n    );\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, 4, newVal);\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  triggerRefValue(ref2, 4, !!(process.env.NODE_ENV !== \"production\") ? ref2.value : void 0);\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = void 0;\n    this.__v_isRef = true;\n    const { get, set } = factory(\n      () => trackRefValue(this),\n      () => triggerRefValue(this)\n    );\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this.__v_isRef = true;\n    this.__v_isReadonly = true;\n  }\n  get value() {\n    return this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nconst deferredComputed = computed;\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\"\n};\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseScheduling, pauseTracking, proxyRefs, reactive, readonly, ref, resetScheduling, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, track, trigger, triggerRef, unref };\n","/**\n* @vue/runtime-core v3.4.27\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { pauseTracking, resetTracking, isRef, toRaw, shallowReadonly, isShallow, isReactive, ReactiveEffect, getCurrentScope, ref, track, reactive, shallowReactive, trigger, isProxy, proxyRefs, markRaw, EffectScope, computed as computed$1, customRef, isReadonly } from '@vue/reactivity';\nexport { EffectScope, ReactiveEffect, TrackOpTypes, TriggerOpTypes, customRef, effect, effectScope, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, proxyRefs, reactive, readonly, ref, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, triggerRef, unref } from '@vue/reactivity';\nimport { isString, isFunction, isPromise, isArray, NOOP, getGlobalThis, extend, EMPTY_OBJ, toHandlerKey, looseToNumber, hyphenate, camelize, isObject, isOn, hasOwn, isModelListener, capitalize, toNumber, hasChanged, remove, isSet, isMap, isPlainObject, isBuiltInDirective, invokeArrayFns, isRegExp, isGloballyAllowed, NO, isReservedProp, EMPTY_ARR, toRawType, makeMap, def, normalizeClass, stringifyStyle, normalizeStyle, isKnownSvgAttr, isBooleanAttr, isKnownHtmlAttr, includeBooleanAttr, isRenderableAttrValue } from '@vue/shared';\nexport { camelize, capitalize, normalizeClass, normalizeProps, normalizeStyle, toDisplayString, toHandlerKey } from '@vue/shared';\n\nconst stack = [];\nfunction pushWarningContext(vnode) {\n  stack.push(vnode);\n}\nfunction popWarningContext() {\n  stack.pop();\n}\nfunction warn$1(msg, ...args) {\n  pauseTracking();\n  const instance = stack.length ? stack[stack.length - 1].component : null;\n  const appWarnHandler = instance && instance.appContext.config.warnHandler;\n  const trace = getComponentTrace();\n  if (appWarnHandler) {\n    callWithErrorHandling(\n      appWarnHandler,\n      instance,\n      11,\n      [\n        msg + args.map((a) => {\n          var _a, _b;\n          return (_b = (_a = a.toString) == null ? void 0 : _a.call(a)) != null ? _b : JSON.stringify(a);\n        }).join(\"\"),\n        instance && instance.proxy,\n        trace.map(\n          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`\n        ).join(\"\\n\"),\n        trace\n      ]\n    );\n  } else {\n    const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n    if (trace.length && // avoid spamming console during tests\n    true) {\n      warnArgs.push(`\n`, ...formatTrace(trace));\n    }\n    console.warn(...warnArgs);\n  }\n  resetTracking();\n}\nfunction getComponentTrace() {\n  let currentVNode = stack[stack.length - 1];\n  if (!currentVNode) {\n    return [];\n  }\n  const normalizedStack = [];\n  while (currentVNode) {\n    const last = normalizedStack[0];\n    if (last && last.vnode === currentVNode) {\n      last.recurseCount++;\n    } else {\n      normalizedStack.push({\n        vnode: currentVNode,\n        recurseCount: 0\n      });\n    }\n    const parentInstance = currentVNode.component && currentVNode.component.parent;\n    currentVNode = parentInstance && parentInstance.vnode;\n  }\n  return normalizedStack;\n}\nfunction formatTrace(trace) {\n  const logs = [];\n  trace.forEach((entry, i) => {\n    logs.push(...i === 0 ? [] : [`\n`], ...formatTraceEntry(entry));\n  });\n  return logs;\n}\nfunction formatTraceEntry({ vnode, recurseCount }) {\n  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n  const isRoot = vnode.component ? vnode.component.parent == null : false;\n  const open = ` at <${formatComponentName(\n    vnode.component,\n    vnode.type,\n    isRoot\n  )}`;\n  const close = `>` + postfix;\n  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];\n}\nfunction formatProps(props) {\n  const res = [];\n  const keys = Object.keys(props);\n  keys.slice(0, 3).forEach((key) => {\n    res.push(...formatProp(key, props[key]));\n  });\n  if (keys.length > 3) {\n    res.push(` ...`);\n  }\n  return res;\n}\nfunction formatProp(key, value, raw) {\n  if (isString(value)) {\n    value = JSON.stringify(value);\n    return raw ? value : [`${key}=${value}`];\n  } else if (typeof value === \"number\" || typeof value === \"boolean\" || value == null) {\n    return raw ? value : [`${key}=${value}`];\n  } else if (isRef(value)) {\n    value = formatProp(key, toRaw(value.value), true);\n    return raw ? value : [`${key}=Ref<`, value, `>`];\n  } else if (isFunction(value)) {\n    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n  } else {\n    value = toRaw(value);\n    return raw ? value : [`${key}=`, value];\n  }\n}\nfunction assertNumber(val, type) {\n  if (!!!(process.env.NODE_ENV !== \"production\"))\n    return;\n  if (val === void 0) {\n    return;\n  } else if (typeof val !== \"number\") {\n    warn$1(`${type} is not a valid number - got ${JSON.stringify(val)}.`);\n  } else if (isNaN(val)) {\n    warn$1(`${type} is NaN - the duration expression might be incorrect.`);\n  }\n}\n\nconst ErrorCodes = {\n  \"SETUP_FUNCTION\": 0,\n  \"0\": \"SETUP_FUNCTION\",\n  \"RENDER_FUNCTION\": 1,\n  \"1\": \"RENDER_FUNCTION\",\n  \"WATCH_GETTER\": 2,\n  \"2\": \"WATCH_GETTER\",\n  \"WATCH_CALLBACK\": 3,\n  \"3\": \"WATCH_CALLBACK\",\n  \"WATCH_CLEANUP\": 4,\n  \"4\": \"WATCH_CLEANUP\",\n  \"NATIVE_EVENT_HANDLER\": 5,\n  \"5\": \"NATIVE_EVENT_HANDLER\",\n  \"COMPONENT_EVENT_HANDLER\": 6,\n  \"6\": \"COMPONENT_EVENT_HANDLER\",\n  \"VNODE_HOOK\": 7,\n  \"7\": \"VNODE_HOOK\",\n  \"DIRECTIVE_HOOK\": 8,\n  \"8\": \"DIRECTIVE_HOOK\",\n  \"TRANSITION_HOOK\": 9,\n  \"9\": \"TRANSITION_HOOK\",\n  \"APP_ERROR_HANDLER\": 10,\n  \"10\": \"APP_ERROR_HANDLER\",\n  \"APP_WARN_HANDLER\": 11,\n  \"11\": \"APP_WARN_HANDLER\",\n  \"FUNCTION_REF\": 12,\n  \"12\": \"FUNCTION_REF\",\n  \"ASYNC_COMPONENT_LOADER\": 13,\n  \"13\": \"ASYNC_COMPONENT_LOADER\",\n  \"SCHEDULER\": 14,\n  \"14\": \"SCHEDULER\"\n};\nconst ErrorTypeStrings$1 = {\n  [\"sp\"]: \"serverPrefetch hook\",\n  [\"bc\"]: \"beforeCreate hook\",\n  [\"c\"]: \"created hook\",\n  [\"bm\"]: \"beforeMount hook\",\n  [\"m\"]: \"mounted hook\",\n  [\"bu\"]: \"beforeUpdate hook\",\n  [\"u\"]: \"updated\",\n  [\"bum\"]: \"beforeUnmount hook\",\n  [\"um\"]: \"unmounted hook\",\n  [\"a\"]: \"activated hook\",\n  [\"da\"]: \"deactivated hook\",\n  [\"ec\"]: \"errorCaptured hook\",\n  [\"rtc\"]: \"renderTracked hook\",\n  [\"rtg\"]: \"renderTriggered hook\",\n  [0]: \"setup function\",\n  [1]: \"render function\",\n  [2]: \"watcher getter\",\n  [3]: \"watcher callback\",\n  [4]: \"watcher cleanup function\",\n  [5]: \"native event handler\",\n  [6]: \"component event handler\",\n  [7]: \"vnode hook\",\n  [8]: \"directive hook\",\n  [9]: \"transition hook\",\n  [10]: \"app errorHandler\",\n  [11]: \"app warnHandler\",\n  [12]: \"ref function\",\n  [13]: \"async component loader\",\n  [14]: \"scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core .\"\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n  try {\n    return args ? fn(...args) : fn();\n  } catch (err) {\n    handleError(err, instance, type);\n  }\n}\nfunction callWithAsyncErrorHandling(fn, instance, type, args) {\n  if (isFunction(fn)) {\n    const res = callWithErrorHandling(fn, instance, type, args);\n    if (res && isPromise(res)) {\n      res.catch((err) => {\n        handleError(err, instance, type);\n      });\n    }\n    return res;\n  }\n  if (isArray(fn)) {\n    const values = [];\n    for (let i = 0; i < fn.length; i++) {\n      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));\n    }\n    return values;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(\n      `Invalid value type passed to callWithAsyncErrorHandling(): ${typeof fn}`\n    );\n  }\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n  const contextVNode = instance ? instance.vnode : null;\n  if (instance) {\n    let cur = instance.parent;\n    const exposedInstance = instance.proxy;\n    const errorInfo = !!(process.env.NODE_ENV !== \"production\") ? ErrorTypeStrings$1[type] : `https://vuejs.org/error-reference/#runtime-${type}`;\n    while (cur) {\n      const errorCapturedHooks = cur.ec;\n      if (errorCapturedHooks) {\n        for (let i = 0; i < errorCapturedHooks.length; i++) {\n          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n            return;\n          }\n        }\n      }\n      cur = cur.parent;\n    }\n    const appErrorHandler = instance.appContext.config.errorHandler;\n    if (appErrorHandler) {\n      pauseTracking();\n      callWithErrorHandling(\n        appErrorHandler,\n        null,\n        10,\n        [err, exposedInstance, errorInfo]\n      );\n      resetTracking();\n      return;\n    }\n  }\n  logError(err, type, contextVNode, throwInDev);\n}\nfunction logError(err, type, contextVNode, throwInDev = true) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const info = ErrorTypeStrings$1[type];\n    if (contextVNode) {\n      pushWarningContext(contextVNode);\n    }\n    warn$1(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n    if (contextVNode) {\n      popWarningContext();\n    }\n    if (throwInDev) {\n      throw err;\n    } else {\n      console.error(err);\n    }\n  } else {\n    console.error(err);\n  }\n}\n\nlet isFlushing = false;\nlet isFlushPending = false;\nconst queue = [];\nlet flushIndex = 0;\nconst pendingPostFlushCbs = [];\nlet activePostFlushCbs = null;\nlet postFlushIndex = 0;\nconst resolvedPromise = /* @__PURE__ */ Promise.resolve();\nlet currentFlushPromise = null;\nconst RECURSION_LIMIT = 100;\nfunction nextTick(fn) {\n  const p = currentFlushPromise || resolvedPromise;\n  return fn ? p.then(this ? fn.bind(this) : fn) : p;\n}\nfunction findInsertionIndex(id) {\n  let start = flushIndex + 1;\n  let end = queue.length;\n  while (start < end) {\n    const middle = start + end >>> 1;\n    const middleJob = queue[middle];\n    const middleJobId = getId(middleJob);\n    if (middleJobId < id || middleJobId === id && middleJob.pre) {\n      start = middle + 1;\n    } else {\n      end = middle;\n    }\n  }\n  return start;\n}\nfunction queueJob(job) {\n  if (!queue.length || !queue.includes(\n    job,\n    isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex\n  )) {\n    if (job.id == null) {\n      queue.push(job);\n    } else {\n      queue.splice(findInsertionIndex(job.id), 0, job);\n    }\n    queueFlush();\n  }\n}\nfunction queueFlush() {\n  if (!isFlushing && !isFlushPending) {\n    isFlushPending = true;\n    currentFlushPromise = resolvedPromise.then(flushJobs);\n  }\n}\nfunction invalidateJob(job) {\n  const i = queue.indexOf(job);\n  if (i > flushIndex) {\n    queue.splice(i, 1);\n  }\n}\nfunction queuePostFlushCb(cb) {\n  if (!isArray(cb)) {\n    if (!activePostFlushCbs || !activePostFlushCbs.includes(\n      cb,\n      cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex\n    )) {\n      pendingPostFlushCbs.push(cb);\n    }\n  } else {\n    pendingPostFlushCbs.push(...cb);\n  }\n  queueFlush();\n}\nfunction flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    seen = seen || /* @__PURE__ */ new Map();\n  }\n  for (; i < queue.length; i++) {\n    const cb = queue[i];\n    if (cb && cb.pre) {\n      if (instance && cb.id !== instance.uid) {\n        continue;\n      }\n      if (!!(process.env.NODE_ENV !== \"production\") && checkRecursiveUpdates(seen, cb)) {\n        continue;\n      }\n      queue.splice(i, 1);\n      i--;\n      cb();\n    }\n  }\n}\nfunction flushPostFlushCbs(seen) {\n  if (pendingPostFlushCbs.length) {\n    const deduped = [...new Set(pendingPostFlushCbs)].sort(\n      (a, b) => getId(a) - getId(b)\n    );\n    pendingPostFlushCbs.length = 0;\n    if (activePostFlushCbs) {\n      activePostFlushCbs.push(...deduped);\n      return;\n    }\n    activePostFlushCbs = deduped;\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      seen = seen || /* @__PURE__ */ new Map();\n    }\n    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {\n      if (!!(process.env.NODE_ENV !== \"production\") && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {\n        continue;\n      }\n      activePostFlushCbs[postFlushIndex]();\n    }\n    activePostFlushCbs = null;\n    postFlushIndex = 0;\n  }\n}\nconst getId = (job) => job.id == null ? Infinity : job.id;\nconst comparator = (a, b) => {\n  const diff = getId(a) - getId(b);\n  if (diff === 0) {\n    if (a.pre && !b.pre)\n      return -1;\n    if (b.pre && !a.pre)\n      return 1;\n  }\n  return diff;\n};\nfunction flushJobs(seen) {\n  isFlushPending = false;\n  isFlushing = true;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    seen = seen || /* @__PURE__ */ new Map();\n  }\n  queue.sort(comparator);\n  const check = !!(process.env.NODE_ENV !== \"production\") ? (job) => checkRecursiveUpdates(seen, job) : NOOP;\n  try {\n    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {\n      const job = queue[flushIndex];\n      if (job && job.active !== false) {\n        if (!!(process.env.NODE_ENV !== \"production\") && check(job)) {\n          continue;\n        }\n        callWithErrorHandling(job, null, 14);\n      }\n    }\n  } finally {\n    flushIndex = 0;\n    queue.length = 0;\n    flushPostFlushCbs(seen);\n    isFlushing = false;\n    currentFlushPromise = null;\n    if (queue.length || pendingPostFlushCbs.length) {\n      flushJobs(seen);\n    }\n  }\n}\nfunction checkRecursiveUpdates(seen, fn) {\n  if (!seen.has(fn)) {\n    seen.set(fn, 1);\n  } else {\n    const count = seen.get(fn);\n    if (count > RECURSION_LIMIT) {\n      const instance = fn.ownerInstance;\n      const componentName = instance && getComponentName(instance.type);\n      handleError(\n        `Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,\n        null,\n        10\n      );\n      return true;\n    } else {\n      seen.set(fn, count + 1);\n    }\n  }\n}\n\nlet isHmrUpdating = false;\nconst hmrDirtyComponents = /* @__PURE__ */ new Set();\nif (!!(process.env.NODE_ENV !== \"production\")) {\n  getGlobalThis().__VUE_HMR_RUNTIME__ = {\n    createRecord: tryWrap(createRecord),\n    rerender: tryWrap(rerender),\n    reload: tryWrap(reload)\n  };\n}\nconst map = /* @__PURE__ */ new Map();\nfunction registerHMR(instance) {\n  const id = instance.type.__hmrId;\n  let record = map.get(id);\n  if (!record) {\n    createRecord(id, instance.type);\n    record = map.get(id);\n  }\n  record.instances.add(instance);\n}\nfunction unregisterHMR(instance) {\n  map.get(instance.type.__hmrId).instances.delete(instance);\n}\nfunction createRecord(id, initialDef) {\n  if (map.has(id)) {\n    return false;\n  }\n  map.set(id, {\n    initialDef: normalizeClassComponent(initialDef),\n    instances: /* @__PURE__ */ new Set()\n  });\n  return true;\n}\nfunction normalizeClassComponent(component) {\n  return isClassComponent(component) ? component.__vccOpts : component;\n}\nfunction rerender(id, newRender) {\n  const record = map.get(id);\n  if (!record) {\n    return;\n  }\n  record.initialDef.render = newRender;\n  [...record.instances].forEach((instance) => {\n    if (newRender) {\n      instance.render = newRender;\n      normalizeClassComponent(instance.type).render = newRender;\n    }\n    instance.renderCache = [];\n    isHmrUpdating = true;\n    instance.effect.dirty = true;\n    instance.update();\n    isHmrUpdating = false;\n  });\n}\nfunction reload(id, newComp) {\n  const record = map.get(id);\n  if (!record)\n    return;\n  newComp = normalizeClassComponent(newComp);\n  updateComponentDef(record.initialDef, newComp);\n  const instances = [...record.instances];\n  for (const instance of instances) {\n    const oldComp = normalizeClassComponent(instance.type);\n    if (!hmrDirtyComponents.has(oldComp)) {\n      if (oldComp !== record.initialDef) {\n        updateComponentDef(oldComp, newComp);\n      }\n      hmrDirtyComponents.add(oldComp);\n    }\n    instance.appContext.propsCache.delete(instance.type);\n    instance.appContext.emitsCache.delete(instance.type);\n    instance.appContext.optionsCache.delete(instance.type);\n    if (instance.ceReload) {\n      hmrDirtyComponents.add(oldComp);\n      instance.ceReload(newComp.styles);\n      hmrDirtyComponents.delete(oldComp);\n    } else if (instance.parent) {\n      instance.parent.effect.dirty = true;\n      queueJob(instance.parent.update);\n    } else if (instance.appContext.reload) {\n      instance.appContext.reload();\n    } else if (typeof window !== \"undefined\") {\n      window.location.reload();\n    } else {\n      console.warn(\n        \"[HMR] Root or manually mounted instance modified. Full reload required.\"\n      );\n    }\n  }\n  queuePostFlushCb(() => {\n    for (const instance of instances) {\n      hmrDirtyComponents.delete(\n        normalizeClassComponent(instance.type)\n      );\n    }\n  });\n}\nfunction updateComponentDef(oldComp, newComp) {\n  extend(oldComp, newComp);\n  for (const key in oldComp) {\n    if (key !== \"__file\" && !(key in newComp)) {\n      delete oldComp[key];\n    }\n  }\n}\nfunction tryWrap(fn) {\n  return (id, arg) => {\n    try {\n      return fn(id, arg);\n    } catch (e) {\n      console.error(e);\n      console.warn(\n        `[HMR] Something went wrong during Vue component hot-reload. Full reload required.`\n      );\n    }\n  };\n}\n\nlet devtools$1;\nlet buffer = [];\nlet devtoolsNotInstalled = false;\nfunction emit$1(event, ...args) {\n  if (devtools$1) {\n    devtools$1.emit(event, ...args);\n  } else if (!devtoolsNotInstalled) {\n    buffer.push({ event, args });\n  }\n}\nfunction setDevtoolsHook$1(hook, target) {\n  var _a, _b;\n  devtools$1 = hook;\n  if (devtools$1) {\n    devtools$1.enabled = true;\n    buffer.forEach(({ event, args }) => devtools$1.emit(event, ...args));\n    buffer = [];\n  } else if (\n    // handle late devtools injection - only do this if we are in an actual\n    // browser environment to avoid the timer handle stalling test runner exit\n    // (#4815)\n    typeof window !== \"undefined\" && // some envs mock window but not fully\n    window.HTMLElement && // also exclude jsdom\n    !((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes(\"jsdom\"))\n  ) {\n    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];\n    replay.push((newHook) => {\n      setDevtoolsHook$1(newHook, target);\n    });\n    setTimeout(() => {\n      if (!devtools$1) {\n        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;\n        devtoolsNotInstalled = true;\n        buffer = [];\n      }\n    }, 3e3);\n  } else {\n    devtoolsNotInstalled = true;\n    buffer = [];\n  }\n}\nfunction devtoolsInitApp(app, version) {\n  emit$1(\"app:init\" /* APP_INIT */, app, version, {\n    Fragment,\n    Text,\n    Comment,\n    Static\n  });\n}\nfunction devtoolsUnmountApp(app) {\n  emit$1(\"app:unmount\" /* APP_UNMOUNT */, app);\n}\nconst devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(\n  \"component:added\" /* COMPONENT_ADDED */\n);\nconst devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(\"component:updated\" /* COMPONENT_UPDATED */);\nconst _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(\n  \"component:removed\" /* COMPONENT_REMOVED */\n);\nconst devtoolsComponentRemoved = (component) => {\n  if (devtools$1 && typeof devtools$1.cleanupBuffer === \"function\" && // remove the component if it wasn't buffered\n  !devtools$1.cleanupBuffer(component)) {\n    _devtoolsComponentRemoved(component);\n  }\n};\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction createDevtoolsComponentHook(hook) {\n  return (component) => {\n    emit$1(\n      hook,\n      component.appContext.app,\n      component.uid,\n      component.parent ? component.parent.uid : void 0,\n      component\n    );\n  };\n}\nconst devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(\n  \"perf:start\" /* PERFORMANCE_START */\n);\nconst devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(\n  \"perf:end\" /* PERFORMANCE_END */\n);\nfunction createDevtoolsPerformanceHook(hook) {\n  return (component, type, time) => {\n    emit$1(hook, component.appContext.app, component.uid, component, type, time);\n  };\n}\nfunction devtoolsComponentEmit(component, event, params) {\n  emit$1(\n    \"component:emit\" /* COMPONENT_EMIT */,\n    component.appContext.app,\n    component,\n    event,\n    params\n  );\n}\n\nfunction emit(instance, event, ...rawArgs) {\n  if (instance.isUnmounted)\n    return;\n  const props = instance.vnode.props || EMPTY_OBJ;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const {\n      emitsOptions,\n      propsOptions: [propsOptions]\n    } = instance;\n    if (emitsOptions) {\n      if (!(event in emitsOptions) && true) {\n        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {\n          warn$1(\n            `Component emitted event \"${event}\" but it is neither declared in the emits option nor as an \"${toHandlerKey(event)}\" prop.`\n          );\n        }\n      } else {\n        const validator = emitsOptions[event];\n        if (isFunction(validator)) {\n          const isValid = validator(...rawArgs);\n          if (!isValid) {\n            warn$1(\n              `Invalid event arguments: event validation failed for event \"${event}\".`\n            );\n          }\n        }\n      }\n    }\n  }\n  let args = rawArgs;\n  const isModelListener = event.startsWith(\"update:\");\n  const modelArg = isModelListener && event.slice(7);\n  if (modelArg && modelArg in props) {\n    const modifiersKey = `${modelArg === \"modelValue\" ? \"model\" : modelArg}Modifiers`;\n    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;\n    if (trim) {\n      args = rawArgs.map((a) => isString(a) ? a.trim() : a);\n    }\n    if (number) {\n      args = rawArgs.map(looseToNumber);\n    }\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n    devtoolsComponentEmit(instance, event, args);\n  }\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const lowerCaseEvent = event.toLowerCase();\n    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {\n      warn$1(\n        `Event \"${lowerCaseEvent}\" is emitted in component ${formatComponentName(\n          instance,\n          instance.type\n        )} but the handler is registered for \"${event}\". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use \"${hyphenate(\n          event\n        )}\" instead of \"${event}\".`\n      );\n    }\n  }\n  let handlerName;\n  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)\n  props[handlerName = toHandlerKey(camelize(event))];\n  if (!handler && isModelListener) {\n    handler = props[handlerName = toHandlerKey(hyphenate(event))];\n  }\n  if (handler) {\n    callWithAsyncErrorHandling(\n      handler,\n      instance,\n      6,\n      args\n    );\n  }\n  const onceHandler = props[handlerName + `Once`];\n  if (onceHandler) {\n    if (!instance.emitted) {\n      instance.emitted = {};\n    } else if (instance.emitted[handlerName]) {\n      return;\n    }\n    instance.emitted[handlerName] = true;\n    callWithAsyncErrorHandling(\n      onceHandler,\n      instance,\n      6,\n      args\n    );\n  }\n}\nfunction normalizeEmitsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.emitsCache;\n  const cached = cache.get(comp);\n  if (cached !== void 0) {\n    return cached;\n  }\n  const raw = comp.emits;\n  let normalized = {};\n  let hasExtends = false;\n  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {\n    const extendEmits = (raw2) => {\n      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);\n      if (normalizedFromExtend) {\n        hasExtends = true;\n        extend(normalized, normalizedFromExtend);\n      }\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendEmits);\n    }\n    if (comp.extends) {\n      extendEmits(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendEmits);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if (isObject(comp)) {\n      cache.set(comp, null);\n    }\n    return null;\n  }\n  if (isArray(raw)) {\n    raw.forEach((key) => normalized[key] = null);\n  } else {\n    extend(normalized, raw);\n  }\n  if (isObject(comp)) {\n    cache.set(comp, normalized);\n  }\n  return normalized;\n}\nfunction isEmitListener(options, key) {\n  if (!options || !isOn(key)) {\n    return false;\n  }\n  key = key.slice(2).replace(/Once$/, \"\");\n  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);\n}\n\nlet currentRenderingInstance = null;\nlet currentScopeId = null;\nfunction setCurrentRenderingInstance(instance) {\n  const prev = currentRenderingInstance;\n  currentRenderingInstance = instance;\n  currentScopeId = instance && instance.type.__scopeId || null;\n  return prev;\n}\nfunction pushScopeId(id) {\n  currentScopeId = id;\n}\nfunction popScopeId() {\n  currentScopeId = null;\n}\nconst withScopeId = (_id) => withCtx;\nfunction withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {\n  if (!ctx)\n    return fn;\n  if (fn._n) {\n    return fn;\n  }\n  const renderFnWithContext = (...args) => {\n    if (renderFnWithContext._d) {\n      setBlockTracking(-1);\n    }\n    const prevInstance = setCurrentRenderingInstance(ctx);\n    let res;\n    try {\n      res = fn(...args);\n    } finally {\n      setCurrentRenderingInstance(prevInstance);\n      if (renderFnWithContext._d) {\n        setBlockTracking(1);\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      devtoolsComponentUpdated(ctx);\n    }\n    return res;\n  };\n  renderFnWithContext._n = true;\n  renderFnWithContext._c = true;\n  renderFnWithContext._d = true;\n  return renderFnWithContext;\n}\n\nlet accessedAttrs = false;\nfunction markAttrsAccessed() {\n  accessedAttrs = true;\n}\nfunction renderComponentRoot(instance) {\n  const {\n    type: Component,\n    vnode,\n    proxy,\n    withProxy,\n    propsOptions: [propsOptions],\n    slots,\n    attrs,\n    emit,\n    render,\n    renderCache,\n    props,\n    data,\n    setupState,\n    ctx,\n    inheritAttrs\n  } = instance;\n  const prev = setCurrentRenderingInstance(instance);\n  let result;\n  let fallthroughAttrs;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    accessedAttrs = false;\n  }\n  try {\n    if (vnode.shapeFlag & 4) {\n      const proxyToUse = withProxy || proxy;\n      const thisProxy = !!(process.env.NODE_ENV !== \"production\") && setupState.__isScriptSetup ? new Proxy(proxyToUse, {\n        get(target, key, receiver) {\n          warn$1(\n            `Property '${String(\n              key\n            )}' was accessed via 'this'. Avoid using 'this' in templates.`\n          );\n          return Reflect.get(target, key, receiver);\n        }\n      }) : proxyToUse;\n      result = normalizeVNode(\n        render.call(\n          thisProxy,\n          proxyToUse,\n          renderCache,\n          !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(props) : props,\n          setupState,\n          data,\n          ctx\n        )\n      );\n      fallthroughAttrs = attrs;\n    } else {\n      const render2 = Component;\n      if (!!(process.env.NODE_ENV !== \"production\") && attrs === props) {\n        markAttrsAccessed();\n      }\n      result = normalizeVNode(\n        render2.length > 1 ? render2(\n          !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(props) : props,\n          !!(process.env.NODE_ENV !== \"production\") ? {\n            get attrs() {\n              markAttrsAccessed();\n              return shallowReadonly(attrs);\n            },\n            slots,\n            emit\n          } : { attrs, slots, emit }\n        ) : render2(\n          !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(props) : props,\n          null\n        )\n      );\n      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);\n    }\n  } catch (err) {\n    blockStack.length = 0;\n    handleError(err, instance, 1);\n    result = createVNode(Comment);\n  }\n  let root = result;\n  let setRoot = void 0;\n  if (!!(process.env.NODE_ENV !== \"production\") && result.patchFlag > 0 && result.patchFlag & 2048) {\n    [root, setRoot] = getChildRoot(result);\n  }\n  if (fallthroughAttrs && inheritAttrs !== false) {\n    const keys = Object.keys(fallthroughAttrs);\n    const { shapeFlag } = root;\n    if (keys.length) {\n      if (shapeFlag & (1 | 6)) {\n        if (propsOptions && keys.some(isModelListener)) {\n          fallthroughAttrs = filterModelListeners(\n            fallthroughAttrs,\n            propsOptions\n          );\n        }\n        root = cloneVNode(root, fallthroughAttrs, false, true);\n      } else if (!!(process.env.NODE_ENV !== \"production\") && !accessedAttrs && root.type !== Comment) {\n        const allAttrs = Object.keys(attrs);\n        const eventAttrs = [];\n        const extraAttrs = [];\n        for (let i = 0, l = allAttrs.length; i < l; i++) {\n          const key = allAttrs[i];\n          if (isOn(key)) {\n            if (!isModelListener(key)) {\n              eventAttrs.push(key[2].toLowerCase() + key.slice(3));\n            }\n          } else {\n            extraAttrs.push(key);\n          }\n        }\n        if (extraAttrs.length) {\n          warn$1(\n            `Extraneous non-props attributes (${extraAttrs.join(\", \")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`\n          );\n        }\n        if (eventAttrs.length) {\n          warn$1(\n            `Extraneous non-emits event listeners (${eventAttrs.join(\", \")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the \"emits\" option.`\n          );\n        }\n      }\n    }\n  }\n  if (vnode.dirs) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !isElementRoot(root)) {\n      warn$1(\n        `Runtime directive used on component with non-element root node. The directives will not function as intended.`\n      );\n    }\n    root = cloneVNode(root, null, false, true);\n    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;\n  }\n  if (vnode.transition) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !isElementRoot(root)) {\n      warn$1(\n        `Component inside <Transition> renders non-element root node that cannot be animated.`\n      );\n    }\n    root.transition = vnode.transition;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && setRoot) {\n    setRoot(root);\n  } else {\n    result = root;\n  }\n  setCurrentRenderingInstance(prev);\n  return result;\n}\nconst getChildRoot = (vnode) => {\n  const rawChildren = vnode.children;\n  const dynamicChildren = vnode.dynamicChildren;\n  const childRoot = filterSingleRoot(rawChildren, false);\n  if (!childRoot) {\n    return [vnode, void 0];\n  } else if (!!(process.env.NODE_ENV !== \"production\") && childRoot.patchFlag > 0 && childRoot.patchFlag & 2048) {\n    return getChildRoot(childRoot);\n  }\n  const index = rawChildren.indexOf(childRoot);\n  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;\n  const setRoot = (updatedRoot) => {\n    rawChildren[index] = updatedRoot;\n    if (dynamicChildren) {\n      if (dynamicIndex > -1) {\n        dynamicChildren[dynamicIndex] = updatedRoot;\n      } else if (updatedRoot.patchFlag > 0) {\n        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];\n      }\n    }\n  };\n  return [normalizeVNode(childRoot), setRoot];\n};\nfunction filterSingleRoot(children, recurse = true) {\n  let singleRoot;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (isVNode(child)) {\n      if (child.type !== Comment || child.children === \"v-if\") {\n        if (singleRoot) {\n          return;\n        } else {\n          singleRoot = child;\n          if (!!(process.env.NODE_ENV !== \"production\") && recurse && singleRoot.patchFlag > 0 && singleRoot.patchFlag & 2048) {\n            return filterSingleRoot(singleRoot.children);\n          }\n        }\n      }\n    } else {\n      return;\n    }\n  }\n  return singleRoot;\n}\nconst getFunctionalFallthrough = (attrs) => {\n  let res;\n  for (const key in attrs) {\n    if (key === \"class\" || key === \"style\" || isOn(key)) {\n      (res || (res = {}))[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst filterModelListeners = (attrs, props) => {\n  const res = {};\n  for (const key in attrs) {\n    if (!isModelListener(key) || !(key.slice(9) in props)) {\n      res[key] = attrs[key];\n    }\n  }\n  return res;\n};\nconst isElementRoot = (vnode) => {\n  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;\n};\nfunction shouldUpdateComponent(prevVNode, nextVNode, optimized) {\n  const { props: prevProps, children: prevChildren, component } = prevVNode;\n  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;\n  const emits = component.emitsOptions;\n  if (!!(process.env.NODE_ENV !== \"production\") && (prevChildren || nextChildren) && isHmrUpdating) {\n    return true;\n  }\n  if (nextVNode.dirs || nextVNode.transition) {\n    return true;\n  }\n  if (optimized && patchFlag >= 0) {\n    if (patchFlag & 1024) {\n      return true;\n    }\n    if (patchFlag & 16) {\n      if (!prevProps) {\n        return !!nextProps;\n      }\n      return hasPropsChanged(prevProps, nextProps, emits);\n    } else if (patchFlag & 8) {\n      const dynamicProps = nextVNode.dynamicProps;\n      for (let i = 0; i < dynamicProps.length; i++) {\n        const key = dynamicProps[i];\n        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    if (prevChildren || nextChildren) {\n      if (!nextChildren || !nextChildren.$stable) {\n        return true;\n      }\n    }\n    if (prevProps === nextProps) {\n      return false;\n    }\n    if (!prevProps) {\n      return !!nextProps;\n    }\n    if (!nextProps) {\n      return true;\n    }\n    return hasPropsChanged(prevProps, nextProps, emits);\n  }\n  return false;\n}\nfunction hasPropsChanged(prevProps, nextProps, emitsOptions) {\n  const nextKeys = Object.keys(nextProps);\n  if (nextKeys.length !== Object.keys(prevProps).length) {\n    return true;\n  }\n  for (let i = 0; i < nextKeys.length; i++) {\n    const key = nextKeys[i];\n    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction updateHOCHostEl({ vnode, parent }, el) {\n  while (parent) {\n    const root = parent.subTree;\n    if (root.suspense && root.suspense.activeBranch === vnode) {\n      root.el = vnode.el;\n    }\n    if (root === vnode) {\n      (vnode = parent.vnode).el = el;\n      parent = parent.parent;\n    } else {\n      break;\n    }\n  }\n}\n\nconst COMPONENTS = \"components\";\nconst DIRECTIVES = \"directives\";\nfunction resolveComponent(name, maybeSelfReference) {\n  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;\n}\nconst NULL_DYNAMIC_COMPONENT = Symbol.for(\"v-ndc\");\nfunction resolveDynamicComponent(component) {\n  if (isString(component)) {\n    return resolveAsset(COMPONENTS, component, false) || component;\n  } else {\n    return component || NULL_DYNAMIC_COMPONENT;\n  }\n}\nfunction resolveDirective(name) {\n  return resolveAsset(DIRECTIVES, name);\n}\nfunction resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {\n  const instance = currentRenderingInstance || currentInstance;\n  if (instance) {\n    const Component = instance.type;\n    if (type === COMPONENTS) {\n      const selfName = getComponentName(\n        Component,\n        false\n      );\n      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {\n        return Component;\n      }\n    }\n    const res = (\n      // local registration\n      // check instance[type] first which is resolved for options API\n      resolve(instance[type] || Component[type], name) || // global registration\n      resolve(instance.appContext[type], name)\n    );\n    if (!res && maybeSelfReference) {\n      return Component;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") && warnMissing && !res) {\n      const extra = type === COMPONENTS ? `\nIf this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : ``;\n      warn$1(`Failed to resolve ${type.slice(0, -1)}: ${name}${extra}`);\n    }\n    return res;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(\n      `resolve${capitalize(type.slice(0, -1))} can only be used in render() or setup().`\n    );\n  }\n}\nfunction resolve(registry, name) {\n  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);\n}\n\nconst isSuspense = (type) => type.__isSuspense;\nlet suspenseId = 0;\nconst SuspenseImpl = {\n  name: \"Suspense\",\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode's type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {\n    if (n1 == null) {\n      mountSuspense(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized,\n        rendererInternals\n      );\n    } else {\n      if (parentSuspense && parentSuspense.deps > 0 && !n1.suspense.isInFallback) {\n        n2.suspense = n1.suspense;\n        n2.suspense.vnode = n2;\n        n2.el = n1.el;\n        return;\n      }\n      patchSuspense(\n        n1,\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        namespace,\n        slotScopeIds,\n        optimized,\n        rendererInternals\n      );\n    }\n  },\n  hydrate: hydrateSuspense,\n  create: createSuspenseBoundary,\n  normalize: normalizeSuspenseChildren\n};\nconst Suspense = SuspenseImpl ;\nfunction triggerEvent(vnode, name) {\n  const eventListener = vnode.props && vnode.props[name];\n  if (isFunction(eventListener)) {\n    eventListener();\n  }\n}\nfunction mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals) {\n  const {\n    p: patch,\n    o: { createElement }\n  } = rendererInternals;\n  const hiddenContainer = createElement(\"div\");\n  const suspense = vnode.suspense = createSuspenseBoundary(\n    vnode,\n    parentSuspense,\n    parentComponent,\n    container,\n    hiddenContainer,\n    anchor,\n    namespace,\n    slotScopeIds,\n    optimized,\n    rendererInternals\n  );\n  patch(\n    null,\n    suspense.pendingBranch = vnode.ssContent,\n    hiddenContainer,\n    null,\n    parentComponent,\n    suspense,\n    namespace,\n    slotScopeIds\n  );\n  if (suspense.deps > 0) {\n    triggerEvent(vnode, \"onPending\");\n    triggerEvent(vnode, \"onFallback\");\n    patch(\n      null,\n      vnode.ssFallback,\n      container,\n      anchor,\n      parentComponent,\n      null,\n      // fallback tree will not have suspense context\n      namespace,\n      slotScopeIds\n    );\n    setActiveBranch(suspense, vnode.ssFallback);\n  } else {\n    suspense.resolve(false, true);\n  }\n}\nfunction patchSuspense(n1, n2, container, anchor, parentComponent, namespace, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {\n  const suspense = n2.suspense = n1.suspense;\n  suspense.vnode = n2;\n  n2.el = n1.el;\n  const newBranch = n2.ssContent;\n  const newFallback = n2.ssFallback;\n  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;\n  if (pendingBranch) {\n    suspense.pendingBranch = newBranch;\n    if (isSameVNodeType(newBranch, pendingBranch)) {\n      patch(\n        pendingBranch,\n        newBranch,\n        suspense.hiddenContainer,\n        null,\n        parentComponent,\n        suspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else if (isInFallback) {\n        if (!isHydrating) {\n          patch(\n            activeBranch,\n            newFallback,\n            container,\n            anchor,\n            parentComponent,\n            null,\n            // fallback tree will not have suspense context\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          setActiveBranch(suspense, newFallback);\n        }\n      }\n    } else {\n      suspense.pendingId = suspenseId++;\n      if (isHydrating) {\n        suspense.isHydrating = false;\n        suspense.activeBranch = pendingBranch;\n      } else {\n        unmount(pendingBranch, parentComponent, suspense);\n      }\n      suspense.deps = 0;\n      suspense.effects.length = 0;\n      suspense.hiddenContainer = createElement(\"div\");\n      if (isInFallback) {\n        patch(\n          null,\n          newBranch,\n          suspense.hiddenContainer,\n          null,\n          parentComponent,\n          suspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        } else {\n          patch(\n            activeBranch,\n            newFallback,\n            container,\n            anchor,\n            parentComponent,\n            null,\n            // fallback tree will not have suspense context\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          setActiveBranch(suspense, newFallback);\n        }\n      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n        patch(\n          activeBranch,\n          newBranch,\n          container,\n          anchor,\n          parentComponent,\n          suspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        suspense.resolve(true);\n      } else {\n        patch(\n          null,\n          newBranch,\n          suspense.hiddenContainer,\n          null,\n          parentComponent,\n          suspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        if (suspense.deps <= 0) {\n          suspense.resolve();\n        }\n      }\n    }\n  } else {\n    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {\n      patch(\n        activeBranch,\n        newBranch,\n        container,\n        anchor,\n        parentComponent,\n        suspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n      setActiveBranch(suspense, newBranch);\n    } else {\n      triggerEvent(n2, \"onPending\");\n      suspense.pendingBranch = newBranch;\n      if (newBranch.shapeFlag & 512) {\n        suspense.pendingId = newBranch.component.suspenseId;\n      } else {\n        suspense.pendingId = suspenseId++;\n      }\n      patch(\n        null,\n        newBranch,\n        suspense.hiddenContainer,\n        null,\n        parentComponent,\n        suspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n      if (suspense.deps <= 0) {\n        suspense.resolve();\n      } else {\n        const { timeout, pendingId } = suspense;\n        if (timeout > 0) {\n          setTimeout(() => {\n            if (suspense.pendingId === pendingId) {\n              suspense.fallback(newFallback);\n            }\n          }, timeout);\n        } else if (timeout === 0) {\n          suspense.fallback(newFallback);\n        }\n      }\n    }\n  }\n}\nlet hasWarned = false;\nfunction createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, namespace, slotScopeIds, optimized, rendererInternals, isHydrating = false) {\n  if (!!(process.env.NODE_ENV !== \"production\") && true && !hasWarned) {\n    hasWarned = true;\n    console[console.info ? \"info\" : \"log\"](\n      `<Suspense> is an experimental feature and its API will likely change.`\n    );\n  }\n  const {\n    p: patch,\n    m: move,\n    um: unmount,\n    n: next,\n    o: { parentNode, remove }\n  } = rendererInternals;\n  let parentSuspenseId;\n  const isSuspensible = isVNodeSuspensible(vnode);\n  if (isSuspensible) {\n    if (parentSuspense && parentSuspense.pendingBranch) {\n      parentSuspenseId = parentSuspense.pendingId;\n      parentSuspense.deps++;\n    }\n  }\n  const timeout = vnode.props ? toNumber(vnode.props.timeout) : void 0;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    assertNumber(timeout, `Suspense timeout`);\n  }\n  const initialAnchor = anchor;\n  const suspense = {\n    vnode,\n    parent: parentSuspense,\n    parentComponent,\n    namespace,\n    container,\n    hiddenContainer,\n    deps: 0,\n    pendingId: suspenseId++,\n    timeout: typeof timeout === \"number\" ? timeout : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: !isHydrating,\n    isHydrating,\n    isUnmounted: false,\n    effects: [],\n    resolve(resume = false, sync = false) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        if (!resume && !suspense.pendingBranch) {\n          throw new Error(\n            `suspense.resolve() is called without a pending branch.`\n          );\n        }\n        if (suspense.isUnmounted) {\n          throw new Error(\n            `suspense.resolve() is called on an already unmounted suspense boundary.`\n          );\n        }\n      }\n      const {\n        vnode: vnode2,\n        activeBranch,\n        pendingBranch,\n        pendingId,\n        effects,\n        parentComponent: parentComponent2,\n        container: container2\n      } = suspense;\n      let delayEnter = false;\n      if (suspense.isHydrating) {\n        suspense.isHydrating = false;\n      } else if (!resume) {\n        delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === \"out-in\";\n        if (delayEnter) {\n          activeBranch.transition.afterLeave = () => {\n            if (pendingId === suspense.pendingId) {\n              move(\n                pendingBranch,\n                container2,\n                anchor === initialAnchor ? next(activeBranch) : anchor,\n                0\n              );\n              queuePostFlushCb(effects);\n            }\n          };\n        }\n        if (activeBranch) {\n          if (parentNode(activeBranch.el) !== suspense.hiddenContainer) {\n            anchor = next(activeBranch);\n          }\n          unmount(activeBranch, parentComponent2, suspense, true);\n        }\n        if (!delayEnter) {\n          move(pendingBranch, container2, anchor, 0);\n        }\n      }\n      setActiveBranch(suspense, pendingBranch);\n      suspense.pendingBranch = null;\n      suspense.isInFallback = false;\n      let parent = suspense.parent;\n      let hasUnresolvedAncestor = false;\n      while (parent) {\n        if (parent.pendingBranch) {\n          parent.effects.push(...effects);\n          hasUnresolvedAncestor = true;\n          break;\n        }\n        parent = parent.parent;\n      }\n      if (!hasUnresolvedAncestor && !delayEnter) {\n        queuePostFlushCb(effects);\n      }\n      suspense.effects = [];\n      if (isSuspensible) {\n        if (parentSuspense && parentSuspense.pendingBranch && parentSuspenseId === parentSuspense.pendingId) {\n          parentSuspense.deps--;\n          if (parentSuspense.deps === 0 && !sync) {\n            parentSuspense.resolve();\n          }\n        }\n      }\n      triggerEvent(vnode2, \"onResolve\");\n    },\n    fallback(fallbackVNode) {\n      if (!suspense.pendingBranch) {\n        return;\n      }\n      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, namespace: namespace2 } = suspense;\n      triggerEvent(vnode2, \"onFallback\");\n      const anchor2 = next(activeBranch);\n      const mountFallback = () => {\n        if (!suspense.isInFallback) {\n          return;\n        }\n        patch(\n          null,\n          fallbackVNode,\n          container2,\n          anchor2,\n          parentComponent2,\n          null,\n          // fallback tree will not have suspense context\n          namespace2,\n          slotScopeIds,\n          optimized\n        );\n        setActiveBranch(suspense, fallbackVNode);\n      };\n      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === \"out-in\";\n      if (delayEnter) {\n        activeBranch.transition.afterLeave = mountFallback;\n      }\n      suspense.isInFallback = true;\n      unmount(\n        activeBranch,\n        parentComponent2,\n        null,\n        // no suspense so unmount hooks fire now\n        true\n        // shouldRemove\n      );\n      if (!delayEnter) {\n        mountFallback();\n      }\n    },\n    move(container2, anchor2, type) {\n      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);\n      suspense.container = container2;\n    },\n    next() {\n      return suspense.activeBranch && next(suspense.activeBranch);\n    },\n    registerDep(instance, setupRenderEffect) {\n      const isInPendingSuspense = !!suspense.pendingBranch;\n      if (isInPendingSuspense) {\n        suspense.deps++;\n      }\n      const hydratedEl = instance.vnode.el;\n      instance.asyncDep.catch((err) => {\n        handleError(err, instance, 0);\n      }).then((asyncSetupResult) => {\n        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {\n          return;\n        }\n        instance.asyncResolved = true;\n        const { vnode: vnode2 } = instance;\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          pushWarningContext(vnode2);\n        }\n        handleSetupResult(instance, asyncSetupResult, false);\n        if (hydratedEl) {\n          vnode2.el = hydratedEl;\n        }\n        const placeholder = !hydratedEl && instance.subTree.el;\n        setupRenderEffect(\n          instance,\n          vnode2,\n          // component may have been moved before resolve.\n          // if this is not a hydration, instance.subTree will be the comment\n          // placeholder.\n          parentNode(hydratedEl || instance.subTree.el),\n          // anchor will not be used if this is hydration, so only need to\n          // consider the comment placeholder case.\n          hydratedEl ? null : next(instance.subTree),\n          suspense,\n          namespace,\n          optimized\n        );\n        if (placeholder) {\n          remove(placeholder);\n        }\n        updateHOCHostEl(instance, vnode2.el);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          popWarningContext();\n        }\n        if (isInPendingSuspense && --suspense.deps === 0) {\n          suspense.resolve();\n        }\n      });\n    },\n    unmount(parentSuspense2, doRemove) {\n      suspense.isUnmounted = true;\n      if (suspense.activeBranch) {\n        unmount(\n          suspense.activeBranch,\n          parentComponent,\n          parentSuspense2,\n          doRemove\n        );\n      }\n      if (suspense.pendingBranch) {\n        unmount(\n          suspense.pendingBranch,\n          parentComponent,\n          parentSuspense2,\n          doRemove\n        );\n      }\n    }\n  };\n  return suspense;\n}\nfunction hydrateSuspense(node, vnode, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, rendererInternals, hydrateNode) {\n  const suspense = vnode.suspense = createSuspenseBoundary(\n    vnode,\n    parentSuspense,\n    parentComponent,\n    node.parentNode,\n    // eslint-disable-next-line no-restricted-globals\n    document.createElement(\"div\"),\n    null,\n    namespace,\n    slotScopeIds,\n    optimized,\n    rendererInternals,\n    true\n  );\n  const result = hydrateNode(\n    node,\n    suspense.pendingBranch = vnode.ssContent,\n    parentComponent,\n    suspense,\n    slotScopeIds,\n    optimized\n  );\n  if (suspense.deps === 0) {\n    suspense.resolve(false, true);\n  }\n  return result;\n}\nfunction normalizeSuspenseChildren(vnode) {\n  const { shapeFlag, children } = vnode;\n  const isSlotChildren = shapeFlag & 32;\n  vnode.ssContent = normalizeSuspenseSlot(\n    isSlotChildren ? children.default : children\n  );\n  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);\n}\nfunction normalizeSuspenseSlot(s) {\n  let block;\n  if (isFunction(s)) {\n    const trackBlock = isBlockTreeEnabled && s._c;\n    if (trackBlock) {\n      s._d = false;\n      openBlock();\n    }\n    s = s();\n    if (trackBlock) {\n      s._d = true;\n      block = currentBlock;\n      closeBlock();\n    }\n  }\n  if (isArray(s)) {\n    const singleChild = filterSingleRoot(s);\n    if (!!(process.env.NODE_ENV !== \"production\") && !singleChild && s.filter((child) => child !== NULL_DYNAMIC_COMPONENT).length > 0) {\n      warn$1(`<Suspense> slots expect a single root node.`);\n    }\n    s = singleChild;\n  }\n  s = normalizeVNode(s);\n  if (block && !s.dynamicChildren) {\n    s.dynamicChildren = block.filter((c) => c !== s);\n  }\n  return s;\n}\nfunction queueEffectWithSuspense(fn, suspense) {\n  if (suspense && suspense.pendingBranch) {\n    if (isArray(fn)) {\n      suspense.effects.push(...fn);\n    } else {\n      suspense.effects.push(fn);\n    }\n  } else {\n    queuePostFlushCb(fn);\n  }\n}\nfunction setActiveBranch(suspense, branch) {\n  suspense.activeBranch = branch;\n  const { vnode, parentComponent } = suspense;\n  let el = branch.el;\n  while (!el && branch.component) {\n    branch = branch.component.subTree;\n    el = branch.el;\n  }\n  vnode.el = el;\n  if (parentComponent && parentComponent.subTree === vnode) {\n    parentComponent.vnode.el = el;\n    updateHOCHostEl(parentComponent, el);\n  }\n}\nfunction isVNodeSuspensible(vnode) {\n  const suspensible = vnode.props && vnode.props.suspensible;\n  return suspensible != null && suspensible !== false;\n}\n\nconst ssrContextKey = Symbol.for(\"v-scx\");\nconst useSSRContext = () => {\n  {\n    const ctx = inject(ssrContextKey);\n    if (!ctx) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(\n        `Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`\n      );\n    }\n    return ctx;\n  }\n};\n\nfunction watchEffect(effect, options) {\n  return doWatch(effect, null, options);\n}\nfunction watchPostEffect(effect, options) {\n  return doWatch(\n    effect,\n    null,\n    !!(process.env.NODE_ENV !== \"production\") ? extend({}, options, { flush: \"post\" }) : { flush: \"post\" }\n  );\n}\nfunction watchSyncEffect(effect, options) {\n  return doWatch(\n    effect,\n    null,\n    !!(process.env.NODE_ENV !== \"production\") ? extend({}, options, { flush: \"sync\" }) : { flush: \"sync\" }\n  );\n}\nconst INITIAL_WATCHER_VALUE = {};\nfunction watch(source, cb, options) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isFunction(cb)) {\n    warn$1(\n      `\\`watch(fn, options?)\\` signature has been moved to a separate API. Use \\`watchEffect(fn, options?)\\` instead. \\`watch\\` now only supports \\`watch(source, cb, options?) signature.`\n    );\n  }\n  return doWatch(source, cb, options);\n}\nfunction doWatch(source, cb, {\n  immediate,\n  deep,\n  flush,\n  once,\n  onTrack,\n  onTrigger\n} = EMPTY_OBJ) {\n  if (cb && once) {\n    const _cb = cb;\n    cb = (...args) => {\n      _cb(...args);\n      unwatch();\n    };\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && deep !== void 0 && typeof deep === \"number\") {\n    warn$1(\n      `watch() \"deep\" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.`\n    );\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && !cb) {\n    if (immediate !== void 0) {\n      warn$1(\n        `watch() \"immediate\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n    if (deep !== void 0) {\n      warn$1(\n        `watch() \"deep\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n    if (once !== void 0) {\n      warn$1(\n        `watch() \"once\" option is only respected when using the watch(source, callback, options?) signature.`\n      );\n    }\n  }\n  const warnInvalidSource = (s) => {\n    warn$1(\n      `Invalid watch source: `,\n      s,\n      `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`\n    );\n  };\n  const instance = currentInstance;\n  const reactiveGetter = (source2) => deep === true ? source2 : (\n    // for deep: false, only traverse root-level properties\n    traverse(source2, deep === false ? 1 : void 0)\n  );\n  let getter;\n  let forceTrigger = false;\n  let isMultiSource = false;\n  if (isRef(source)) {\n    getter = () => source.value;\n    forceTrigger = isShallow(source);\n  } else if (isReactive(source)) {\n    getter = () => reactiveGetter(source);\n    forceTrigger = true;\n  } else if (isArray(source)) {\n    isMultiSource = true;\n    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));\n    getter = () => source.map((s) => {\n      if (isRef(s)) {\n        return s.value;\n      } else if (isReactive(s)) {\n        return reactiveGetter(s);\n      } else if (isFunction(s)) {\n        return callWithErrorHandling(s, instance, 2);\n      } else {\n        !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(s);\n      }\n    });\n  } else if (isFunction(source)) {\n    if (cb) {\n      getter = () => callWithErrorHandling(source, instance, 2);\n    } else {\n      getter = () => {\n        if (cleanup) {\n          cleanup();\n        }\n        return callWithAsyncErrorHandling(\n          source,\n          instance,\n          3,\n          [onCleanup]\n        );\n      };\n    }\n  } else {\n    getter = NOOP;\n    !!(process.env.NODE_ENV !== \"production\") && warnInvalidSource(source);\n  }\n  if (cb && deep) {\n    const baseGetter = getter;\n    getter = () => traverse(baseGetter());\n  }\n  let cleanup;\n  let onCleanup = (fn) => {\n    cleanup = effect.onStop = () => {\n      callWithErrorHandling(fn, instance, 4);\n      cleanup = effect.onStop = void 0;\n    };\n  };\n  let ssrCleanup;\n  if (isInSSRComponentSetup) {\n    onCleanup = NOOP;\n    if (!cb) {\n      getter();\n    } else if (immediate) {\n      callWithAsyncErrorHandling(cb, instance, 3, [\n        getter(),\n        isMultiSource ? [] : void 0,\n        onCleanup\n      ]);\n    }\n    if (flush === \"sync\") {\n      const ctx = useSSRContext();\n      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);\n    } else {\n      return NOOP;\n    }\n  }\n  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;\n  const job = () => {\n    if (!effect.active || !effect.dirty) {\n      return;\n    }\n    if (cb) {\n      const newValue = effect.run();\n      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {\n        if (cleanup) {\n          cleanup();\n        }\n        callWithAsyncErrorHandling(cb, instance, 3, [\n          newValue,\n          // pass undefined as the old value when it's changed for the first time\n          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,\n          onCleanup\n        ]);\n        oldValue = newValue;\n      }\n    } else {\n      effect.run();\n    }\n  };\n  job.allowRecurse = !!cb;\n  let scheduler;\n  if (flush === \"sync\") {\n    scheduler = job;\n  } else if (flush === \"post\") {\n    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);\n  } else {\n    job.pre = true;\n    if (instance)\n      job.id = instance.uid;\n    scheduler = () => queueJob(job);\n  }\n  const effect = new ReactiveEffect(getter, NOOP, scheduler);\n  const scope = getCurrentScope();\n  const unwatch = () => {\n    effect.stop();\n    if (scope) {\n      remove(scope.effects, effect);\n    }\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    effect.onTrack = onTrack;\n    effect.onTrigger = onTrigger;\n  }\n  if (cb) {\n    if (immediate) {\n      job();\n    } else {\n      oldValue = effect.run();\n    }\n  } else if (flush === \"post\") {\n    queuePostRenderEffect(\n      effect.run.bind(effect),\n      instance && instance.suspense\n    );\n  } else {\n    effect.run();\n  }\n  if (ssrCleanup)\n    ssrCleanup.push(unwatch);\n  return unwatch;\n}\nfunction instanceWatch(source, value, options) {\n  const publicThis = this.proxy;\n  const getter = isString(source) ? source.includes(\".\") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);\n  let cb;\n  if (isFunction(value)) {\n    cb = value;\n  } else {\n    cb = value.handler;\n    options = value;\n  }\n  const reset = setCurrentInstance(this);\n  const res = doWatch(getter, cb.bind(publicThis), options);\n  reset();\n  return res;\n}\nfunction createPathGetter(ctx, path) {\n  const segments = path.split(\".\");\n  return () => {\n    let cur = ctx;\n    for (let i = 0; i < segments.length && cur; i++) {\n      cur = cur[segments[i]];\n    }\n    return cur;\n  };\n}\nfunction traverse(value, depth = Infinity, seen) {\n  if (depth <= 0 || !isObject(value) || value[\"__v_skip\"]) {\n    return value;\n  }\n  seen = seen || /* @__PURE__ */ new Set();\n  if (seen.has(value)) {\n    return value;\n  }\n  seen.add(value);\n  depth--;\n  if (isRef(value)) {\n    traverse(value.value, depth, seen);\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      traverse(value[i], depth, seen);\n    }\n  } else if (isSet(value) || isMap(value)) {\n    value.forEach((v) => {\n      traverse(v, depth, seen);\n    });\n  } else if (isPlainObject(value)) {\n    for (const key in value) {\n      traverse(value[key], depth, seen);\n    }\n  }\n  return value;\n}\n\nfunction validateDirectiveName(name) {\n  if (isBuiltInDirective(name)) {\n    warn$1(\"Do not use built-in directive ids as custom directive id: \" + name);\n  }\n}\nfunction withDirectives(vnode, directives) {\n  if (currentRenderingInstance === null) {\n    !!(process.env.NODE_ENV !== \"production\") && warn$1(`withDirectives can only be used inside render functions.`);\n    return vnode;\n  }\n  const instance = getExposeProxy(currentRenderingInstance) || currentRenderingInstance.proxy;\n  const bindings = vnode.dirs || (vnode.dirs = []);\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];\n    if (dir) {\n      if (isFunction(dir)) {\n        dir = {\n          mounted: dir,\n          updated: dir\n        };\n      }\n      if (dir.deep) {\n        traverse(value);\n      }\n      bindings.push({\n        dir,\n        instance,\n        value,\n        oldValue: void 0,\n        arg,\n        modifiers\n      });\n    }\n  }\n  return vnode;\n}\nfunction invokeDirectiveHook(vnode, prevVNode, instance, name) {\n  const bindings = vnode.dirs;\n  const oldBindings = prevVNode && prevVNode.dirs;\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i];\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value;\n    }\n    let hook = binding.dir[name];\n    if (hook) {\n      pauseTracking();\n      callWithAsyncErrorHandling(hook, instance, 8, [\n        vnode.el,\n        binding,\n        vnode,\n        prevVNode\n      ]);\n      resetTracking();\n    }\n  }\n}\n\nconst leaveCbKey = Symbol(\"_leaveCb\");\nconst enterCbKey = Symbol(\"_enterCb\");\nfunction useTransitionState() {\n  const state = {\n    isMounted: false,\n    isLeaving: false,\n    isUnmounting: false,\n    leavingVNodes: /* @__PURE__ */ new Map()\n  };\n  onMounted(() => {\n    state.isMounted = true;\n  });\n  onBeforeUnmount(() => {\n    state.isUnmounting = true;\n  });\n  return state;\n}\nconst TransitionHookValidator = [Function, Array];\nconst BaseTransitionPropsValidators = {\n  mode: String,\n  appear: Boolean,\n  persisted: Boolean,\n  // enter\n  onBeforeEnter: TransitionHookValidator,\n  onEnter: TransitionHookValidator,\n  onAfterEnter: TransitionHookValidator,\n  onEnterCancelled: TransitionHookValidator,\n  // leave\n  onBeforeLeave: TransitionHookValidator,\n  onLeave: TransitionHookValidator,\n  onAfterLeave: TransitionHookValidator,\n  onLeaveCancelled: TransitionHookValidator,\n  // appear\n  onBeforeAppear: TransitionHookValidator,\n  onAppear: TransitionHookValidator,\n  onAfterAppear: TransitionHookValidator,\n  onAppearCancelled: TransitionHookValidator\n};\nconst BaseTransitionImpl = {\n  name: `BaseTransition`,\n  props: BaseTransitionPropsValidators,\n  setup(props, { slots }) {\n    const instance = getCurrentInstance();\n    const state = useTransitionState();\n    return () => {\n      const children = slots.default && getTransitionRawChildren(slots.default(), true);\n      if (!children || !children.length) {\n        return;\n      }\n      let child = children[0];\n      if (children.length > 1) {\n        let hasFound = false;\n        for (const c of children) {\n          if (c.type !== Comment) {\n            if (!!(process.env.NODE_ENV !== \"production\") && hasFound) {\n              warn$1(\n                \"<transition> can only be used on a single element or component. Use <transition-group> for lists.\"\n              );\n              break;\n            }\n            child = c;\n            hasFound = true;\n            if (!!!(process.env.NODE_ENV !== \"production\"))\n              break;\n          }\n        }\n      }\n      const rawProps = toRaw(props);\n      const { mode } = rawProps;\n      if (!!(process.env.NODE_ENV !== \"production\") && mode && mode !== \"in-out\" && mode !== \"out-in\" && mode !== \"default\") {\n        warn$1(`invalid <transition> mode: ${mode}`);\n      }\n      if (state.isLeaving) {\n        return emptyPlaceholder(child);\n      }\n      const innerChild = getKeepAliveChild(child);\n      if (!innerChild) {\n        return emptyPlaceholder(child);\n      }\n      const enterHooks = resolveTransitionHooks(\n        innerChild,\n        rawProps,\n        state,\n        instance\n      );\n      setTransitionHooks(innerChild, enterHooks);\n      const oldChild = instance.subTree;\n      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);\n      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild)) {\n        const leavingHooks = resolveTransitionHooks(\n          oldInnerChild,\n          rawProps,\n          state,\n          instance\n        );\n        setTransitionHooks(oldInnerChild, leavingHooks);\n        if (mode === \"out-in\" && innerChild.type !== Comment) {\n          state.isLeaving = true;\n          leavingHooks.afterLeave = () => {\n            state.isLeaving = false;\n            if (instance.update.active !== false) {\n              instance.effect.dirty = true;\n              instance.update();\n            }\n          };\n          return emptyPlaceholder(child);\n        } else if (mode === \"in-out\" && innerChild.type !== Comment) {\n          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {\n            const leavingVNodesCache = getLeavingNodesForType(\n              state,\n              oldInnerChild\n            );\n            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;\n            el[leaveCbKey] = () => {\n              earlyRemove();\n              el[leaveCbKey] = void 0;\n              delete enterHooks.delayedLeave;\n            };\n            enterHooks.delayedLeave = delayedLeave;\n          };\n        }\n      }\n      return child;\n    };\n  }\n};\nconst BaseTransition = BaseTransitionImpl;\nfunction getLeavingNodesForType(state, vnode) {\n  const { leavingVNodes } = state;\n  let leavingVNodesCache = leavingVNodes.get(vnode.type);\n  if (!leavingVNodesCache) {\n    leavingVNodesCache = /* @__PURE__ */ Object.create(null);\n    leavingVNodes.set(vnode.type, leavingVNodesCache);\n  }\n  return leavingVNodesCache;\n}\nfunction resolveTransitionHooks(vnode, props, state, instance) {\n  const {\n    appear,\n    mode,\n    persisted = false,\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onEnterCancelled,\n    onBeforeLeave,\n    onLeave,\n    onAfterLeave,\n    onLeaveCancelled,\n    onBeforeAppear,\n    onAppear,\n    onAfterAppear,\n    onAppearCancelled\n  } = props;\n  const key = String(vnode.key);\n  const leavingVNodesCache = getLeavingNodesForType(state, vnode);\n  const callHook = (hook, args) => {\n    hook && callWithAsyncErrorHandling(\n      hook,\n      instance,\n      9,\n      args\n    );\n  };\n  const callAsyncHook = (hook, args) => {\n    const done = args[1];\n    callHook(hook, args);\n    if (isArray(hook)) {\n      if (hook.every((hook2) => hook2.length <= 1))\n        done();\n    } else if (hook.length <= 1) {\n      done();\n    }\n  };\n  const hooks = {\n    mode,\n    persisted,\n    beforeEnter(el) {\n      let hook = onBeforeEnter;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onBeforeAppear || onBeforeEnter;\n        } else {\n          return;\n        }\n      }\n      if (el[leaveCbKey]) {\n        el[leaveCbKey](\n          true\n          /* cancelled */\n        );\n      }\n      const leavingVNode = leavingVNodesCache[key];\n      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {\n        leavingVNode.el[leaveCbKey]();\n      }\n      callHook(hook, [el]);\n    },\n    enter(el) {\n      let hook = onEnter;\n      let afterHook = onAfterEnter;\n      let cancelHook = onEnterCancelled;\n      if (!state.isMounted) {\n        if (appear) {\n          hook = onAppear || onEnter;\n          afterHook = onAfterAppear || onAfterEnter;\n          cancelHook = onAppearCancelled || onEnterCancelled;\n        } else {\n          return;\n        }\n      }\n      let called = false;\n      const done = el[enterCbKey] = (cancelled) => {\n        if (called)\n          return;\n        called = true;\n        if (cancelled) {\n          callHook(cancelHook, [el]);\n        } else {\n          callHook(afterHook, [el]);\n        }\n        if (hooks.delayedLeave) {\n          hooks.delayedLeave();\n        }\n        el[enterCbKey] = void 0;\n      };\n      if (hook) {\n        callAsyncHook(hook, [el, done]);\n      } else {\n        done();\n      }\n    },\n    leave(el, remove) {\n      const key2 = String(vnode.key);\n      if (el[enterCbKey]) {\n        el[enterCbKey](\n          true\n          /* cancelled */\n        );\n      }\n      if (state.isUnmounting) {\n        return remove();\n      }\n      callHook(onBeforeLeave, [el]);\n      let called = false;\n      const done = el[leaveCbKey] = (cancelled) => {\n        if (called)\n          return;\n        called = true;\n        remove();\n        if (cancelled) {\n          callHook(onLeaveCancelled, [el]);\n        } else {\n          callHook(onAfterLeave, [el]);\n        }\n        el[leaveCbKey] = void 0;\n        if (leavingVNodesCache[key2] === vnode) {\n          delete leavingVNodesCache[key2];\n        }\n      };\n      leavingVNodesCache[key2] = vnode;\n      if (onLeave) {\n        callAsyncHook(onLeave, [el, done]);\n      } else {\n        done();\n      }\n    },\n    clone(vnode2) {\n      return resolveTransitionHooks(vnode2, props, state, instance);\n    }\n  };\n  return hooks;\n}\nfunction emptyPlaceholder(vnode) {\n  if (isKeepAlive(vnode)) {\n    vnode = cloneVNode(vnode);\n    vnode.children = null;\n    return vnode;\n  }\n}\nfunction getKeepAliveChild(vnode) {\n  if (!isKeepAlive(vnode)) {\n    return vnode;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && vnode.component) {\n    return vnode.component.subTree;\n  }\n  const { shapeFlag, children } = vnode;\n  if (children) {\n    if (shapeFlag & 16) {\n      return children[0];\n    }\n    if (shapeFlag & 32 && isFunction(children.default)) {\n      return children.default();\n    }\n  }\n}\nfunction setTransitionHooks(vnode, hooks) {\n  if (vnode.shapeFlag & 6 && vnode.component) {\n    setTransitionHooks(vnode.component.subTree, hooks);\n  } else if (vnode.shapeFlag & 128) {\n    vnode.ssContent.transition = hooks.clone(vnode.ssContent);\n    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);\n  } else {\n    vnode.transition = hooks;\n  }\n}\nfunction getTransitionRawChildren(children, keepComment = false, parentKey) {\n  let ret = [];\n  let keyedFragmentCount = 0;\n  for (let i = 0; i < children.length; i++) {\n    let child = children[i];\n    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);\n    if (child.type === Fragment) {\n      if (child.patchFlag & 128)\n        keyedFragmentCount++;\n      ret = ret.concat(\n        getTransitionRawChildren(child.children, keepComment, key)\n      );\n    } else if (keepComment || child.type !== Comment) {\n      ret.push(key != null ? cloneVNode(child, { key }) : child);\n    }\n  }\n  if (keyedFragmentCount > 1) {\n    for (let i = 0; i < ret.length; i++) {\n      ret[i].patchFlag = -2;\n    }\n  }\n  return ret;\n}\n\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineComponent(options, extraOptions) {\n  return isFunction(options) ? (\n    // #8326: extend call and options.name access are considered side-effects\n    // by Rollup, so we have to wrap it in a pure-annotated IIFE.\n    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()\n  ) : options;\n}\n\nconst isAsyncWrapper = (i) => !!i.type.__asyncLoader;\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineAsyncComponent(source) {\n  if (isFunction(source)) {\n    source = { loader: source };\n  }\n  const {\n    loader,\n    loadingComponent,\n    errorComponent,\n    delay = 200,\n    timeout,\n    // undefined = never times out\n    suspensible = true,\n    onError: userOnError\n  } = source;\n  let pendingRequest = null;\n  let resolvedComp;\n  let retries = 0;\n  const retry = () => {\n    retries++;\n    pendingRequest = null;\n    return load();\n  };\n  const load = () => {\n    let thisRequest;\n    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {\n      err = err instanceof Error ? err : new Error(String(err));\n      if (userOnError) {\n        return new Promise((resolve, reject) => {\n          const userRetry = () => resolve(retry());\n          const userFail = () => reject(err);\n          userOnError(err, userRetry, userFail, retries + 1);\n        });\n      } else {\n        throw err;\n      }\n    }).then((comp) => {\n      if (thisRequest !== pendingRequest && pendingRequest) {\n        return pendingRequest;\n      }\n      if (!!(process.env.NODE_ENV !== \"production\") && !comp) {\n        warn$1(\n          `Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`\n        );\n      }\n      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === \"Module\")) {\n        comp = comp.default;\n      }\n      if (!!(process.env.NODE_ENV !== \"production\") && comp && !isObject(comp) && !isFunction(comp)) {\n        throw new Error(`Invalid async component load result: ${comp}`);\n      }\n      resolvedComp = comp;\n      return comp;\n    }));\n  };\n  return defineComponent({\n    name: \"AsyncComponentWrapper\",\n    __asyncLoader: load,\n    get __asyncResolved() {\n      return resolvedComp;\n    },\n    setup() {\n      const instance = currentInstance;\n      if (resolvedComp) {\n        return () => createInnerComp(resolvedComp, instance);\n      }\n      const onError = (err) => {\n        pendingRequest = null;\n        handleError(\n          err,\n          instance,\n          13,\n          !errorComponent\n        );\n      };\n      if (suspensible && instance.suspense || isInSSRComponentSetup) {\n        return load().then((comp) => {\n          return () => createInnerComp(comp, instance);\n        }).catch((err) => {\n          onError(err);\n          return () => errorComponent ? createVNode(errorComponent, {\n            error: err\n          }) : null;\n        });\n      }\n      const loaded = ref(false);\n      const error = ref();\n      const delayed = ref(!!delay);\n      if (delay) {\n        setTimeout(() => {\n          delayed.value = false;\n        }, delay);\n      }\n      if (timeout != null) {\n        setTimeout(() => {\n          if (!loaded.value && !error.value) {\n            const err = new Error(\n              `Async component timed out after ${timeout}ms.`\n            );\n            onError(err);\n            error.value = err;\n          }\n        }, timeout);\n      }\n      load().then(() => {\n        loaded.value = true;\n        if (instance.parent && isKeepAlive(instance.parent.vnode)) {\n          instance.parent.effect.dirty = true;\n          queueJob(instance.parent.update);\n        }\n      }).catch((err) => {\n        onError(err);\n        error.value = err;\n      });\n      return () => {\n        if (loaded.value && resolvedComp) {\n          return createInnerComp(resolvedComp, instance);\n        } else if (error.value && errorComponent) {\n          return createVNode(errorComponent, {\n            error: error.value\n          });\n        } else if (loadingComponent && !delayed.value) {\n          return createVNode(loadingComponent);\n        }\n      };\n    }\n  });\n}\nfunction createInnerComp(comp, parent) {\n  const { ref: ref2, props, children, ce } = parent.vnode;\n  const vnode = createVNode(comp, props, children);\n  vnode.ref = ref2;\n  vnode.ce = ce;\n  delete parent.vnode.ce;\n  return vnode;\n}\n\nconst isKeepAlive = (vnode) => vnode.type.__isKeepAlive;\nconst KeepAliveImpl = {\n  name: `KeepAlive`,\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: true,\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n  setup(props, { slots }) {\n    const instance = getCurrentInstance();\n    const sharedContext = instance.ctx;\n    if (!sharedContext.renderer) {\n      return () => {\n        const children = slots.default && slots.default();\n        return children && children.length === 1 ? children[0] : children;\n      };\n    }\n    const cache = /* @__PURE__ */ new Map();\n    const keys = /* @__PURE__ */ new Set();\n    let current = null;\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      instance.__v_cache = cache;\n    }\n    const parentSuspense = instance.suspense;\n    const {\n      renderer: {\n        p: patch,\n        m: move,\n        um: _unmount,\n        o: { createElement }\n      }\n    } = sharedContext;\n    const storageContainer = createElement(\"div\");\n    sharedContext.activate = (vnode, container, anchor, namespace, optimized) => {\n      const instance2 = vnode.component;\n      move(vnode, container, anchor, 0, parentSuspense);\n      patch(\n        instance2.vnode,\n        vnode,\n        container,\n        anchor,\n        instance2,\n        parentSuspense,\n        namespace,\n        vnode.slotScopeIds,\n        optimized\n      );\n      queuePostRenderEffect(() => {\n        instance2.isDeactivated = false;\n        if (instance2.a) {\n          invokeArrayFns(instance2.a);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n      }, parentSuspense);\n      if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n        devtoolsComponentAdded(instance2);\n      }\n    };\n    sharedContext.deactivate = (vnode) => {\n      const instance2 = vnode.component;\n      move(vnode, storageContainer, null, 1, parentSuspense);\n      queuePostRenderEffect(() => {\n        if (instance2.da) {\n          invokeArrayFns(instance2.da);\n        }\n        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;\n        if (vnodeHook) {\n          invokeVNodeHook(vnodeHook, instance2.parent, vnode);\n        }\n        instance2.isDeactivated = true;\n      }, parentSuspense);\n      if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n        devtoolsComponentAdded(instance2);\n      }\n    };\n    function unmount(vnode) {\n      resetShapeFlag(vnode);\n      _unmount(vnode, instance, parentSuspense, true);\n    }\n    function pruneCache(filter) {\n      cache.forEach((vnode, key) => {\n        const name = getComponentName(vnode.type);\n        if (name && (!filter || !filter(name))) {\n          pruneCacheEntry(key);\n        }\n      });\n    }\n    function pruneCacheEntry(key) {\n      const cached = cache.get(key);\n      if (!current || !isSameVNodeType(cached, current)) {\n        unmount(cached);\n      } else if (current) {\n        resetShapeFlag(current);\n      }\n      cache.delete(key);\n      keys.delete(key);\n    }\n    watch(\n      () => [props.include, props.exclude],\n      ([include, exclude]) => {\n        include && pruneCache((name) => matches(include, name));\n        exclude && pruneCache((name) => !matches(exclude, name));\n      },\n      // prune post-render after `current` has been updated\n      { flush: \"post\", deep: true }\n    );\n    let pendingCacheKey = null;\n    const cacheSubtree = () => {\n      if (pendingCacheKey != null) {\n        cache.set(pendingCacheKey, getInnerChild(instance.subTree));\n      }\n    };\n    onMounted(cacheSubtree);\n    onUpdated(cacheSubtree);\n    onBeforeUnmount(() => {\n      cache.forEach((cached) => {\n        const { subTree, suspense } = instance;\n        const vnode = getInnerChild(subTree);\n        if (cached.type === vnode.type && cached.key === vnode.key) {\n          resetShapeFlag(vnode);\n          const da = vnode.component.da;\n          da && queuePostRenderEffect(da, suspense);\n          return;\n        }\n        unmount(cached);\n      });\n    });\n    return () => {\n      pendingCacheKey = null;\n      if (!slots.default) {\n        return null;\n      }\n      const children = slots.default();\n      const rawVNode = children[0];\n      if (children.length > 1) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(`KeepAlive should contain exactly one component child.`);\n        }\n        current = null;\n        return children;\n      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {\n        current = null;\n        return rawVNode;\n      }\n      let vnode = getInnerChild(rawVNode);\n      const comp = vnode.type;\n      const name = getComponentName(\n        isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp\n      );\n      const { include, exclude, max } = props;\n      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {\n        current = vnode;\n        return rawVNode;\n      }\n      const key = vnode.key == null ? comp : vnode.key;\n      const cachedVNode = cache.get(key);\n      if (vnode.el) {\n        vnode = cloneVNode(vnode);\n        if (rawVNode.shapeFlag & 128) {\n          rawVNode.ssContent = vnode;\n        }\n      }\n      pendingCacheKey = key;\n      if (cachedVNode) {\n        vnode.el = cachedVNode.el;\n        vnode.component = cachedVNode.component;\n        if (vnode.transition) {\n          setTransitionHooks(vnode, vnode.transition);\n        }\n        vnode.shapeFlag |= 512;\n        keys.delete(key);\n        keys.add(key);\n      } else {\n        keys.add(key);\n        if (max && keys.size > parseInt(max, 10)) {\n          pruneCacheEntry(keys.values().next().value);\n        }\n      }\n      vnode.shapeFlag |= 256;\n      current = vnode;\n      return isSuspense(rawVNode.type) ? rawVNode : vnode;\n    };\n  }\n};\nconst KeepAlive = KeepAliveImpl;\nfunction matches(pattern, name) {\n  if (isArray(pattern)) {\n    return pattern.some((p) => matches(p, name));\n  } else if (isString(pattern)) {\n    return pattern.split(\",\").includes(name);\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name);\n  }\n  return false;\n}\nfunction onActivated(hook, target) {\n  registerKeepAliveHook(hook, \"a\", target);\n}\nfunction onDeactivated(hook, target) {\n  registerKeepAliveHook(hook, \"da\", target);\n}\nfunction registerKeepAliveHook(hook, type, target = currentInstance) {\n  const wrappedHook = hook.__wdc || (hook.__wdc = () => {\n    let current = target;\n    while (current) {\n      if (current.isDeactivated) {\n        return;\n      }\n      current = current.parent;\n    }\n    return hook();\n  });\n  injectHook(type, wrappedHook, target);\n  if (target) {\n    let current = target.parent;\n    while (current && current.parent) {\n      if (isKeepAlive(current.parent.vnode)) {\n        injectToKeepAliveRoot(wrappedHook, type, target, current);\n      }\n      current = current.parent;\n    }\n  }\n}\nfunction injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {\n  const injected = injectHook(\n    type,\n    hook,\n    keepAliveRoot,\n    true\n    /* prepend */\n  );\n  onUnmounted(() => {\n    remove(keepAliveRoot[type], injected);\n  }, target);\n}\nfunction resetShapeFlag(vnode) {\n  vnode.shapeFlag &= ~256;\n  vnode.shapeFlag &= ~512;\n}\nfunction getInnerChild(vnode) {\n  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;\n}\n\nfunction injectHook(type, hook, target = currentInstance, prepend = false) {\n  if (target) {\n    const hooks = target[type] || (target[type] = []);\n    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {\n      if (target.isUnmounted) {\n        return;\n      }\n      pauseTracking();\n      const reset = setCurrentInstance(target);\n      const res = callWithAsyncErrorHandling(hook, target, type, args);\n      reset();\n      resetTracking();\n      return res;\n    });\n    if (prepend) {\n      hooks.unshift(wrappedHook);\n    } else {\n      hooks.push(wrappedHook);\n    }\n    return wrappedHook;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    const apiName = toHandlerKey(ErrorTypeStrings$1[type].replace(/ hook$/, \"\"));\n    warn$1(\n      `${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup().` + (` If you are using async setup(), make sure to register lifecycle hooks before the first await statement.` )\n    );\n  }\n}\nconst createHook = (lifecycle) => (hook, target = currentInstance) => (\n  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\n  (!isInSSRComponentSetup || lifecycle === \"sp\") && injectHook(lifecycle, (...args) => hook(...args), target)\n);\nconst onBeforeMount = createHook(\"bm\");\nconst onMounted = createHook(\"m\");\nconst onBeforeUpdate = createHook(\"bu\");\nconst onUpdated = createHook(\"u\");\nconst onBeforeUnmount = createHook(\"bum\");\nconst onUnmounted = createHook(\"um\");\nconst onServerPrefetch = createHook(\"sp\");\nconst onRenderTriggered = createHook(\n  \"rtg\"\n);\nconst onRenderTracked = createHook(\n  \"rtc\"\n);\nfunction onErrorCaptured(hook, target = currentInstance) {\n  injectHook(\"ec\", hook, target);\n}\n\nfunction renderList(source, renderItem, cache, index) {\n  let ret;\n  const cached = cache && cache[index];\n  if (isArray(source) || isString(source)) {\n    ret = new Array(source.length);\n    for (let i = 0, l = source.length; i < l; i++) {\n      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);\n    }\n  } else if (typeof source === \"number\") {\n    if (!!(process.env.NODE_ENV !== \"production\") && !Number.isInteger(source)) {\n      warn$1(`The v-for range expect an integer value but got ${source}.`);\n    }\n    ret = new Array(source);\n    for (let i = 0; i < source; i++) {\n      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);\n    }\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator]) {\n      ret = Array.from(\n        source,\n        (item, i) => renderItem(item, i, void 0, cached && cached[i])\n      );\n    } else {\n      const keys = Object.keys(source);\n      ret = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        ret[i] = renderItem(source[key], key, i, cached && cached[i]);\n      }\n    }\n  } else {\n    ret = [];\n  }\n  if (cache) {\n    cache[index] = ret;\n  }\n  return ret;\n}\n\nfunction createSlots(slots, dynamicSlots) {\n  for (let i = 0; i < dynamicSlots.length; i++) {\n    const slot = dynamicSlots[i];\n    if (isArray(slot)) {\n      for (let j = 0; j < slot.length; j++) {\n        slots[slot[j].name] = slot[j].fn;\n      }\n    } else if (slot) {\n      slots[slot.name] = slot.key ? (...args) => {\n        const res = slot.fn(...args);\n        if (res)\n          res.key = slot.key;\n        return res;\n      } : slot.fn;\n    }\n  }\n  return slots;\n}\n\nfunction renderSlot(slots, name, props = {}, fallback, noSlotted) {\n  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {\n    if (name !== \"default\")\n      props.name = name;\n    return createVNode(\"slot\", props, fallback && fallback());\n  }\n  let slot = slots[name];\n  if (!!(process.env.NODE_ENV !== \"production\") && slot && slot.length > 1) {\n    warn$1(\n      `SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`\n    );\n    slot = () => [];\n  }\n  if (slot && slot._c) {\n    slot._d = false;\n  }\n  openBlock();\n  const validSlotContent = slot && ensureValidVNode(slot(props));\n  const rendered = createBlock(\n    Fragment,\n    {\n      key: props.key || // slot content array of a dynamic conditional slot may have a branch\n      // key attached in the `createSlots` helper, respect that\n      validSlotContent && validSlotContent.key || `_${name}`\n    },\n    validSlotContent || (fallback ? fallback() : []),\n    validSlotContent && slots._ === 1 ? 64 : -2\n  );\n  if (!noSlotted && rendered.scopeId) {\n    rendered.slotScopeIds = [rendered.scopeId + \"-s\"];\n  }\n  if (slot && slot._c) {\n    slot._d = true;\n  }\n  return rendered;\n}\nfunction ensureValidVNode(vnodes) {\n  return vnodes.some((child) => {\n    if (!isVNode(child))\n      return true;\n    if (child.type === Comment)\n      return false;\n    if (child.type === Fragment && !ensureValidVNode(child.children))\n      return false;\n    return true;\n  }) ? vnodes : null;\n}\n\nfunction toHandlers(obj, preserveCaseIfNecessary) {\n  const ret = {};\n  if (!!(process.env.NODE_ENV !== \"production\") && !isObject(obj)) {\n    warn$1(`v-on with no argument expects an object value.`);\n    return ret;\n  }\n  for (const key in obj) {\n    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];\n  }\n  return ret;\n}\n\nconst getPublicInstance = (i) => {\n  if (!i)\n    return null;\n  if (isStatefulComponent(i))\n    return getExposeProxy(i) || i.proxy;\n  return getPublicInstance(i.parent);\n};\nconst publicPropertiesMap = (\n  // Move PURE marker to new line to workaround compiler discarding it\n  // due to type annotation\n  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {\n    $: (i) => i,\n    $el: (i) => i.vnode.el,\n    $data: (i) => i.data,\n    $props: (i) => !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(i.props) : i.props,\n    $attrs: (i) => !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(i.attrs) : i.attrs,\n    $slots: (i) => !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(i.slots) : i.slots,\n    $refs: (i) => !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(i.refs) : i.refs,\n    $parent: (i) => getPublicInstance(i.parent),\n    $root: (i) => getPublicInstance(i.root),\n    $emit: (i) => i.emit,\n    $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,\n    $forceUpdate: (i) => i.f || (i.f = () => {\n      i.effect.dirty = true;\n      queueJob(i.update);\n    }),\n    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),\n    $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP\n  })\n);\nconst isReservedPrefix = (key) => key === \"_\" || key === \"$\";\nconst hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);\nconst PublicInstanceProxyHandlers = {\n  get({ _: instance }, key) {\n    if (key === \"__v_skip\") {\n      return true;\n    }\n    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;\n    if (!!(process.env.NODE_ENV !== \"production\") && key === \"__isVue\") {\n      return true;\n    }\n    let normalizedProps;\n    if (key[0] !== \"$\") {\n      const n = accessCache[key];\n      if (n !== void 0) {\n        switch (n) {\n          case 1 /* SETUP */:\n            return setupState[key];\n          case 2 /* DATA */:\n            return data[key];\n          case 4 /* CONTEXT */:\n            return ctx[key];\n          case 3 /* PROPS */:\n            return props[key];\n        }\n      } else if (hasSetupBinding(setupState, key)) {\n        accessCache[key] = 1 /* SETUP */;\n        return setupState[key];\n      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n        accessCache[key] = 2 /* DATA */;\n        return data[key];\n      } else if (\n        // only cache other properties when instance has declared (thus stable)\n        // props\n        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)\n      ) {\n        accessCache[key] = 3 /* PROPS */;\n        return props[key];\n      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n        accessCache[key] = 4 /* CONTEXT */;\n        return ctx[key];\n      } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {\n        accessCache[key] = 0 /* OTHER */;\n      }\n    }\n    const publicGetter = publicPropertiesMap[key];\n    let cssModule, globalProperties;\n    if (publicGetter) {\n      if (key === \"$attrs\") {\n        track(instance.attrs, \"get\", \"\");\n        !!(process.env.NODE_ENV !== \"production\") && markAttrsAccessed();\n      } else if (!!(process.env.NODE_ENV !== \"production\") && key === \"$slots\") {\n        track(instance, \"get\", key);\n      }\n      return publicGetter(instance);\n    } else if (\n      // css module (injected by vue-loader)\n      (cssModule = type.__cssModules) && (cssModule = cssModule[key])\n    ) {\n      return cssModule;\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n      accessCache[key] = 4 /* CONTEXT */;\n      return ctx[key];\n    } else if (\n      // global properties\n      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)\n    ) {\n      {\n        return globalProperties[key];\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\") && currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading\n    // to infinite warning loop\n    key.indexOf(\"__v\") !== 0)) {\n      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {\n        warn$1(\n          `Property ${JSON.stringify(\n            key\n          )} must be accessed via $data because it starts with a reserved character (\"$\" or \"_\") and is not proxied on the render context.`\n        );\n      } else if (instance === currentRenderingInstance) {\n        warn$1(\n          `Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`\n        );\n      }\n    }\n  },\n  set({ _: instance }, key, value) {\n    const { data, setupState, ctx } = instance;\n    if (hasSetupBinding(setupState, key)) {\n      setupState[key] = value;\n      return true;\n    } else if (!!(process.env.NODE_ENV !== \"production\") && setupState.__isScriptSetup && hasOwn(setupState, key)) {\n      warn$1(`Cannot mutate <script setup> binding \"${key}\" from Options API.`);\n      return false;\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n      data[key] = value;\n      return true;\n    } else if (hasOwn(instance.props, key)) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(`Attempting to mutate prop \"${key}\". Props are readonly.`);\n      return false;\n    }\n    if (key[0] === \"$\" && key.slice(1) in instance) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(\n        `Attempting to mutate public property \"${key}\". Properties starting with $ are reserved and readonly.`\n      );\n      return false;\n    } else {\n      if (!!(process.env.NODE_ENV !== \"production\") && key in instance.appContext.config.globalProperties) {\n        Object.defineProperty(ctx, key, {\n          enumerable: true,\n          configurable: true,\n          value\n        });\n      } else {\n        ctx[key] = value;\n      }\n    }\n    return true;\n  },\n  has({\n    _: { data, setupState, accessCache, ctx, appContext, propsOptions }\n  }, key) {\n    let normalizedProps;\n    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);\n  },\n  defineProperty(target, key, descriptor) {\n    if (descriptor.get != null) {\n      target._.accessCache[key] = 0;\n    } else if (hasOwn(descriptor, \"value\")) {\n      this.set(target, key, descriptor.value, null);\n    }\n    return Reflect.defineProperty(target, key, descriptor);\n  }\n};\nif (!!(process.env.NODE_ENV !== \"production\") && true) {\n  PublicInstanceProxyHandlers.ownKeys = (target) => {\n    warn$1(\n      `Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`\n    );\n    return Reflect.ownKeys(target);\n  };\n}\nconst RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend(\n  {},\n  PublicInstanceProxyHandlers,\n  {\n    get(target, key) {\n      if (key === Symbol.unscopables) {\n        return;\n      }\n      return PublicInstanceProxyHandlers.get(target, key, target);\n    },\n    has(_, key) {\n      const has = key[0] !== \"_\" && !isGloballyAllowed(key);\n      if (!!(process.env.NODE_ENV !== \"production\") && !has && PublicInstanceProxyHandlers.has(_, key)) {\n        warn$1(\n          `Property ${JSON.stringify(\n            key\n          )} should not start with _ which is a reserved prefix for Vue internals.`\n        );\n      }\n      return has;\n    }\n  }\n);\nfunction createDevRenderContext(instance) {\n  const target = {};\n  Object.defineProperty(target, `_`, {\n    configurable: true,\n    enumerable: false,\n    get: () => instance\n  });\n  Object.keys(publicPropertiesMap).forEach((key) => {\n    Object.defineProperty(target, key, {\n      configurable: true,\n      enumerable: false,\n      get: () => publicPropertiesMap[key](instance),\n      // intercepted by the proxy so no need for implementation,\n      // but needed to prevent set errors\n      set: NOOP\n    });\n  });\n  return target;\n}\nfunction exposePropsOnRenderContext(instance) {\n  const {\n    ctx,\n    propsOptions: [propsOptions]\n  } = instance;\n  if (propsOptions) {\n    Object.keys(propsOptions).forEach((key) => {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => instance.props[key],\n        set: NOOP\n      });\n    });\n  }\n}\nfunction exposeSetupStateOnRenderContext(instance) {\n  const { ctx, setupState } = instance;\n  Object.keys(toRaw(setupState)).forEach((key) => {\n    if (!setupState.__isScriptSetup) {\n      if (isReservedPrefix(key[0])) {\n        warn$1(\n          `setup() return property ${JSON.stringify(\n            key\n          )} should not start with \"$\" or \"_\" which are reserved prefixes for Vue internals.`\n        );\n        return;\n      }\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => setupState[key],\n        set: NOOP\n      });\n    }\n  });\n}\n\nconst warnRuntimeUsage = (method) => warn$1(\n  `${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`\n);\nfunction defineProps() {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`defineProps`);\n  }\n  return null;\n}\nfunction defineEmits() {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`defineEmits`);\n  }\n  return null;\n}\nfunction defineExpose(exposed) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`defineExpose`);\n  }\n}\nfunction defineOptions(options) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`defineOptions`);\n  }\n}\nfunction defineSlots() {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`defineSlots`);\n  }\n  return null;\n}\nfunction defineModel() {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(\"defineModel\");\n  }\n}\nfunction withDefaults(props, defaults) {\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    warnRuntimeUsage(`withDefaults`);\n  }\n  return null;\n}\nfunction useSlots() {\n  return getContext().slots;\n}\nfunction useAttrs() {\n  return getContext().attrs;\n}\nfunction getContext() {\n  const i = getCurrentInstance();\n  if (!!(process.env.NODE_ENV !== \"production\") && !i) {\n    warn$1(`useContext() called without active instance.`);\n  }\n  return i.setupContext || (i.setupContext = createSetupContext(i));\n}\nfunction normalizePropsOrEmits(props) {\n  return isArray(props) ? props.reduce(\n    (normalized, p) => (normalized[p] = null, normalized),\n    {}\n  ) : props;\n}\nfunction mergeDefaults(raw, defaults) {\n  const props = normalizePropsOrEmits(raw);\n  for (const key in defaults) {\n    if (key.startsWith(\"__skip\"))\n      continue;\n    let opt = props[key];\n    if (opt) {\n      if (isArray(opt) || isFunction(opt)) {\n        opt = props[key] = { type: opt, default: defaults[key] };\n      } else {\n        opt.default = defaults[key];\n      }\n    } else if (opt === null) {\n      opt = props[key] = { default: defaults[key] };\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(`props default key \"${key}\" has no corresponding declaration.`);\n    }\n    if (opt && defaults[`__skip_${key}`]) {\n      opt.skipFactory = true;\n    }\n  }\n  return props;\n}\nfunction mergeModels(a, b) {\n  if (!a || !b)\n    return a || b;\n  if (isArray(a) && isArray(b))\n    return a.concat(b);\n  return extend({}, normalizePropsOrEmits(a), normalizePropsOrEmits(b));\n}\nfunction createPropsRestProxy(props, excludedKeys) {\n  const ret = {};\n  for (const key in props) {\n    if (!excludedKeys.includes(key)) {\n      Object.defineProperty(ret, key, {\n        enumerable: true,\n        get: () => props[key]\n      });\n    }\n  }\n  return ret;\n}\nfunction withAsyncContext(getAwaitable) {\n  const ctx = getCurrentInstance();\n  if (!!(process.env.NODE_ENV !== \"production\") && !ctx) {\n    warn$1(\n      `withAsyncContext called without active current instance. This is likely a bug.`\n    );\n  }\n  let awaitable = getAwaitable();\n  unsetCurrentInstance();\n  if (isPromise(awaitable)) {\n    awaitable = awaitable.catch((e) => {\n      setCurrentInstance(ctx);\n      throw e;\n    });\n  }\n  return [awaitable, () => setCurrentInstance(ctx)];\n}\n\nfunction createDuplicateChecker() {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (type, key) => {\n    if (cache[key]) {\n      warn$1(`${type} property \"${key}\" is already defined in ${cache[key]}.`);\n    } else {\n      cache[key] = type;\n    }\n  };\n}\nlet shouldCacheAccess = true;\nfunction applyOptions(instance) {\n  const options = resolveMergedOptions(instance);\n  const publicThis = instance.proxy;\n  const ctx = instance.ctx;\n  shouldCacheAccess = false;\n  if (options.beforeCreate) {\n    callHook(options.beforeCreate, instance, \"bc\");\n  }\n  const {\n    // state\n    data: dataOptions,\n    computed: computedOptions,\n    methods,\n    watch: watchOptions,\n    provide: provideOptions,\n    inject: injectOptions,\n    // lifecycle\n    created,\n    beforeMount,\n    mounted,\n    beforeUpdate,\n    updated,\n    activated,\n    deactivated,\n    beforeDestroy,\n    beforeUnmount,\n    destroyed,\n    unmounted,\n    render,\n    renderTracked,\n    renderTriggered,\n    errorCaptured,\n    serverPrefetch,\n    // public API\n    expose,\n    inheritAttrs,\n    // assets\n    components,\n    directives,\n    filters\n  } = options;\n  const checkDuplicateProperties = !!(process.env.NODE_ENV !== \"production\") ? createDuplicateChecker() : null;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const [propsOptions] = instance.propsOptions;\n    if (propsOptions) {\n      for (const key in propsOptions) {\n        checkDuplicateProperties(\"Props\" /* PROPS */, key);\n      }\n    }\n  }\n  if (injectOptions) {\n    resolveInjections(injectOptions, ctx, checkDuplicateProperties);\n  }\n  if (methods) {\n    for (const key in methods) {\n      const methodHandler = methods[key];\n      if (isFunction(methodHandler)) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          Object.defineProperty(ctx, key, {\n            value: methodHandler.bind(publicThis),\n            configurable: true,\n            enumerable: true,\n            writable: true\n          });\n        } else {\n          ctx[key] = methodHandler.bind(publicThis);\n        }\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          checkDuplicateProperties(\"Methods\" /* METHODS */, key);\n        }\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        warn$1(\n          `Method \"${key}\" has type \"${typeof methodHandler}\" in the component definition. Did you reference the function correctly?`\n        );\n      }\n    }\n  }\n  if (dataOptions) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !isFunction(dataOptions)) {\n      warn$1(\n        `The data option must be a function. Plain object usage is no longer supported.`\n      );\n    }\n    const data = dataOptions.call(publicThis, publicThis);\n    if (!!(process.env.NODE_ENV !== \"production\") && isPromise(data)) {\n      warn$1(\n        `data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`\n      );\n    }\n    if (!isObject(data)) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(`data() should return an object.`);\n    } else {\n      instance.data = reactive(data);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        for (const key in data) {\n          checkDuplicateProperties(\"Data\" /* DATA */, key);\n          if (!isReservedPrefix(key[0])) {\n            Object.defineProperty(ctx, key, {\n              configurable: true,\n              enumerable: true,\n              get: () => data[key],\n              set: NOOP\n            });\n          }\n        }\n      }\n    }\n  }\n  shouldCacheAccess = true;\n  if (computedOptions) {\n    for (const key in computedOptions) {\n      const opt = computedOptions[key];\n      const get = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;\n      if (!!(process.env.NODE_ENV !== \"production\") && get === NOOP) {\n        warn$1(`Computed property \"${key}\" has no getter.`);\n      }\n      const set = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : !!(process.env.NODE_ENV !== \"production\") ? () => {\n        warn$1(\n          `Write operation failed: computed property \"${key}\" is readonly.`\n        );\n      } : NOOP;\n      const c = computed({\n        get,\n        set\n      });\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => c.value,\n        set: (v) => c.value = v\n      });\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        checkDuplicateProperties(\"Computed\" /* COMPUTED */, key);\n      }\n    }\n  }\n  if (watchOptions) {\n    for (const key in watchOptions) {\n      createWatcher(watchOptions[key], ctx, publicThis, key);\n    }\n  }\n  if (provideOptions) {\n    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;\n    Reflect.ownKeys(provides).forEach((key) => {\n      provide(key, provides[key]);\n    });\n  }\n  if (created) {\n    callHook(created, instance, \"c\");\n  }\n  function registerLifecycleHook(register, hook) {\n    if (isArray(hook)) {\n      hook.forEach((_hook) => register(_hook.bind(publicThis)));\n    } else if (hook) {\n      register(hook.bind(publicThis));\n    }\n  }\n  registerLifecycleHook(onBeforeMount, beforeMount);\n  registerLifecycleHook(onMounted, mounted);\n  registerLifecycleHook(onBeforeUpdate, beforeUpdate);\n  registerLifecycleHook(onUpdated, updated);\n  registerLifecycleHook(onActivated, activated);\n  registerLifecycleHook(onDeactivated, deactivated);\n  registerLifecycleHook(onErrorCaptured, errorCaptured);\n  registerLifecycleHook(onRenderTracked, renderTracked);\n  registerLifecycleHook(onRenderTriggered, renderTriggered);\n  registerLifecycleHook(onBeforeUnmount, beforeUnmount);\n  registerLifecycleHook(onUnmounted, unmounted);\n  registerLifecycleHook(onServerPrefetch, serverPrefetch);\n  if (isArray(expose)) {\n    if (expose.length) {\n      const exposed = instance.exposed || (instance.exposed = {});\n      expose.forEach((key) => {\n        Object.defineProperty(exposed, key, {\n          get: () => publicThis[key],\n          set: (val) => publicThis[key] = val\n        });\n      });\n    } else if (!instance.exposed) {\n      instance.exposed = {};\n    }\n  }\n  if (render && instance.render === NOOP) {\n    instance.render = render;\n  }\n  if (inheritAttrs != null) {\n    instance.inheritAttrs = inheritAttrs;\n  }\n  if (components)\n    instance.components = components;\n  if (directives)\n    instance.directives = directives;\n}\nfunction resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {\n  if (isArray(injectOptions)) {\n    injectOptions = normalizeInject(injectOptions);\n  }\n  for (const key in injectOptions) {\n    const opt = injectOptions[key];\n    let injected;\n    if (isObject(opt)) {\n      if (\"default\" in opt) {\n        injected = inject(\n          opt.from || key,\n          opt.default,\n          true\n        );\n      } else {\n        injected = inject(opt.from || key);\n      }\n    } else {\n      injected = inject(opt);\n    }\n    if (isRef(injected)) {\n      Object.defineProperty(ctx, key, {\n        enumerable: true,\n        configurable: true,\n        get: () => injected.value,\n        set: (v) => injected.value = v\n      });\n    } else {\n      ctx[key] = injected;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      checkDuplicateProperties(\"Inject\" /* INJECT */, key);\n    }\n  }\n}\nfunction callHook(hook, instance, type) {\n  callWithAsyncErrorHandling(\n    isArray(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),\n    instance,\n    type\n  );\n}\nfunction createWatcher(raw, ctx, publicThis, key) {\n  const getter = key.includes(\".\") ? createPathGetter(publicThis, key) : () => publicThis[key];\n  if (isString(raw)) {\n    const handler = ctx[raw];\n    if (isFunction(handler)) {\n      watch(getter, handler);\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(`Invalid watch handler specified by key \"${raw}\"`, handler);\n    }\n  } else if (isFunction(raw)) {\n    watch(getter, raw.bind(publicThis));\n  } else if (isObject(raw)) {\n    if (isArray(raw)) {\n      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));\n    } else {\n      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];\n      if (isFunction(handler)) {\n        watch(getter, handler, raw);\n      } else if (!!(process.env.NODE_ENV !== \"production\")) {\n        warn$1(`Invalid watch handler specified by key \"${raw.handler}\"`, handler);\n      }\n    }\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(`Invalid watch option: \"${key}\"`, raw);\n  }\n}\nfunction resolveMergedOptions(instance) {\n  const base = instance.type;\n  const { mixins, extends: extendsOptions } = base;\n  const {\n    mixins: globalMixins,\n    optionsCache: cache,\n    config: { optionMergeStrategies }\n  } = instance.appContext;\n  const cached = cache.get(base);\n  let resolved;\n  if (cached) {\n    resolved = cached;\n  } else if (!globalMixins.length && !mixins && !extendsOptions) {\n    {\n      resolved = base;\n    }\n  } else {\n    resolved = {};\n    if (globalMixins.length) {\n      globalMixins.forEach(\n        (m) => mergeOptions(resolved, m, optionMergeStrategies, true)\n      );\n    }\n    mergeOptions(resolved, base, optionMergeStrategies);\n  }\n  if (isObject(base)) {\n    cache.set(base, resolved);\n  }\n  return resolved;\n}\nfunction mergeOptions(to, from, strats, asMixin = false) {\n  const { mixins, extends: extendsOptions } = from;\n  if (extendsOptions) {\n    mergeOptions(to, extendsOptions, strats, true);\n  }\n  if (mixins) {\n    mixins.forEach(\n      (m) => mergeOptions(to, m, strats, true)\n    );\n  }\n  for (const key in from) {\n    if (asMixin && key === \"expose\") {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(\n        `\"expose\" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`\n      );\n    } else {\n      const strat = internalOptionMergeStrats[key] || strats && strats[key];\n      to[key] = strat ? strat(to[key], from[key]) : from[key];\n    }\n  }\n  return to;\n}\nconst internalOptionMergeStrats = {\n  data: mergeDataFn,\n  props: mergeEmitsOrPropsOptions,\n  emits: mergeEmitsOrPropsOptions,\n  // objects\n  methods: mergeObjectOptions,\n  computed: mergeObjectOptions,\n  // lifecycle\n  beforeCreate: mergeAsArray,\n  created: mergeAsArray,\n  beforeMount: mergeAsArray,\n  mounted: mergeAsArray,\n  beforeUpdate: mergeAsArray,\n  updated: mergeAsArray,\n  beforeDestroy: mergeAsArray,\n  beforeUnmount: mergeAsArray,\n  destroyed: mergeAsArray,\n  unmounted: mergeAsArray,\n  activated: mergeAsArray,\n  deactivated: mergeAsArray,\n  errorCaptured: mergeAsArray,\n  serverPrefetch: mergeAsArray,\n  // assets\n  components: mergeObjectOptions,\n  directives: mergeObjectOptions,\n  // watch\n  watch: mergeWatchOptions,\n  // provide / inject\n  provide: mergeDataFn,\n  inject: mergeInject\n};\nfunction mergeDataFn(to, from) {\n  if (!from) {\n    return to;\n  }\n  if (!to) {\n    return from;\n  }\n  return function mergedDataFn() {\n    return (extend)(\n      isFunction(to) ? to.call(this, this) : to,\n      isFunction(from) ? from.call(this, this) : from\n    );\n  };\n}\nfunction mergeInject(to, from) {\n  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));\n}\nfunction normalizeInject(raw) {\n  if (isArray(raw)) {\n    const res = {};\n    for (let i = 0; i < raw.length; i++) {\n      res[raw[i]] = raw[i];\n    }\n    return res;\n  }\n  return raw;\n}\nfunction mergeAsArray(to, from) {\n  return to ? [...new Set([].concat(to, from))] : from;\n}\nfunction mergeObjectOptions(to, from) {\n  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;\n}\nfunction mergeEmitsOrPropsOptions(to, from) {\n  if (to) {\n    if (isArray(to) && isArray(from)) {\n      return [.../* @__PURE__ */ new Set([...to, ...from])];\n    }\n    return extend(\n      /* @__PURE__ */ Object.create(null),\n      normalizePropsOrEmits(to),\n      normalizePropsOrEmits(from != null ? from : {})\n    );\n  } else {\n    return from;\n  }\n}\nfunction mergeWatchOptions(to, from) {\n  if (!to)\n    return from;\n  if (!from)\n    return to;\n  const merged = extend(/* @__PURE__ */ Object.create(null), to);\n  for (const key in from) {\n    merged[key] = mergeAsArray(to[key], from[key]);\n  }\n  return merged;\n}\n\nfunction createAppContext() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: void 0,\n      warnHandler: void 0,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: /* @__PURE__ */ Object.create(null),\n    optionsCache: /* @__PURE__ */ new WeakMap(),\n    propsCache: /* @__PURE__ */ new WeakMap(),\n    emitsCache: /* @__PURE__ */ new WeakMap()\n  };\n}\nlet uid$1 = 0;\nfunction createAppAPI(render, hydrate) {\n  return function createApp(rootComponent, rootProps = null) {\n    if (!isFunction(rootComponent)) {\n      rootComponent = extend({}, rootComponent);\n    }\n    if (rootProps != null && !isObject(rootProps)) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(`root props passed to app.mount() must be an object.`);\n      rootProps = null;\n    }\n    const context = createAppContext();\n    const installedPlugins = /* @__PURE__ */ new WeakSet();\n    let isMounted = false;\n    const app = context.app = {\n      _uid: uid$1++,\n      _component: rootComponent,\n      _props: rootProps,\n      _container: null,\n      _context: context,\n      _instance: null,\n      version,\n      get config() {\n        return context.config;\n      },\n      set config(v) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\n            `app.config cannot be replaced. Modify individual options instead.`\n          );\n        }\n      },\n      use(plugin, ...options) {\n        if (installedPlugins.has(plugin)) {\n          !!(process.env.NODE_ENV !== \"production\") && warn$1(`Plugin has already been applied to target app.`);\n        } else if (plugin && isFunction(plugin.install)) {\n          installedPlugins.add(plugin);\n          plugin.install(app, ...options);\n        } else if (isFunction(plugin)) {\n          installedPlugins.add(plugin);\n          plugin(app, ...options);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\n            `A plugin must either be a function or an object with an \"install\" function.`\n          );\n        }\n        return app;\n      },\n      mixin(mixin) {\n        if (__VUE_OPTIONS_API__) {\n          if (!context.mixins.includes(mixin)) {\n            context.mixins.push(mixin);\n          } else if (!!(process.env.NODE_ENV !== \"production\")) {\n            warn$1(\n              \"Mixin has already been applied to target app\" + (mixin.name ? `: ${mixin.name}` : \"\")\n            );\n          }\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\"Mixins are only available in builds supporting Options API\");\n        }\n        return app;\n      },\n      component(name, component) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          validateComponentName(name, context.config);\n        }\n        if (!component) {\n          return context.components[name];\n        }\n        if (!!(process.env.NODE_ENV !== \"production\") && context.components[name]) {\n          warn$1(`Component \"${name}\" has already been registered in target app.`);\n        }\n        context.components[name] = component;\n        return app;\n      },\n      directive(name, directive) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          validateDirectiveName(name);\n        }\n        if (!directive) {\n          return context.directives[name];\n        }\n        if (!!(process.env.NODE_ENV !== \"production\") && context.directives[name]) {\n          warn$1(`Directive \"${name}\" has already been registered in target app.`);\n        }\n        context.directives[name] = directive;\n        return app;\n      },\n      mount(rootContainer, isHydrate, namespace) {\n        if (!isMounted) {\n          if (!!(process.env.NODE_ENV !== \"production\") && rootContainer.__vue_app__) {\n            warn$1(\n              `There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling \\`app.unmount()\\` first.`\n            );\n          }\n          const vnode = createVNode(rootComponent, rootProps);\n          vnode.appContext = context;\n          if (namespace === true) {\n            namespace = \"svg\";\n          } else if (namespace === false) {\n            namespace = void 0;\n          }\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            context.reload = () => {\n              render(\n                cloneVNode(vnode),\n                rootContainer,\n                namespace\n              );\n            };\n          }\n          if (isHydrate && hydrate) {\n            hydrate(vnode, rootContainer);\n          } else {\n            render(vnode, rootContainer, namespace);\n          }\n          isMounted = true;\n          app._container = rootContainer;\n          rootContainer.__vue_app__ = app;\n          if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n            app._instance = vnode.component;\n            devtoolsInitApp(app, version);\n          }\n          return getExposeProxy(vnode.component) || vnode.component.proxy;\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\n            `App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \\`const createMyApp = () => createApp(App)\\``\n          );\n        }\n      },\n      unmount() {\n        if (isMounted) {\n          render(null, app._container);\n          if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n            app._instance = null;\n            devtoolsUnmountApp(app);\n          }\n          delete app._container.__vue_app__;\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(`Cannot unmount an app that is not mounted.`);\n        }\n      },\n      provide(key, value) {\n        if (!!(process.env.NODE_ENV !== \"production\") && key in context.provides) {\n          warn$1(\n            `App already provides property with key \"${String(key)}\". It will be overwritten with the new value.`\n          );\n        }\n        context.provides[key] = value;\n        return app;\n      },\n      runWithContext(fn) {\n        const lastApp = currentApp;\n        currentApp = app;\n        try {\n          return fn();\n        } finally {\n          currentApp = lastApp;\n        }\n      }\n    };\n    return app;\n  };\n}\nlet currentApp = null;\n\nfunction provide(key, value) {\n  if (!currentInstance) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(`provide() can only be used inside setup().`);\n    }\n  } else {\n    let provides = currentInstance.provides;\n    const parentProvides = currentInstance.parent && currentInstance.parent.provides;\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides);\n    }\n    provides[key] = value;\n  }\n}\nfunction inject(key, defaultValue, treatDefaultAsFactory = false) {\n  const instance = currentInstance || currentRenderingInstance;\n  if (instance || currentApp) {\n    const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;\n    if (provides && key in provides) {\n      return provides[key];\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(`injection \"${String(key)}\" not found.`);\n    }\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(`inject() can only be used inside setup() or functional components.`);\n  }\n}\nfunction hasInjectionContext() {\n  return !!(currentInstance || currentRenderingInstance || currentApp);\n}\n\nconst internalObjectProto = {};\nconst createInternalObject = () => Object.create(internalObjectProto);\nconst isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;\n\nfunction initProps(instance, rawProps, isStateful, isSSR = false) {\n  const props = {};\n  const attrs = createInternalObject();\n  instance.propsDefaults = /* @__PURE__ */ Object.create(null);\n  setFullProps(instance, rawProps, props, attrs);\n  for (const key in instance.propsOptions[0]) {\n    if (!(key in props)) {\n      props[key] = void 0;\n    }\n  }\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    validateProps(rawProps || {}, props, instance);\n  }\n  if (isStateful) {\n    instance.props = isSSR ? props : shallowReactive(props);\n  } else {\n    if (!instance.type.props) {\n      instance.props = attrs;\n    } else {\n      instance.props = props;\n    }\n  }\n  instance.attrs = attrs;\n}\nfunction isInHmrContext(instance) {\n  while (instance) {\n    if (instance.type.__hmrId)\n      return true;\n    instance = instance.parent;\n  }\n}\nfunction updateProps(instance, rawProps, rawPrevProps, optimized) {\n  const {\n    props,\n    attrs,\n    vnode: { patchFlag }\n  } = instance;\n  const rawCurrentProps = toRaw(props);\n  const [options] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  if (\n    // always force full diff in dev\n    // - #1942 if hmr is enabled with sfc component\n    // - vite#872 non-sfc component used by sfc component\n    !(!!(process.env.NODE_ENV !== \"production\") && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16)\n  ) {\n    if (patchFlag & 8) {\n      const propsToUpdate = instance.vnode.dynamicProps;\n      for (let i = 0; i < propsToUpdate.length; i++) {\n        let key = propsToUpdate[i];\n        if (isEmitListener(instance.emitsOptions, key)) {\n          continue;\n        }\n        const value = rawProps[key];\n        if (options) {\n          if (hasOwn(attrs, key)) {\n            if (value !== attrs[key]) {\n              attrs[key] = value;\n              hasAttrsChanged = true;\n            }\n          } else {\n            const camelizedKey = camelize(key);\n            props[camelizedKey] = resolvePropValue(\n              options,\n              rawCurrentProps,\n              camelizedKey,\n              value,\n              instance,\n              false\n            );\n          }\n        } else {\n          if (value !== attrs[key]) {\n            attrs[key] = value;\n            hasAttrsChanged = true;\n          }\n        }\n      }\n    }\n  } else {\n    if (setFullProps(instance, rawProps, props, attrs)) {\n      hasAttrsChanged = true;\n    }\n    let kebabKey;\n    for (const key in rawCurrentProps) {\n      if (!rawProps || // for camelCase\n      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case\n      // and converted to camelCase (#955)\n      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {\n        if (options) {\n          if (rawPrevProps && // for camelCase\n          (rawPrevProps[key] !== void 0 || // for kebab-case\n          rawPrevProps[kebabKey] !== void 0)) {\n            props[key] = resolvePropValue(\n              options,\n              rawCurrentProps,\n              key,\n              void 0,\n              instance,\n              true\n            );\n          }\n        } else {\n          delete props[key];\n        }\n      }\n    }\n    if (attrs !== rawCurrentProps) {\n      for (const key in attrs) {\n        if (!rawProps || !hasOwn(rawProps, key) && true) {\n          delete attrs[key];\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (hasAttrsChanged) {\n    trigger(instance.attrs, \"set\", \"\");\n  }\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    validateProps(rawProps || {}, props, instance);\n  }\n}\nfunction setFullProps(instance, rawProps, props, attrs) {\n  const [options, needCastKeys] = instance.propsOptions;\n  let hasAttrsChanged = false;\n  let rawCastValues;\n  if (rawProps) {\n    for (let key in rawProps) {\n      if (isReservedProp(key)) {\n        continue;\n      }\n      const value = rawProps[key];\n      let camelKey;\n      if (options && hasOwn(options, camelKey = camelize(key))) {\n        if (!needCastKeys || !needCastKeys.includes(camelKey)) {\n          props[camelKey] = value;\n        } else {\n          (rawCastValues || (rawCastValues = {}))[camelKey] = value;\n        }\n      } else if (!isEmitListener(instance.emitsOptions, key)) {\n        if (!(key in attrs) || value !== attrs[key]) {\n          attrs[key] = value;\n          hasAttrsChanged = true;\n        }\n      }\n    }\n  }\n  if (needCastKeys) {\n    const rawCurrentProps = toRaw(props);\n    const castValues = rawCastValues || EMPTY_OBJ;\n    for (let i = 0; i < needCastKeys.length; i++) {\n      const key = needCastKeys[i];\n      props[key] = resolvePropValue(\n        options,\n        rawCurrentProps,\n        key,\n        castValues[key],\n        instance,\n        !hasOwn(castValues, key)\n      );\n    }\n  }\n  return hasAttrsChanged;\n}\nfunction resolvePropValue(options, props, key, value, instance, isAbsent) {\n  const opt = options[key];\n  if (opt != null) {\n    const hasDefault = hasOwn(opt, \"default\");\n    if (hasDefault && value === void 0) {\n      const defaultValue = opt.default;\n      if (opt.type !== Function && !opt.skipFactory && isFunction(defaultValue)) {\n        const { propsDefaults } = instance;\n        if (key in propsDefaults) {\n          value = propsDefaults[key];\n        } else {\n          const reset = setCurrentInstance(instance);\n          value = propsDefaults[key] = defaultValue.call(\n            null,\n            props\n          );\n          reset();\n        }\n      } else {\n        value = defaultValue;\n      }\n    }\n    if (opt[0 /* shouldCast */]) {\n      if (isAbsent && !hasDefault) {\n        value = false;\n      } else if (opt[1 /* shouldCastTrue */] && (value === \"\" || value === hyphenate(key))) {\n        value = true;\n      }\n    }\n  }\n  return value;\n}\nfunction normalizePropsOptions(comp, appContext, asMixin = false) {\n  const cache = appContext.propsCache;\n  const cached = cache.get(comp);\n  if (cached) {\n    return cached;\n  }\n  const raw = comp.props;\n  const normalized = {};\n  const needCastKeys = [];\n  let hasExtends = false;\n  if (__VUE_OPTIONS_API__ && !isFunction(comp)) {\n    const extendProps = (raw2) => {\n      hasExtends = true;\n      const [props, keys] = normalizePropsOptions(raw2, appContext, true);\n      extend(normalized, props);\n      if (keys)\n        needCastKeys.push(...keys);\n    };\n    if (!asMixin && appContext.mixins.length) {\n      appContext.mixins.forEach(extendProps);\n    }\n    if (comp.extends) {\n      extendProps(comp.extends);\n    }\n    if (comp.mixins) {\n      comp.mixins.forEach(extendProps);\n    }\n  }\n  if (!raw && !hasExtends) {\n    if (isObject(comp)) {\n      cache.set(comp, EMPTY_ARR);\n    }\n    return EMPTY_ARR;\n  }\n  if (isArray(raw)) {\n    for (let i = 0; i < raw.length; i++) {\n      if (!!(process.env.NODE_ENV !== \"production\") && !isString(raw[i])) {\n        warn$1(`props must be strings when using array syntax.`, raw[i]);\n      }\n      const normalizedKey = camelize(raw[i]);\n      if (validatePropName(normalizedKey)) {\n        normalized[normalizedKey] = EMPTY_OBJ;\n      }\n    }\n  } else if (raw) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !isObject(raw)) {\n      warn$1(`invalid props options`, raw);\n    }\n    for (const key in raw) {\n      const normalizedKey = camelize(key);\n      if (validatePropName(normalizedKey)) {\n        const opt = raw[key];\n        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : extend({}, opt);\n        if (prop) {\n          const booleanIndex = getTypeIndex(Boolean, prop.type);\n          const stringIndex = getTypeIndex(String, prop.type);\n          prop[0 /* shouldCast */] = booleanIndex > -1;\n          prop[1 /* shouldCastTrue */] = stringIndex < 0 || booleanIndex < stringIndex;\n          if (booleanIndex > -1 || hasOwn(prop, \"default\")) {\n            needCastKeys.push(normalizedKey);\n          }\n        }\n      }\n    }\n  }\n  const res = [normalized, needCastKeys];\n  if (isObject(comp)) {\n    cache.set(comp, res);\n  }\n  return res;\n}\nfunction validatePropName(key) {\n  if (key[0] !== \"$\" && !isReservedProp(key)) {\n    return true;\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn$1(`Invalid prop name: \"${key}\" is a reserved property.`);\n  }\n  return false;\n}\nfunction getType(ctor) {\n  if (ctor === null) {\n    return \"null\";\n  }\n  if (typeof ctor === \"function\") {\n    return ctor.name || \"\";\n  } else if (typeof ctor === \"object\") {\n    const name = ctor.constructor && ctor.constructor.name;\n    return name || \"\";\n  }\n  return \"\";\n}\nfunction isSameType(a, b) {\n  return getType(a) === getType(b);\n}\nfunction getTypeIndex(type, expectedTypes) {\n  if (isArray(expectedTypes)) {\n    return expectedTypes.findIndex((t) => isSameType(t, type));\n  } else if (isFunction(expectedTypes)) {\n    return isSameType(expectedTypes, type) ? 0 : -1;\n  }\n  return -1;\n}\nfunction validateProps(rawProps, props, instance) {\n  const resolvedValues = toRaw(props);\n  const options = instance.propsOptions[0];\n  for (const key in options) {\n    let opt = options[key];\n    if (opt == null)\n      continue;\n    validateProp(\n      key,\n      resolvedValues[key],\n      opt,\n      !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(resolvedValues) : resolvedValues,\n      !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key))\n    );\n  }\n}\nfunction validateProp(name, value, prop, props, isAbsent) {\n  const { type, required, validator, skipCheck } = prop;\n  if (required && isAbsent) {\n    warn$1('Missing required prop: \"' + name + '\"');\n    return;\n  }\n  if (value == null && !required) {\n    return;\n  }\n  if (type != null && type !== true && !skipCheck) {\n    let isValid = false;\n    const types = isArray(type) ? type : [type];\n    const expectedTypes = [];\n    for (let i = 0; i < types.length && !isValid; i++) {\n      const { valid, expectedType } = assertType(value, types[i]);\n      expectedTypes.push(expectedType || \"\");\n      isValid = valid;\n    }\n    if (!isValid) {\n      warn$1(getInvalidTypeMessage(name, value, expectedTypes));\n      return;\n    }\n  }\n  if (validator && !validator(value, props)) {\n    warn$1('Invalid prop: custom validator check failed for prop \"' + name + '\".');\n  }\n}\nconst isSimpleType = /* @__PURE__ */ makeMap(\n  \"String,Number,Boolean,Function,Symbol,BigInt\"\n);\nfunction assertType(value, type) {\n  let valid;\n  const expectedType = getType(type);\n  if (isSimpleType(expectedType)) {\n    const t = typeof value;\n    valid = t === expectedType.toLowerCase();\n    if (!valid && t === \"object\") {\n      valid = value instanceof type;\n    }\n  } else if (expectedType === \"Object\") {\n    valid = isObject(value);\n  } else if (expectedType === \"Array\") {\n    valid = isArray(value);\n  } else if (expectedType === \"null\") {\n    valid = value === null;\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid,\n    expectedType\n  };\n}\nfunction getInvalidTypeMessage(name, value, expectedTypes) {\n  if (expectedTypes.length === 0) {\n    return `Prop type [] for prop \"${name}\" won't match anything. Did you mean to use type Array instead?`;\n  }\n  let message = `Invalid prop: type check failed for prop \"${name}\". Expected ${expectedTypes.map(capitalize).join(\" | \")}`;\n  const expectedType = expectedTypes[0];\n  const receivedType = toRawType(value);\n  const expectedValue = styleValue(value, expectedType);\n  const receivedValue = styleValue(value, receivedType);\n  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {\n    message += ` with value ${expectedValue}`;\n  }\n  message += `, got ${receivedType} `;\n  if (isExplicable(receivedType)) {\n    message += `with value ${receivedValue}.`;\n  }\n  return message;\n}\nfunction styleValue(value, type) {\n  if (type === \"String\") {\n    return `\"${value}\"`;\n  } else if (type === \"Number\") {\n    return `${Number(value)}`;\n  } else {\n    return `${value}`;\n  }\n}\nfunction isExplicable(type) {\n  const explicitTypes = [\"string\", \"number\", \"boolean\"];\n  return explicitTypes.some((elem) => type.toLowerCase() === elem);\n}\nfunction isBoolean(...args) {\n  return args.some((elem) => elem.toLowerCase() === \"boolean\");\n}\n\nconst isInternalKey = (key) => key[0] === \"_\" || key === \"$stable\";\nconst normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];\nconst normalizeSlot = (key, rawSlot, ctx) => {\n  if (rawSlot._n) {\n    return rawSlot;\n  }\n  const normalized = withCtx((...args) => {\n    if (!!(process.env.NODE_ENV !== \"production\") && currentInstance && (!ctx || ctx.root === currentInstance.root)) {\n      warn$1(\n        `Slot \"${key}\" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`\n      );\n    }\n    return normalizeSlotValue(rawSlot(...args));\n  }, ctx);\n  normalized._c = false;\n  return normalized;\n};\nconst normalizeObjectSlots = (rawSlots, slots, instance) => {\n  const ctx = rawSlots._ctx;\n  for (const key in rawSlots) {\n    if (isInternalKey(key))\n      continue;\n    const value = rawSlots[key];\n    if (isFunction(value)) {\n      slots[key] = normalizeSlot(key, value, ctx);\n    } else if (value != null) {\n      if (!!(process.env.NODE_ENV !== \"production\") && true) {\n        warn$1(\n          `Non-function value encountered for slot \"${key}\". Prefer function slots for better performance.`\n        );\n      }\n      const normalized = normalizeSlotValue(value);\n      slots[key] = () => normalized;\n    }\n  }\n};\nconst normalizeVNodeSlots = (instance, children) => {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isKeepAlive(instance.vnode) && true) {\n    warn$1(\n      `Non-function value encountered for default slot. Prefer function slots for better performance.`\n    );\n  }\n  const normalized = normalizeSlotValue(children);\n  instance.slots.default = () => normalized;\n};\nconst initSlots = (instance, children) => {\n  const slots = instance.slots = createInternalObject();\n  if (instance.vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      extend(slots, children);\n      def(slots, \"_\", type, true);\n    } else {\n      normalizeObjectSlots(children, slots);\n    }\n  } else if (children) {\n    normalizeVNodeSlots(instance, children);\n  }\n};\nconst updateSlots = (instance, children, optimized) => {\n  const { vnode, slots } = instance;\n  let needDeletionCheck = true;\n  let deletionComparisonTarget = EMPTY_OBJ;\n  if (vnode.shapeFlag & 32) {\n    const type = children._;\n    if (type) {\n      if (!!(process.env.NODE_ENV !== \"production\") && isHmrUpdating) {\n        extend(slots, children);\n        trigger(instance, \"set\", \"$slots\");\n      } else if (optimized && type === 1) {\n        needDeletionCheck = false;\n      } else {\n        extend(slots, children);\n        if (!optimized && type === 1) {\n          delete slots._;\n        }\n      }\n    } else {\n      needDeletionCheck = !children.$stable;\n      normalizeObjectSlots(children, slots);\n    }\n    deletionComparisonTarget = children;\n  } else if (children) {\n    normalizeVNodeSlots(instance, children);\n    deletionComparisonTarget = { default: 1 };\n  }\n  if (needDeletionCheck) {\n    for (const key in slots) {\n      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {\n        delete slots[key];\n      }\n    }\n  }\n};\n\nfunction setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {\n  if (isArray(rawRef)) {\n    rawRef.forEach(\n      (r, i) => setRef(\n        r,\n        oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef),\n        parentSuspense,\n        vnode,\n        isUnmount\n      )\n    );\n    return;\n  }\n  if (isAsyncWrapper(vnode) && !isUnmount) {\n    return;\n  }\n  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;\n  const value = isUnmount ? null : refValue;\n  const { i: owner, r: ref } = rawRef;\n  if (!!(process.env.NODE_ENV !== \"production\") && !owner) {\n    warn$1(\n      `Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`\n    );\n    return;\n  }\n  const oldRef = oldRawRef && oldRawRef.r;\n  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;\n  const setupState = owner.setupState;\n  if (oldRef != null && oldRef !== ref) {\n    if (isString(oldRef)) {\n      refs[oldRef] = null;\n      if (hasOwn(setupState, oldRef)) {\n        setupState[oldRef] = null;\n      }\n    } else if (isRef(oldRef)) {\n      oldRef.value = null;\n    }\n  }\n  if (isFunction(ref)) {\n    callWithErrorHandling(ref, owner, 12, [value, refs]);\n  } else {\n    const _isString = isString(ref);\n    const _isRef = isRef(ref);\n    if (_isString || _isRef) {\n      const doSet = () => {\n        if (rawRef.f) {\n          const existing = _isString ? hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;\n          if (isUnmount) {\n            isArray(existing) && remove(existing, refValue);\n          } else {\n            if (!isArray(existing)) {\n              if (_isString) {\n                refs[ref] = [refValue];\n                if (hasOwn(setupState, ref)) {\n                  setupState[ref] = refs[ref];\n                }\n              } else {\n                ref.value = [refValue];\n                if (rawRef.k)\n                  refs[rawRef.k] = ref.value;\n              }\n            } else if (!existing.includes(refValue)) {\n              existing.push(refValue);\n            }\n          }\n        } else if (_isString) {\n          refs[ref] = value;\n          if (hasOwn(setupState, ref)) {\n            setupState[ref] = value;\n          }\n        } else if (_isRef) {\n          ref.value = value;\n          if (rawRef.k)\n            refs[rawRef.k] = value;\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\"Invalid template ref type:\", ref, `(${typeof ref})`);\n        }\n      };\n      if (value) {\n        doSet.id = -1;\n        queuePostRenderEffect(doSet, parentSuspense);\n      } else {\n        doSet();\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn$1(\"Invalid template ref type:\", ref, `(${typeof ref})`);\n    }\n  }\n}\n\nlet hasMismatch = false;\nconst isSVGContainer = (container) => container.namespaceURI.includes(\"svg\") && container.tagName !== \"foreignObject\";\nconst isMathMLContainer = (container) => container.namespaceURI.includes(\"MathML\");\nconst getContainerType = (container) => {\n  if (isSVGContainer(container))\n    return \"svg\";\n  if (isMathMLContainer(container))\n    return \"mathml\";\n  return void 0;\n};\nconst isComment = (node) => node.nodeType === 8 /* COMMENT */;\nfunction createHydrationFunctions(rendererInternals) {\n  const {\n    mt: mountComponent,\n    p: patch,\n    o: {\n      patchProp,\n      createText,\n      nextSibling,\n      parentNode,\n      remove,\n      insert,\n      createComment\n    }\n  } = rendererInternals;\n  const hydrate = (vnode, container) => {\n    if (!container.hasChildNodes()) {\n      (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(\n        `Attempting to hydrate existing markup but container is empty. Performing full mount instead.`\n      );\n      patch(null, vnode, container);\n      flushPostFlushCbs();\n      container._vnode = vnode;\n      return;\n    }\n    hasMismatch = false;\n    hydrateNode(container.firstChild, vnode, null, null, null);\n    flushPostFlushCbs();\n    container._vnode = vnode;\n    if (hasMismatch && true) {\n      console.error(`Hydration completed but contains mismatches.`);\n    }\n  };\n  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const isFragmentStart = isComment(node) && node.data === \"[\";\n    const onMismatch = () => handleMismatch(\n      node,\n      vnode,\n      parentComponent,\n      parentSuspense,\n      slotScopeIds,\n      isFragmentStart\n    );\n    const { type, ref, shapeFlag, patchFlag } = vnode;\n    let domType = node.nodeType;\n    vnode.el = node;\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      if (!(\"__vnode\" in node)) {\n        Object.defineProperty(node, \"__vnode\", {\n          value: vnode,\n          enumerable: false\n        });\n      }\n      if (!(\"__vueParentComponent\" in node)) {\n        Object.defineProperty(node, \"__vueParentComponent\", {\n          value: parentComponent,\n          enumerable: false\n        });\n      }\n    }\n    if (patchFlag === -2) {\n      optimized = false;\n      vnode.dynamicChildren = null;\n    }\n    let nextNode = null;\n    switch (type) {\n      case Text:\n        if (domType !== 3 /* TEXT */) {\n          if (vnode.children === \"\") {\n            insert(vnode.el = createText(\"\"), parentNode(node), node);\n            nextNode = node;\n          } else {\n            nextNode = onMismatch();\n          }\n        } else {\n          if (node.data !== vnode.children) {\n            hasMismatch = true;\n            (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(\n              `Hydration text mismatch in`,\n              node.parentNode,\n              `\n  - rendered on server: ${JSON.stringify(\n                node.data\n              )}\n  - expected on client: ${JSON.stringify(vnode.children)}`\n            );\n            node.data = vnode.children;\n          }\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Comment:\n        if (isTemplateNode(node)) {\n          nextNode = nextSibling(node);\n          replaceNode(\n            vnode.el = node.content.firstChild,\n            node,\n            parentComponent\n          );\n        } else if (domType !== 8 /* COMMENT */ || isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = nextSibling(node);\n        }\n        break;\n      case Static:\n        if (isFragmentStart) {\n          node = nextSibling(node);\n          domType = node.nodeType;\n        }\n        if (domType === 1 /* ELEMENT */ || domType === 3 /* TEXT */) {\n          nextNode = node;\n          const needToAdoptContent = !vnode.children.length;\n          for (let i = 0; i < vnode.staticCount; i++) {\n            if (needToAdoptContent)\n              vnode.children += nextNode.nodeType === 1 /* ELEMENT */ ? nextNode.outerHTML : nextNode.data;\n            if (i === vnode.staticCount - 1) {\n              vnode.anchor = nextNode;\n            }\n            nextNode = nextSibling(nextNode);\n          }\n          return isFragmentStart ? nextSibling(nextNode) : nextNode;\n        } else {\n          onMismatch();\n        }\n        break;\n      case Fragment:\n        if (!isFragmentStart) {\n          nextNode = onMismatch();\n        } else {\n          nextNode = hydrateFragment(\n            node,\n            vnode,\n            parentComponent,\n            parentSuspense,\n            slotScopeIds,\n            optimized\n          );\n        }\n        break;\n      default:\n        if (shapeFlag & 1) {\n          if ((domType !== 1 /* ELEMENT */ || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) && !isTemplateNode(node)) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = hydrateElement(\n              node,\n              vnode,\n              parentComponent,\n              parentSuspense,\n              slotScopeIds,\n              optimized\n            );\n          }\n        } else if (shapeFlag & 6) {\n          vnode.slotScopeIds = slotScopeIds;\n          const container = parentNode(node);\n          if (isFragmentStart) {\n            nextNode = locateClosingAnchor(node);\n          } else if (isComment(node) && node.data === \"teleport start\") {\n            nextNode = locateClosingAnchor(node, node.data, \"teleport end\");\n          } else {\n            nextNode = nextSibling(node);\n          }\n          mountComponent(\n            vnode,\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            getContainerType(container),\n            optimized\n          );\n          if (isAsyncWrapper(vnode)) {\n            let subTree;\n            if (isFragmentStart) {\n              subTree = createVNode(Fragment);\n              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;\n            } else {\n              subTree = node.nodeType === 3 ? createTextVNode(\"\") : createVNode(\"div\");\n            }\n            subTree.el = node;\n            vnode.component.subTree = subTree;\n          }\n        } else if (shapeFlag & 64) {\n          if (domType !== 8 /* COMMENT */) {\n            nextNode = onMismatch();\n          } else {\n            nextNode = vnode.type.hydrate(\n              node,\n              vnode,\n              parentComponent,\n              parentSuspense,\n              slotScopeIds,\n              optimized,\n              rendererInternals,\n              hydrateChildren\n            );\n          }\n        } else if (shapeFlag & 128) {\n          nextNode = vnode.type.hydrate(\n            node,\n            vnode,\n            parentComponent,\n            parentSuspense,\n            getContainerType(parentNode(node)),\n            slotScopeIds,\n            optimized,\n            rendererInternals,\n            hydrateNode\n          );\n        } else if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) {\n          warn$1(\"Invalid HostVNode type:\", type, `(${typeof type})`);\n        }\n    }\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode);\n    }\n    return nextNode;\n  };\n  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!vnode.dynamicChildren;\n    const { type, props, patchFlag, shapeFlag, dirs, transition } = vnode;\n    const forcePatch = type === \"input\" || type === \"option\";\n    if (!!(process.env.NODE_ENV !== \"production\") || forcePatch || patchFlag !== -1) {\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"created\");\n      }\n      let needCallTransitionHooks = false;\n      if (isTemplateNode(el)) {\n        needCallTransitionHooks = needTransition(parentSuspense, transition) && parentComponent && parentComponent.vnode.props && parentComponent.vnode.props.appear;\n        const content = el.content.firstChild;\n        if (needCallTransitionHooks) {\n          transition.beforeEnter(content);\n        }\n        replaceNode(content, el, parentComponent);\n        vnode.el = el = content;\n      }\n      if (shapeFlag & 16 && // skip if element has innerHTML / textContent\n      !(props && (props.innerHTML || props.textContent))) {\n        let next = hydrateChildren(\n          el.firstChild,\n          vnode,\n          el,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n        let hasWarned = false;\n        while (next) {\n          hasMismatch = true;\n          if ((!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && !hasWarned) {\n            warn$1(\n              `Hydration children mismatch on`,\n              el,\n              `\nServer rendered element contains more child nodes than client vdom.`\n            );\n            hasWarned = true;\n          }\n          const cur = next;\n          next = next.nextSibling;\n          remove(cur);\n        }\n      } else if (shapeFlag & 8) {\n        if (el.textContent !== vnode.children) {\n          hasMismatch = true;\n          (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(\n            `Hydration text content mismatch on`,\n            el,\n            `\n  - rendered on server: ${el.textContent}\n  - expected on client: ${vnode.children}`\n          );\n          el.textContent = vnode.children;\n        }\n      }\n      if (props) {\n        if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ || forcePatch || !optimized || patchFlag & (16 | 32)) {\n          for (const key in props) {\n            if ((!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && propHasMismatch(el, key, props[key], vnode, parentComponent)) {\n              hasMismatch = true;\n            }\n            if (forcePatch && (key.endsWith(\"value\") || key === \"indeterminate\") || isOn(key) && !isReservedProp(key) || // force hydrate v-bind with .prop modifiers\n            key[0] === \".\") {\n              patchProp(\n                el,\n                key,\n                null,\n                props[key],\n                void 0,\n                void 0,\n                parentComponent\n              );\n            }\n          }\n        } else if (props.onClick) {\n          patchProp(\n            el,\n            \"onClick\",\n            null,\n            props.onClick,\n            void 0,\n            void 0,\n            parentComponent\n          );\n        }\n      }\n      let vnodeHooks;\n      if (vnodeHooks = props && props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n      }\n      if (dirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"beforeMount\");\n      }\n      if ((vnodeHooks = props && props.onVnodeMounted) || dirs || needCallTransitionHooks) {\n        queueEffectWithSuspense(() => {\n          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);\n          needCallTransitionHooks && transition.enter(el);\n          dirs && invokeDirectiveHook(vnode, null, parentComponent, \"mounted\");\n        }, parentSuspense);\n      }\n    }\n    return el.nextSibling;\n  };\n  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    optimized = optimized || !!parentVNode.dynamicChildren;\n    const children = parentVNode.children;\n    const l = children.length;\n    let hasWarned = false;\n    for (let i = 0; i < l; i++) {\n      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);\n      if (node) {\n        node = hydrateNode(\n          node,\n          vnode,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n      } else if (vnode.type === Text && !vnode.children) {\n        continue;\n      } else {\n        hasMismatch = true;\n        if ((!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && !hasWarned) {\n          warn$1(\n            `Hydration children mismatch on`,\n            container,\n            `\nServer rendered element contains fewer child nodes than client vdom.`\n          );\n          hasWarned = true;\n        }\n        patch(\n          null,\n          vnode,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          getContainerType(container),\n          slotScopeIds\n        );\n      }\n    }\n    return node;\n  };\n  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {\n    const { slotScopeIds: fragmentSlotScopeIds } = vnode;\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    const container = parentNode(node);\n    const next = hydrateChildren(\n      nextSibling(node),\n      vnode,\n      container,\n      parentComponent,\n      parentSuspense,\n      slotScopeIds,\n      optimized\n    );\n    if (next && isComment(next) && next.data === \"]\") {\n      return nextSibling(vnode.anchor = next);\n    } else {\n      hasMismatch = true;\n      insert(vnode.anchor = createComment(`]`), container, next);\n      return next;\n    }\n  };\n  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {\n    hasMismatch = true;\n    (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_HYDRATION_MISMATCH_DETAILS__) && warn$1(\n      `Hydration node mismatch:\n- rendered on server:`,\n      node,\n      node.nodeType === 3 /* TEXT */ ? `(text)` : isComment(node) && node.data === \"[\" ? `(start of fragment)` : ``,\n      `\n- expected on client:`,\n      vnode.type\n    );\n    vnode.el = null;\n    if (isFragment) {\n      const end = locateClosingAnchor(node);\n      while (true) {\n        const next2 = nextSibling(node);\n        if (next2 && next2 !== end) {\n          remove(next2);\n        } else {\n          break;\n        }\n      }\n    }\n    const next = nextSibling(node);\n    const container = parentNode(node);\n    remove(node);\n    patch(\n      null,\n      vnode,\n      container,\n      next,\n      parentComponent,\n      parentSuspense,\n      getContainerType(container),\n      slotScopeIds\n    );\n    return next;\n  };\n  const locateClosingAnchor = (node, open = \"[\", close = \"]\") => {\n    let match = 0;\n    while (node) {\n      node = nextSibling(node);\n      if (node && isComment(node)) {\n        if (node.data === open)\n          match++;\n        if (node.data === close) {\n          if (match === 0) {\n            return nextSibling(node);\n          } else {\n            match--;\n          }\n        }\n      }\n    }\n    return node;\n  };\n  const replaceNode = (newNode, oldNode, parentComponent) => {\n    const parentNode2 = oldNode.parentNode;\n    if (parentNode2) {\n      parentNode2.replaceChild(newNode, oldNode);\n    }\n    let parent = parentComponent;\n    while (parent) {\n      if (parent.vnode.el === oldNode) {\n        parent.vnode.el = parent.subTree.el = newNode;\n      }\n      parent = parent.parent;\n    }\n  };\n  const isTemplateNode = (node) => {\n    return node.nodeType === 1 /* ELEMENT */ && node.tagName.toLowerCase() === \"template\";\n  };\n  return [hydrate, hydrateNode];\n}\nfunction propHasMismatch(el, key, clientValue, vnode, instance) {\n  var _a;\n  let mismatchType;\n  let mismatchKey;\n  let actual;\n  let expected;\n  if (key === \"class\") {\n    actual = el.getAttribute(\"class\");\n    expected = normalizeClass(clientValue);\n    if (!isSetEqual(toClassSet(actual || \"\"), toClassSet(expected))) {\n      mismatchType = mismatchKey = `class`;\n    }\n  } else if (key === \"style\") {\n    actual = el.getAttribute(\"style\") || \"\";\n    expected = isString(clientValue) ? clientValue : stringifyStyle(normalizeStyle(clientValue));\n    const actualMap = toStyleMap(actual);\n    const expectedMap = toStyleMap(expected);\n    if (vnode.dirs) {\n      for (const { dir, value } of vnode.dirs) {\n        if (dir.name === \"show\" && !value) {\n          expectedMap.set(\"display\", \"none\");\n        }\n      }\n    }\n    const root = instance == null ? void 0 : instance.subTree;\n    if (vnode === root || (root == null ? void 0 : root.type) === Fragment && root.children.includes(vnode)) {\n      const cssVars = (_a = instance == null ? void 0 : instance.getCssVars) == null ? void 0 : _a.call(instance);\n      for (const key2 in cssVars) {\n        expectedMap.set(`--${key2}`, String(cssVars[key2]));\n      }\n    }\n    if (!isMapEqual(actualMap, expectedMap)) {\n      mismatchType = mismatchKey = \"style\";\n    }\n  } else if (el instanceof SVGElement && isKnownSvgAttr(key) || el instanceof HTMLElement && (isBooleanAttr(key) || isKnownHtmlAttr(key))) {\n    if (isBooleanAttr(key)) {\n      actual = el.hasAttribute(key);\n      expected = includeBooleanAttr(clientValue);\n    } else if (clientValue == null) {\n      actual = el.hasAttribute(key);\n      expected = false;\n    } else {\n      if (el.hasAttribute(key)) {\n        actual = el.getAttribute(key);\n      } else if (key === \"value\" && el.tagName === \"TEXTAREA\") {\n        actual = el.value;\n      } else {\n        actual = false;\n      }\n      expected = isRenderableAttrValue(clientValue) ? String(clientValue) : false;\n    }\n    if (actual !== expected) {\n      mismatchType = `attribute`;\n      mismatchKey = key;\n    }\n  }\n  if (mismatchType) {\n    const format = (v) => v === false ? `(not rendered)` : `${mismatchKey}=\"${v}\"`;\n    const preSegment = `Hydration ${mismatchType} mismatch on`;\n    const postSegment = `\n  - rendered on server: ${format(actual)}\n  - expected on client: ${format(expected)}\n  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.\n  You should fix the source of the mismatch.`;\n    {\n      warn$1(preSegment, el, postSegment);\n    }\n    return true;\n  }\n  return false;\n}\nfunction toClassSet(str) {\n  return new Set(str.trim().split(/\\s+/));\n}\nfunction isSetEqual(a, b) {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const s of a) {\n    if (!b.has(s)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toStyleMap(str) {\n  const styleMap = /* @__PURE__ */ new Map();\n  for (const item of str.split(\";\")) {\n    let [key, value] = item.split(\":\");\n    key = key == null ? void 0 : key.trim();\n    value = value == null ? void 0 : value.trim();\n    if (key && value) {\n      styleMap.set(key, value);\n    }\n  }\n  return styleMap;\n}\nfunction isMapEqual(a, b) {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const [key, value] of a) {\n    if (value !== b.get(key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nlet supported;\nlet perf;\nfunction startMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    perf.mark(`vue-${type}-${instance.uid}`);\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction endMeasure(instance, type) {\n  if (instance.appContext.config.performance && isSupported()) {\n    const startTag = `vue-${type}-${instance.uid}`;\n    const endTag = startTag + `:end`;\n    perf.mark(endTag);\n    perf.measure(\n      `<${formatComponentName(instance, instance.type)}> ${type}`,\n      startTag,\n      endTag\n    );\n    perf.clearMarks(startTag);\n    perf.clearMarks(endTag);\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());\n  }\n}\nfunction isSupported() {\n  if (supported !== void 0) {\n    return supported;\n  }\n  if (typeof window !== \"undefined\" && window.performance) {\n    supported = true;\n    perf = window.performance;\n  } else {\n    supported = false;\n  }\n  return supported;\n}\n\nfunction initFeatureFlags() {\n  const needWarn = [];\n  if (typeof __VUE_OPTIONS_API__ !== \"boolean\") {\n    !!(process.env.NODE_ENV !== \"production\") && needWarn.push(`__VUE_OPTIONS_API__`);\n    getGlobalThis().__VUE_OPTIONS_API__ = true;\n  }\n  if (typeof __VUE_PROD_DEVTOOLS__ !== \"boolean\") {\n    !!(process.env.NODE_ENV !== \"production\") && needWarn.push(`__VUE_PROD_DEVTOOLS__`);\n    getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;\n  }\n  if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== \"boolean\") {\n    !!(process.env.NODE_ENV !== \"production\") && needWarn.push(`__VUE_PROD_HYDRATION_MISMATCH_DETAILS__`);\n    getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && needWarn.length) {\n    const multi = needWarn.length > 1;\n    console.warn(\n      `Feature flag${multi ? `s` : ``} ${needWarn.join(\", \")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.\n\nFor more details, see https://link.vuejs.org/feature-flags.`\n    );\n  }\n}\n\nconst queuePostRenderEffect = queueEffectWithSuspense ;\nfunction createRenderer(options) {\n  return baseCreateRenderer(options);\n}\nfunction createHydrationRenderer(options) {\n  return baseCreateRenderer(options, createHydrationFunctions);\n}\nfunction baseCreateRenderer(options, createHydrationFns) {\n  {\n    initFeatureFlags();\n  }\n  const target = getGlobalThis();\n  target.__VUE__ = true;\n  if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n    setDevtoolsHook$1(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);\n  }\n  const {\n    insert: hostInsert,\n    remove: hostRemove,\n    patchProp: hostPatchProp,\n    createElement: hostCreateElement,\n    createText: hostCreateText,\n    createComment: hostCreateComment,\n    setText: hostSetText,\n    setElementText: hostSetElementText,\n    parentNode: hostParentNode,\n    nextSibling: hostNextSibling,\n    setScopeId: hostSetScopeId = NOOP,\n    insertStaticContent: hostInsertStaticContent\n  } = options;\n  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!(process.env.NODE_ENV !== \"production\") && isHmrUpdating ? false : !!n2.dynamicChildren) => {\n    if (n1 === n2) {\n      return;\n    }\n    if (n1 && !isSameVNodeType(n1, n2)) {\n      anchor = getNextHostNode(n1);\n      unmount(n1, parentComponent, parentSuspense, true);\n      n1 = null;\n    }\n    if (n2.patchFlag === -2) {\n      optimized = false;\n      n2.dynamicChildren = null;\n    }\n    const { type, ref, shapeFlag } = n2;\n    switch (type) {\n      case Text:\n        processText(n1, n2, container, anchor);\n        break;\n      case Comment:\n        processCommentNode(n1, n2, container, anchor);\n        break;\n      case Static:\n        if (n1 == null) {\n          mountStaticNode(n2, container, anchor, namespace);\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          patchStaticNode(n1, n2, container, namespace);\n        }\n        break;\n      case Fragment:\n        processFragment(\n          n1,\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        break;\n      default:\n        if (shapeFlag & 1) {\n          processElement(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else if (shapeFlag & 6) {\n          processComponent(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else if (shapeFlag & 64) {\n          type.process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n            internals\n          );\n        } else if (shapeFlag & 128) {\n          type.process(\n            n1,\n            n2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized,\n            internals\n          );\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn$1(\"Invalid VNode type:\", type, `(${typeof type})`);\n        }\n    }\n    if (ref != null && parentComponent) {\n      setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);\n    }\n  };\n  const processText = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(\n        n2.el = hostCreateText(n2.children),\n        container,\n        anchor\n      );\n    } else {\n      const el = n2.el = n1.el;\n      if (n2.children !== n1.children) {\n        hostSetText(el, n2.children);\n      }\n    }\n  };\n  const processCommentNode = (n1, n2, container, anchor) => {\n    if (n1 == null) {\n      hostInsert(\n        n2.el = hostCreateComment(n2.children || \"\"),\n        container,\n        anchor\n      );\n    } else {\n      n2.el = n1.el;\n    }\n  };\n  const mountStaticNode = (n2, container, anchor, namespace) => {\n    [n2.el, n2.anchor] = hostInsertStaticContent(\n      n2.children,\n      container,\n      anchor,\n      namespace,\n      n2.el,\n      n2.anchor\n    );\n  };\n  const patchStaticNode = (n1, n2, container, namespace) => {\n    if (n2.children !== n1.children) {\n      const anchor = hostNextSibling(n1.anchor);\n      removeStaticNode(n1);\n      [n2.el, n2.anchor] = hostInsertStaticContent(\n        n2.children,\n        container,\n        anchor,\n        namespace\n      );\n    } else {\n      n2.el = n1.el;\n      n2.anchor = n1.anchor;\n    }\n  };\n  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostInsert(el, container, nextSibling);\n      el = next;\n    }\n    hostInsert(anchor, container, nextSibling);\n  };\n  const removeStaticNode = ({ el, anchor }) => {\n    let next;\n    while (el && el !== anchor) {\n      next = hostNextSibling(el);\n      hostRemove(el);\n      el = next;\n    }\n    hostRemove(anchor);\n  };\n  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    if (n2.type === \"svg\") {\n      namespace = \"svg\";\n    } else if (n2.type === \"math\") {\n      namespace = \"mathml\";\n    }\n    if (n1 == null) {\n      mountElement(\n        n2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    } else {\n      patchElement(\n        n1,\n        n2,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    }\n  };\n  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let el;\n    let vnodeHook;\n    const { props, shapeFlag, transition, dirs } = vnode;\n    el = vnode.el = hostCreateElement(\n      vnode.type,\n      namespace,\n      props && props.is,\n      props\n    );\n    if (shapeFlag & 8) {\n      hostSetElementText(el, vnode.children);\n    } else if (shapeFlag & 16) {\n      mountChildren(\n        vnode.children,\n        el,\n        null,\n        parentComponent,\n        parentSuspense,\n        resolveChildrenNamespace(vnode, namespace),\n        slotScopeIds,\n        optimized\n      );\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, \"created\");\n    }\n    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);\n    if (props) {\n      for (const key in props) {\n        if (key !== \"value\" && !isReservedProp(key)) {\n          hostPatchProp(\n            el,\n            key,\n            null,\n            props[key],\n            namespace,\n            vnode.children,\n            parentComponent,\n            parentSuspense,\n            unmountChildren\n          );\n        }\n      }\n      if (\"value\" in props) {\n        hostPatchProp(el, \"value\", null, props.value, namespace);\n      }\n      if (vnodeHook = props.onVnodeBeforeMount) {\n        invokeVNodeHook(vnodeHook, parentComponent, vnode);\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      Object.defineProperty(el, \"__vnode\", {\n        value: vnode,\n        enumerable: false\n      });\n      Object.defineProperty(el, \"__vueParentComponent\", {\n        value: parentComponent,\n        enumerable: false\n      });\n    }\n    if (dirs) {\n      invokeDirectiveHook(vnode, null, parentComponent, \"beforeMount\");\n    }\n    const needCallTransitionHooks = needTransition(parentSuspense, transition);\n    if (needCallTransitionHooks) {\n      transition.beforeEnter(el);\n    }\n    hostInsert(el, container, anchor);\n    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        needCallTransitionHooks && transition.enter(el);\n        dirs && invokeDirectiveHook(vnode, null, parentComponent, \"mounted\");\n      }, parentSuspense);\n    }\n  };\n  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {\n    if (scopeId) {\n      hostSetScopeId(el, scopeId);\n    }\n    if (slotScopeIds) {\n      for (let i = 0; i < slotScopeIds.length; i++) {\n        hostSetScopeId(el, slotScopeIds[i]);\n      }\n    }\n    if (parentComponent) {\n      let subTree = parentComponent.subTree;\n      if (!!(process.env.NODE_ENV !== \"production\") && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {\n        subTree = filterSingleRoot(subTree.children) || subTree;\n      }\n      if (vnode === subTree) {\n        const parentVNode = parentComponent.vnode;\n        setScopeId(\n          el,\n          parentVNode,\n          parentVNode.scopeId,\n          parentVNode.slotScopeIds,\n          parentComponent.parent\n        );\n      }\n    }\n  };\n  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);\n      patch(\n        null,\n        child,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    }\n  };\n  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    const el = n2.el = n1.el;\n    let { patchFlag, dynamicChildren, dirs } = n2;\n    patchFlag |= n1.patchFlag & 16;\n    const oldProps = n1.props || EMPTY_OBJ;\n    const newProps = n2.props || EMPTY_OBJ;\n    let vnodeHook;\n    parentComponent && toggleRecurse(parentComponent, false);\n    if (vnodeHook = newProps.onVnodeBeforeUpdate) {\n      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n    }\n    if (dirs) {\n      invokeDirectiveHook(n2, n1, parentComponent, \"beforeUpdate\");\n    }\n    parentComponent && toggleRecurse(parentComponent, true);\n    if (!!(process.env.NODE_ENV !== \"production\") && isHmrUpdating) {\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (dynamicChildren) {\n      patchBlockChildren(\n        n1.dynamicChildren,\n        dynamicChildren,\n        el,\n        parentComponent,\n        parentSuspense,\n        resolveChildrenNamespace(n2, namespace),\n        slotScopeIds\n      );\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        traverseStaticChildren(n1, n2);\n      }\n    } else if (!optimized) {\n      patchChildren(\n        n1,\n        n2,\n        el,\n        null,\n        parentComponent,\n        parentSuspense,\n        resolveChildrenNamespace(n2, namespace),\n        slotScopeIds,\n        false\n      );\n    }\n    if (patchFlag > 0) {\n      if (patchFlag & 16) {\n        patchProps(\n          el,\n          n2,\n          oldProps,\n          newProps,\n          parentComponent,\n          parentSuspense,\n          namespace\n        );\n      } else {\n        if (patchFlag & 2) {\n          if (oldProps.class !== newProps.class) {\n            hostPatchProp(el, \"class\", null, newProps.class, namespace);\n          }\n        }\n        if (patchFlag & 4) {\n          hostPatchProp(el, \"style\", oldProps.style, newProps.style, namespace);\n        }\n        if (patchFlag & 8) {\n          const propsToUpdate = n2.dynamicProps;\n          for (let i = 0; i < propsToUpdate.length; i++) {\n            const key = propsToUpdate[i];\n            const prev = oldProps[key];\n            const next = newProps[key];\n            if (next !== prev || key === \"value\") {\n              hostPatchProp(\n                el,\n                key,\n                prev,\n                next,\n                namespace,\n                n1.children,\n                parentComponent,\n                parentSuspense,\n                unmountChildren\n              );\n            }\n          }\n        }\n      }\n      if (patchFlag & 1) {\n        if (n1.children !== n2.children) {\n          hostSetElementText(el, n2.children);\n        }\n      }\n    } else if (!optimized && dynamicChildren == null) {\n      patchProps(\n        el,\n        n2,\n        oldProps,\n        newProps,\n        parentComponent,\n        parentSuspense,\n        namespace\n      );\n    }\n    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);\n        dirs && invokeDirectiveHook(n2, n1, parentComponent, \"updated\");\n      }, parentSuspense);\n    }\n  };\n  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {\n    for (let i = 0; i < newChildren.length; i++) {\n      const oldVNode = oldChildren[i];\n      const newVNode = newChildren[i];\n      const container = (\n        // oldVNode may be an errored async setup() component inside Suspense\n        // which will not have a mounted element\n        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent\n        // of the Fragment itself so it can move its children.\n        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement\n        // which also requires the correct parent container\n        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.\n        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (\n          // In other cases, the parent container is not actually used so we\n          // just pass the block element here to avoid a DOM parentNode call.\n          fallbackContainer\n        )\n      );\n      patch(\n        oldVNode,\n        newVNode,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        true\n      );\n    }\n  };\n  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {\n    if (oldProps !== newProps) {\n      if (oldProps !== EMPTY_OBJ) {\n        for (const key in oldProps) {\n          if (!isReservedProp(key) && !(key in newProps)) {\n            hostPatchProp(\n              el,\n              key,\n              oldProps[key],\n              null,\n              namespace,\n              vnode.children,\n              parentComponent,\n              parentSuspense,\n              unmountChildren\n            );\n          }\n        }\n      }\n      for (const key in newProps) {\n        if (isReservedProp(key))\n          continue;\n        const next = newProps[key];\n        const prev = oldProps[key];\n        if (next !== prev && key !== \"value\") {\n          hostPatchProp(\n            el,\n            key,\n            prev,\n            next,\n            namespace,\n            vnode.children,\n            parentComponent,\n            parentSuspense,\n            unmountChildren\n          );\n        }\n      }\n      if (\"value\" in newProps) {\n        hostPatchProp(el, \"value\", oldProps.value, newProps.value, namespace);\n      }\n    }\n  };\n  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText(\"\");\n    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText(\"\");\n    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;\n    if (!!(process.env.NODE_ENV !== \"production\") && // #5523 dev root fragment may inherit directives\n    (isHmrUpdating || patchFlag & 2048)) {\n      patchFlag = 0;\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (fragmentSlotScopeIds) {\n      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;\n    }\n    if (n1 == null) {\n      hostInsert(fragmentStartAnchor, container, anchor);\n      hostInsert(fragmentEndAnchor, container, anchor);\n      mountChildren(\n        // #10007\n        // such fragment like `<></>` will be compiled into\n        // a fragment which doesn't have a children.\n        // In this case fallback to an empty array\n        n2.children || [],\n        container,\n        fragmentEndAnchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    } else {\n      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result\n      // of renderSlot() with no valid children\n      n1.dynamicChildren) {\n        patchBlockChildren(\n          n1.dynamicChildren,\n          dynamicChildren,\n          container,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds\n        );\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          traverseStaticChildren(n1, n2);\n        } else if (\n          // #2080 if the stable fragment has a key, it's a <template v-for> that may\n          //  get moved around. Make sure all root level vnodes inherit el.\n          // #2134 or if it's a component root, it may also get moved around\n          // as the component is being moved.\n          n2.key != null || parentComponent && n2 === parentComponent.subTree\n        ) {\n          traverseStaticChildren(\n            n1,\n            n2,\n            true\n            /* shallow */\n          );\n        }\n      } else {\n        patchChildren(\n          n1,\n          n2,\n          container,\n          fragmentEndAnchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n      }\n    }\n  };\n  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    n2.slotScopeIds = slotScopeIds;\n    if (n1 == null) {\n      if (n2.shapeFlag & 512) {\n        parentComponent.ctx.activate(\n          n2,\n          container,\n          anchor,\n          namespace,\n          optimized\n        );\n      } else {\n        mountComponent(\n          n2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          optimized\n        );\n      }\n    } else {\n      updateComponent(n1, n2, optimized);\n    }\n  };\n  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {\n    const instance = (initialVNode.component = createComponentInstance(\n      initialVNode,\n      parentComponent,\n      parentSuspense\n    ));\n    if (!!(process.env.NODE_ENV !== \"production\") && instance.type.__hmrId) {\n      registerHMR(instance);\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      pushWarningContext(initialVNode);\n      startMeasure(instance, `mount`);\n    }\n    if (isKeepAlive(initialVNode)) {\n      instance.ctx.renderer = internals;\n    }\n    {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        startMeasure(instance, `init`);\n      }\n      setupComponent(instance);\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        endMeasure(instance, `init`);\n      }\n    }\n    if (instance.asyncDep) {\n      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);\n      if (!initialVNode.el) {\n        const placeholder = instance.subTree = createVNode(Comment);\n        processCommentNode(null, placeholder, container, anchor);\n      }\n    } else {\n      setupRenderEffect(\n        instance,\n        initialVNode,\n        container,\n        anchor,\n        parentSuspense,\n        namespace,\n        optimized\n      );\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      popWarningContext();\n      endMeasure(instance, `mount`);\n    }\n  };\n  const updateComponent = (n1, n2, optimized) => {\n    const instance = n2.component = n1.component;\n    if (shouldUpdateComponent(n1, n2, optimized)) {\n      if (instance.asyncDep && !instance.asyncResolved) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          pushWarningContext(n2);\n        }\n        updateComponentPreRender(instance, n2, optimized);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          popWarningContext();\n        }\n        return;\n      } else {\n        instance.next = n2;\n        invalidateJob(instance.update);\n        instance.effect.dirty = true;\n        instance.update();\n      }\n    } else {\n      n2.el = n1.el;\n      instance.vnode = n2;\n    }\n  };\n  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {\n    const componentUpdateFn = () => {\n      if (!instance.isMounted) {\n        let vnodeHook;\n        const { el, props } = initialVNode;\n        const { bm, m, parent } = instance;\n        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);\n        toggleRecurse(instance, false);\n        if (bm) {\n          invokeArrayFns(bm);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {\n          invokeVNodeHook(vnodeHook, parent, initialVNode);\n        }\n        toggleRecurse(instance, true);\n        if (el && hydrateNode) {\n          const hydrateSubTree = () => {\n            if (!!(process.env.NODE_ENV !== \"production\")) {\n              startMeasure(instance, `render`);\n            }\n            instance.subTree = renderComponentRoot(instance);\n            if (!!(process.env.NODE_ENV !== \"production\")) {\n              endMeasure(instance, `render`);\n            }\n            if (!!(process.env.NODE_ENV !== \"production\")) {\n              startMeasure(instance, `hydrate`);\n            }\n            hydrateNode(\n              el,\n              instance.subTree,\n              instance,\n              parentSuspense,\n              null\n            );\n            if (!!(process.env.NODE_ENV !== \"production\")) {\n              endMeasure(instance, `hydrate`);\n            }\n          };\n          if (isAsyncWrapperVNode) {\n            initialVNode.type.__asyncLoader().then(\n              // note: we are moving the render call into an async callback,\n              // which means it won't track dependencies - but it's ok because\n              // a server-rendered async wrapper is already in resolved state\n              // and it will never need to change.\n              () => !instance.isUnmounted && hydrateSubTree()\n            );\n          } else {\n            hydrateSubTree();\n          }\n        } else {\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            startMeasure(instance, `render`);\n          }\n          const subTree = instance.subTree = renderComponentRoot(instance);\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            endMeasure(instance, `render`);\n          }\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            startMeasure(instance, `patch`);\n          }\n          patch(\n            null,\n            subTree,\n            container,\n            anchor,\n            instance,\n            parentSuspense,\n            namespace\n          );\n          if (!!(process.env.NODE_ENV !== \"production\")) {\n            endMeasure(instance, `patch`);\n          }\n          initialVNode.el = subTree.el;\n        }\n        if (m) {\n          queuePostRenderEffect(m, parentSuspense);\n        }\n        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {\n          const scopedInitialVNode = initialVNode;\n          queuePostRenderEffect(\n            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),\n            parentSuspense\n          );\n        }\n        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {\n          instance.a && queuePostRenderEffect(instance.a, parentSuspense);\n        }\n        instance.isMounted = true;\n        if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n          devtoolsComponentAdded(instance);\n        }\n        initialVNode = container = anchor = null;\n      } else {\n        let { next, bu, u, parent, vnode } = instance;\n        {\n          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);\n          if (nonHydratedAsyncRoot) {\n            if (next) {\n              next.el = vnode.el;\n              updateComponentPreRender(instance, next, optimized);\n            }\n            nonHydratedAsyncRoot.asyncDep.then(() => {\n              if (!instance.isUnmounted) {\n                componentUpdateFn();\n              }\n            });\n            return;\n          }\n        }\n        let originNext = next;\n        let vnodeHook;\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          pushWarningContext(next || instance.vnode);\n        }\n        toggleRecurse(instance, false);\n        if (next) {\n          next.el = vnode.el;\n          updateComponentPreRender(instance, next, optimized);\n        } else {\n          next = vnode;\n        }\n        if (bu) {\n          invokeArrayFns(bu);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {\n          invokeVNodeHook(vnodeHook, parent, next, vnode);\n        }\n        toggleRecurse(instance, true);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          startMeasure(instance, `render`);\n        }\n        const nextTree = renderComponentRoot(instance);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          endMeasure(instance, `render`);\n        }\n        const prevTree = instance.subTree;\n        instance.subTree = nextTree;\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          startMeasure(instance, `patch`);\n        }\n        patch(\n          prevTree,\n          nextTree,\n          // parent may have changed if it's in a teleport\n          hostParentNode(prevTree.el),\n          // anchor may have changed if it's in a fragment\n          getNextHostNode(prevTree),\n          instance,\n          parentSuspense,\n          namespace\n        );\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          endMeasure(instance, `patch`);\n        }\n        next.el = nextTree.el;\n        if (originNext === null) {\n          updateHOCHostEl(instance, nextTree.el);\n        }\n        if (u) {\n          queuePostRenderEffect(u, parentSuspense);\n        }\n        if (vnodeHook = next.props && next.props.onVnodeUpdated) {\n          queuePostRenderEffect(\n            () => invokeVNodeHook(vnodeHook, parent, next, vnode),\n            parentSuspense\n          );\n        }\n        if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n          devtoolsComponentUpdated(instance);\n        }\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          popWarningContext();\n        }\n      }\n    };\n    const effect = instance.effect = new ReactiveEffect(\n      componentUpdateFn,\n      NOOP,\n      () => queueJob(update),\n      instance.scope\n      // track it in component's effect scope\n    );\n    const update = instance.update = () => {\n      if (effect.dirty) {\n        effect.run();\n      }\n    };\n    update.id = instance.uid;\n    toggleRecurse(instance, true);\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      effect.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;\n      effect.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;\n      update.ownerInstance = instance;\n    }\n    update();\n  };\n  const updateComponentPreRender = (instance, nextVNode, optimized) => {\n    nextVNode.component = instance;\n    const prevProps = instance.vnode.props;\n    instance.vnode = nextVNode;\n    instance.next = null;\n    updateProps(instance, nextVNode.props, prevProps, optimized);\n    updateSlots(instance, nextVNode.children, optimized);\n    pauseTracking();\n    flushPreFlushCbs(instance);\n    resetTracking();\n  };\n  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {\n    const c1 = n1 && n1.children;\n    const prevShapeFlag = n1 ? n1.shapeFlag : 0;\n    const c2 = n2.children;\n    const { patchFlag, shapeFlag } = n2;\n    if (patchFlag > 0) {\n      if (patchFlag & 128) {\n        patchKeyedChildren(\n          c1,\n          c2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        return;\n      } else if (patchFlag & 256) {\n        patchUnkeyedChildren(\n          c1,\n          c2,\n          container,\n          anchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n        return;\n      }\n    }\n    if (shapeFlag & 8) {\n      if (prevShapeFlag & 16) {\n        unmountChildren(c1, parentComponent, parentSuspense);\n      }\n      if (c2 !== c1) {\n        hostSetElementText(container, c2);\n      }\n    } else {\n      if (prevShapeFlag & 16) {\n        if (shapeFlag & 16) {\n          patchKeyedChildren(\n            c1,\n            c2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else {\n          unmountChildren(c1, parentComponent, parentSuspense, true);\n        }\n      } else {\n        if (prevShapeFlag & 8) {\n          hostSetElementText(container, \"\");\n        }\n        if (shapeFlag & 16) {\n          mountChildren(\n            c2,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        }\n      }\n    }\n  };\n  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    c1 = c1 || EMPTY_ARR;\n    c2 = c2 || EMPTY_ARR;\n    const oldLength = c1.length;\n    const newLength = c2.length;\n    const commonLength = Math.min(oldLength, newLength);\n    let i;\n    for (i = 0; i < commonLength; i++) {\n      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      patch(\n        c1[i],\n        nextChild,\n        container,\n        null,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized\n      );\n    }\n    if (oldLength > newLength) {\n      unmountChildren(\n        c1,\n        parentComponent,\n        parentSuspense,\n        true,\n        false,\n        commonLength\n      );\n    } else {\n      mountChildren(\n        c2,\n        container,\n        anchor,\n        parentComponent,\n        parentSuspense,\n        namespace,\n        slotScopeIds,\n        optimized,\n        commonLength\n      );\n    }\n  };\n  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {\n    let i = 0;\n    const l2 = c2.length;\n    let e1 = c1.length - 1;\n    let e2 = l2 - 1;\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[i];\n      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n      } else {\n        break;\n      }\n      i++;\n    }\n    while (i <= e1 && i <= e2) {\n      const n1 = c1[e1];\n      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);\n      if (isSameVNodeType(n1, n2)) {\n        patch(\n          n1,\n          n2,\n          container,\n          null,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          optimized\n        );\n      } else {\n        break;\n      }\n      e1--;\n      e2--;\n    }\n    if (i > e1) {\n      if (i <= e2) {\n        const nextPos = e2 + 1;\n        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;\n        while (i <= e2) {\n          patch(\n            null,\n            c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          i++;\n        }\n      }\n    } else if (i > e2) {\n      while (i <= e1) {\n        unmount(c1[i], parentComponent, parentSuspense, true);\n        i++;\n      }\n    } else {\n      const s1 = i;\n      const s2 = i;\n      const keyToNewIndexMap = /* @__PURE__ */ new Map();\n      for (i = s2; i <= e2; i++) {\n        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);\n        if (nextChild.key != null) {\n          if (!!(process.env.NODE_ENV !== \"production\") && keyToNewIndexMap.has(nextChild.key)) {\n            warn$1(\n              `Duplicate keys found during update:`,\n              JSON.stringify(nextChild.key),\n              `Make sure keys are unique.`\n            );\n          }\n          keyToNewIndexMap.set(nextChild.key, i);\n        }\n      }\n      let j;\n      let patched = 0;\n      const toBePatched = e2 - s2 + 1;\n      let moved = false;\n      let maxNewIndexSoFar = 0;\n      const newIndexToOldIndexMap = new Array(toBePatched);\n      for (i = 0; i < toBePatched; i++)\n        newIndexToOldIndexMap[i] = 0;\n      for (i = s1; i <= e1; i++) {\n        const prevChild = c1[i];\n        if (patched >= toBePatched) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n          continue;\n        }\n        let newIndex;\n        if (prevChild.key != null) {\n          newIndex = keyToNewIndexMap.get(prevChild.key);\n        } else {\n          for (j = s2; j <= e2; j++) {\n            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {\n              newIndex = j;\n              break;\n            }\n          }\n        }\n        if (newIndex === void 0) {\n          unmount(prevChild, parentComponent, parentSuspense, true);\n        } else {\n          newIndexToOldIndexMap[newIndex - s2] = i + 1;\n          if (newIndex >= maxNewIndexSoFar) {\n            maxNewIndexSoFar = newIndex;\n          } else {\n            moved = true;\n          }\n          patch(\n            prevChild,\n            c2[newIndex],\n            container,\n            null,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n          patched++;\n        }\n      }\n      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;\n      j = increasingNewIndexSequence.length - 1;\n      for (i = toBePatched - 1; i >= 0; i--) {\n        const nextIndex = s2 + i;\n        const nextChild = c2[nextIndex];\n        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;\n        if (newIndexToOldIndexMap[i] === 0) {\n          patch(\n            null,\n            nextChild,\n            container,\n            anchor,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        } else if (moved) {\n          if (j < 0 || i !== increasingNewIndexSequence[j]) {\n            move(nextChild, container, anchor, 2);\n          } else {\n            j--;\n          }\n        }\n      }\n    }\n  };\n  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {\n    const { el, type, transition, children, shapeFlag } = vnode;\n    if (shapeFlag & 6) {\n      move(vnode.component.subTree, container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 128) {\n      vnode.suspense.move(container, anchor, moveType);\n      return;\n    }\n    if (shapeFlag & 64) {\n      type.move(vnode, container, anchor, internals);\n      return;\n    }\n    if (type === Fragment) {\n      hostInsert(el, container, anchor);\n      for (let i = 0; i < children.length; i++) {\n        move(children[i], container, anchor, moveType);\n      }\n      hostInsert(vnode.anchor, container, anchor);\n      return;\n    }\n    if (type === Static) {\n      moveStaticNode(vnode, container, anchor);\n      return;\n    }\n    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;\n    if (needTransition2) {\n      if (moveType === 0) {\n        transition.beforeEnter(el);\n        hostInsert(el, container, anchor);\n        queuePostRenderEffect(() => transition.enter(el), parentSuspense);\n      } else {\n        const { leave, delayLeave, afterLeave } = transition;\n        const remove2 = () => hostInsert(el, container, anchor);\n        const performLeave = () => {\n          leave(el, () => {\n            remove2();\n            afterLeave && afterLeave();\n          });\n        };\n        if (delayLeave) {\n          delayLeave(el, remove2, performLeave);\n        } else {\n          performLeave();\n        }\n      }\n    } else {\n      hostInsert(el, container, anchor);\n    }\n  };\n  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {\n    const {\n      type,\n      props,\n      ref,\n      children,\n      dynamicChildren,\n      shapeFlag,\n      patchFlag,\n      dirs\n    } = vnode;\n    if (ref != null) {\n      setRef(ref, null, parentSuspense, vnode, true);\n    }\n    if (shapeFlag & 256) {\n      parentComponent.ctx.deactivate(vnode);\n      return;\n    }\n    const shouldInvokeDirs = shapeFlag & 1 && dirs;\n    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);\n    let vnodeHook;\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {\n      invokeVNodeHook(vnodeHook, parentComponent, vnode);\n    }\n    if (shapeFlag & 6) {\n      unmountComponent(vnode.component, parentSuspense, doRemove);\n    } else {\n      if (shapeFlag & 128) {\n        vnode.suspense.unmount(parentSuspense, doRemove);\n        return;\n      }\n      if (shouldInvokeDirs) {\n        invokeDirectiveHook(vnode, null, parentComponent, \"beforeUnmount\");\n      }\n      if (shapeFlag & 64) {\n        vnode.type.remove(\n          vnode,\n          parentComponent,\n          parentSuspense,\n          optimized,\n          internals,\n          doRemove\n        );\n      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments\n      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {\n        unmountChildren(\n          dynamicChildren,\n          parentComponent,\n          parentSuspense,\n          false,\n          true\n        );\n      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {\n        unmountChildren(children, parentComponent, parentSuspense);\n      }\n      if (doRemove) {\n        remove(vnode);\n      }\n    }\n    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {\n      queuePostRenderEffect(() => {\n        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);\n        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, \"unmounted\");\n      }, parentSuspense);\n    }\n  };\n  const remove = (vnode) => {\n    const { type, el, anchor, transition } = vnode;\n    if (type === Fragment) {\n      if (!!(process.env.NODE_ENV !== \"production\") && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {\n        vnode.children.forEach((child) => {\n          if (child.type === Comment) {\n            hostRemove(child.el);\n          } else {\n            remove(child);\n          }\n        });\n      } else {\n        removeFragment(el, anchor);\n      }\n      return;\n    }\n    if (type === Static) {\n      removeStaticNode(vnode);\n      return;\n    }\n    const performRemove = () => {\n      hostRemove(el);\n      if (transition && !transition.persisted && transition.afterLeave) {\n        transition.afterLeave();\n      }\n    };\n    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {\n      const { leave, delayLeave } = transition;\n      const performLeave = () => leave(el, performRemove);\n      if (delayLeave) {\n        delayLeave(vnode.el, performRemove, performLeave);\n      } else {\n        performLeave();\n      }\n    } else {\n      performRemove();\n    }\n  };\n  const removeFragment = (cur, end) => {\n    let next;\n    while (cur !== end) {\n      next = hostNextSibling(cur);\n      hostRemove(cur);\n      cur = next;\n    }\n    hostRemove(end);\n  };\n  const unmountComponent = (instance, parentSuspense, doRemove) => {\n    if (!!(process.env.NODE_ENV !== \"production\") && instance.type.__hmrId) {\n      unregisterHMR(instance);\n    }\n    const { bum, scope, update, subTree, um } = instance;\n    if (bum) {\n      invokeArrayFns(bum);\n    }\n    scope.stop();\n    if (update) {\n      update.active = false;\n      unmount(subTree, instance, parentSuspense, doRemove);\n    }\n    if (um) {\n      queuePostRenderEffect(um, parentSuspense);\n    }\n    queuePostRenderEffect(() => {\n      instance.isUnmounted = true;\n    }, parentSuspense);\n    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {\n      parentSuspense.deps--;\n      if (parentSuspense.deps === 0) {\n        parentSuspense.resolve();\n      }\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      devtoolsComponentRemoved(instance);\n    }\n  };\n  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {\n    for (let i = start; i < children.length; i++) {\n      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);\n    }\n  };\n  const getNextHostNode = (vnode) => {\n    if (vnode.shapeFlag & 6) {\n      return getNextHostNode(vnode.component.subTree);\n    }\n    if (vnode.shapeFlag & 128) {\n      return vnode.suspense.next();\n    }\n    return hostNextSibling(vnode.anchor || vnode.el);\n  };\n  let isFlushing = false;\n  const render = (vnode, container, namespace) => {\n    if (vnode == null) {\n      if (container._vnode) {\n        unmount(container._vnode, null, null, true);\n      }\n    } else {\n      patch(\n        container._vnode || null,\n        vnode,\n        container,\n        null,\n        null,\n        null,\n        namespace\n      );\n    }\n    if (!isFlushing) {\n      isFlushing = true;\n      flushPreFlushCbs();\n      flushPostFlushCbs();\n      isFlushing = false;\n    }\n    container._vnode = vnode;\n  };\n  const internals = {\n    p: patch,\n    um: unmount,\n    m: move,\n    r: remove,\n    mt: mountComponent,\n    mc: mountChildren,\n    pc: patchChildren,\n    pbc: patchBlockChildren,\n    n: getNextHostNode,\n    o: options\n  };\n  let hydrate;\n  let hydrateNode;\n  if (createHydrationFns) {\n    [hydrate, hydrateNode] = createHydrationFns(\n      internals\n    );\n  }\n  return {\n    render,\n    hydrate,\n    createApp: createAppAPI(render, hydrate)\n  };\n}\nfunction resolveChildrenNamespace({ type, props }, currentNamespace) {\n  return currentNamespace === \"svg\" && type === \"foreignObject\" || currentNamespace === \"mathml\" && type === \"annotation-xml\" && props && props.encoding && props.encoding.includes(\"html\") ? void 0 : currentNamespace;\n}\nfunction toggleRecurse({ effect, update }, allowed) {\n  effect.allowRecurse = update.allowRecurse = allowed;\n}\nfunction needTransition(parentSuspense, transition) {\n  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;\n}\nfunction traverseStaticChildren(n1, n2, shallow = false) {\n  const ch1 = n1.children;\n  const ch2 = n2.children;\n  if (isArray(ch1) && isArray(ch2)) {\n    for (let i = 0; i < ch1.length; i++) {\n      const c1 = ch1[i];\n      let c2 = ch2[i];\n      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {\n        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {\n          c2 = ch2[i] = cloneIfMounted(ch2[i]);\n          c2.el = c1.el;\n        }\n        if (!shallow)\n          traverseStaticChildren(c1, c2);\n      }\n      if (c2.type === Text) {\n        c2.el = c1.el;\n      }\n      if (!!(process.env.NODE_ENV !== \"production\") && c2.type === Comment && !c2.el) {\n        c2.el = c1.el;\n      }\n    }\n  }\n}\nfunction getSequence(arr) {\n  const p = arr.slice();\n  const result = [0];\n  let i, j, u, v, c;\n  const len = arr.length;\n  for (i = 0; i < len; i++) {\n    const arrI = arr[i];\n    if (arrI !== 0) {\n      j = result[result.length - 1];\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result.push(i);\n        continue;\n      }\n      u = 0;\n      v = result.length - 1;\n      while (u < v) {\n        c = u + v >> 1;\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n        result[u] = i;\n      }\n    }\n  }\n  u = result.length;\n  v = result[u - 1];\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n  return result;\n}\nfunction locateNonHydratedAsyncRoot(instance) {\n  const subComponent = instance.subTree.component;\n  if (subComponent) {\n    if (subComponent.asyncDep && !subComponent.asyncResolved) {\n      return subComponent;\n    } else {\n      return locateNonHydratedAsyncRoot(subComponent);\n    }\n  }\n}\n\nconst isTeleport = (type) => type.__isTeleport;\nconst isTeleportDisabled = (props) => props && (props.disabled || props.disabled === \"\");\nconst isTargetSVG = (target) => typeof SVGElement !== \"undefined\" && target instanceof SVGElement;\nconst isTargetMathML = (target) => typeof MathMLElement === \"function\" && target instanceof MathMLElement;\nconst resolveTarget = (props, select) => {\n  const targetSelector = props && props.to;\n  if (isString(targetSelector)) {\n    if (!select) {\n      !!(process.env.NODE_ENV !== \"production\") && warn$1(\n        `Current renderer does not support string target for Teleports. (missing querySelector renderer option)`\n      );\n      return null;\n    } else {\n      const target = select(targetSelector);\n      if (!target) {\n        !!(process.env.NODE_ENV !== \"production\") && warn$1(\n          `Failed to locate Teleport target with selector \"${targetSelector}\". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`\n        );\n      }\n      return target;\n    }\n  } else {\n    if (!!(process.env.NODE_ENV !== \"production\") && !targetSelector && !isTeleportDisabled(props)) {\n      warn$1(`Invalid Teleport target: ${targetSelector}`);\n    }\n    return targetSelector;\n  }\n};\nconst TeleportImpl = {\n  name: \"Teleport\",\n  __isTeleport: true,\n  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {\n    const {\n      mc: mountChildren,\n      pc: patchChildren,\n      pbc: patchBlockChildren,\n      o: { insert, querySelector, createText, createComment }\n    } = internals;\n    const disabled = isTeleportDisabled(n2.props);\n    let { shapeFlag, children, dynamicChildren } = n2;\n    if (!!(process.env.NODE_ENV !== \"production\") && isHmrUpdating) {\n      optimized = false;\n      dynamicChildren = null;\n    }\n    if (n1 == null) {\n      const placeholder = n2.el = !!(process.env.NODE_ENV !== \"production\") ? createComment(\"teleport start\") : createText(\"\");\n      const mainAnchor = n2.anchor = !!(process.env.NODE_ENV !== \"production\") ? createComment(\"teleport end\") : createText(\"\");\n      insert(placeholder, container, anchor);\n      insert(mainAnchor, container, anchor);\n      const target = n2.target = resolveTarget(n2.props, querySelector);\n      const targetAnchor = n2.targetAnchor = createText(\"\");\n      if (target) {\n        insert(targetAnchor, target);\n        if (namespace === \"svg\" || isTargetSVG(target)) {\n          namespace = \"svg\";\n        } else if (namespace === \"mathml\" || isTargetMathML(target)) {\n          namespace = \"mathml\";\n        }\n      } else if (!!(process.env.NODE_ENV !== \"production\") && !disabled) {\n        warn$1(\"Invalid Teleport target on mount:\", target, `(${typeof target})`);\n      }\n      const mount = (container2, anchor2) => {\n        if (shapeFlag & 16) {\n          mountChildren(\n            children,\n            container2,\n            anchor2,\n            parentComponent,\n            parentSuspense,\n            namespace,\n            slotScopeIds,\n            optimized\n          );\n        }\n      };\n      if (disabled) {\n        mount(container, mainAnchor);\n      } else if (target) {\n        mount(target, targetAnchor);\n      }\n    } else {\n      n2.el = n1.el;\n      const mainAnchor = n2.anchor = n1.anchor;\n      const target = n2.target = n1.target;\n      const targetAnchor = n2.targetAnchor = n1.targetAnchor;\n      const wasDisabled = isTeleportDisabled(n1.props);\n      const currentContainer = wasDisabled ? container : target;\n      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;\n      if (namespace === \"svg\" || isTargetSVG(target)) {\n        namespace = \"svg\";\n      } else if (namespace === \"mathml\" || isTargetMathML(target)) {\n        namespace = \"mathml\";\n      }\n      if (dynamicChildren) {\n        patchBlockChildren(\n          n1.dynamicChildren,\n          dynamicChildren,\n          currentContainer,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds\n        );\n        traverseStaticChildren(n1, n2, true);\n      } else if (!optimized) {\n        patchChildren(\n          n1,\n          n2,\n          currentContainer,\n          currentAnchor,\n          parentComponent,\n          parentSuspense,\n          namespace,\n          slotScopeIds,\n          false\n        );\n      }\n      if (disabled) {\n        if (!wasDisabled) {\n          moveTeleport(\n            n2,\n            container,\n            mainAnchor,\n            internals,\n            1\n          );\n        } else {\n          if (n2.props && n1.props && n2.props.to !== n1.props.to) {\n            n2.props.to = n1.props.to;\n          }\n        }\n      } else {\n        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {\n          const nextTarget = n2.target = resolveTarget(\n            n2.props,\n            querySelector\n          );\n          if (nextTarget) {\n            moveTeleport(\n              n2,\n              nextTarget,\n              null,\n              internals,\n              0\n            );\n          } else if (!!(process.env.NODE_ENV !== \"production\")) {\n            warn$1(\n              \"Invalid Teleport target on update:\",\n              target,\n              `(${typeof target})`\n            );\n          }\n        } else if (wasDisabled) {\n          moveTeleport(\n            n2,\n            target,\n            targetAnchor,\n            internals,\n            1\n          );\n        }\n      }\n    }\n    updateCssVars(n2);\n  },\n  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {\n    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;\n    if (target) {\n      hostRemove(targetAnchor);\n    }\n    doRemove && hostRemove(anchor);\n    if (shapeFlag & 16) {\n      const shouldRemove = doRemove || !isTeleportDisabled(props);\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        unmount(\n          child,\n          parentComponent,\n          parentSuspense,\n          shouldRemove,\n          !!child.dynamicChildren\n        );\n      }\n    }\n  },\n  move: moveTeleport,\n  hydrate: hydrateTeleport\n};\nfunction moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {\n  if (moveType === 0) {\n    insert(vnode.targetAnchor, container, parentAnchor);\n  }\n  const { el, anchor, shapeFlag, children, props } = vnode;\n  const isReorder = moveType === 2;\n  if (isReorder) {\n    insert(el, container, parentAnchor);\n  }\n  if (!isReorder || isTeleportDisabled(props)) {\n    if (shapeFlag & 16) {\n      for (let i = 0; i < children.length; i++) {\n        move(\n          children[i],\n          container,\n          parentAnchor,\n          2\n        );\n      }\n    }\n  }\n  if (isReorder) {\n    insert(anchor, container, parentAnchor);\n  }\n}\nfunction hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {\n  o: { nextSibling, parentNode, querySelector }\n}, hydrateChildren) {\n  const target = vnode.target = resolveTarget(\n    vnode.props,\n    querySelector\n  );\n  if (target) {\n    const targetNode = target._lpa || target.firstChild;\n    if (vnode.shapeFlag & 16) {\n      if (isTeleportDisabled(vnode.props)) {\n        vnode.anchor = hydrateChildren(\n          nextSibling(node),\n          vnode,\n          parentNode(node),\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n        vnode.targetAnchor = targetNode;\n      } else {\n        vnode.anchor = nextSibling(node);\n        let targetAnchor = targetNode;\n        while (targetAnchor) {\n          targetAnchor = nextSibling(targetAnchor);\n          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === \"teleport anchor\") {\n            vnode.targetAnchor = targetAnchor;\n            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);\n            break;\n          }\n        }\n        hydrateChildren(\n          targetNode,\n          vnode,\n          target,\n          parentComponent,\n          parentSuspense,\n          slotScopeIds,\n          optimized\n        );\n      }\n    }\n    updateCssVars(vnode);\n  }\n  return vnode.anchor && nextSibling(vnode.anchor);\n}\nconst Teleport = TeleportImpl;\nfunction updateCssVars(vnode) {\n  const ctx = vnode.ctx;\n  if (ctx && ctx.ut) {\n    let node = vnode.children[0].el;\n    while (node && node !== vnode.targetAnchor) {\n      if (node.nodeType === 1)\n        node.setAttribute(\"data-v-owner\", ctx.uid);\n      node = node.nextSibling;\n    }\n    ctx.ut();\n  }\n}\n\nconst Fragment = Symbol.for(\"v-fgt\");\nconst Text = Symbol.for(\"v-txt\");\nconst Comment = Symbol.for(\"v-cmt\");\nconst Static = Symbol.for(\"v-stc\");\nconst blockStack = [];\nlet currentBlock = null;\nfunction openBlock(disableTracking = false) {\n  blockStack.push(currentBlock = disableTracking ? null : []);\n}\nfunction closeBlock() {\n  blockStack.pop();\n  currentBlock = blockStack[blockStack.length - 1] || null;\n}\nlet isBlockTreeEnabled = 1;\nfunction setBlockTracking(value) {\n  isBlockTreeEnabled += value;\n}\nfunction setupBlock(vnode) {\n  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;\n  closeBlock();\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nfunction createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {\n  return setupBlock(\n    createBaseVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      shapeFlag,\n      true\n    )\n  );\n}\nfunction createBlock(type, props, children, patchFlag, dynamicProps) {\n  return setupBlock(\n    createVNode(\n      type,\n      props,\n      children,\n      patchFlag,\n      dynamicProps,\n      true\n    )\n  );\n}\nfunction isVNode(value) {\n  return value ? value.__v_isVNode === true : false;\n}\nfunction isSameVNodeType(n1, n2) {\n  if (!!(process.env.NODE_ENV !== \"production\") && n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {\n    n1.shapeFlag &= ~256;\n    n2.shapeFlag &= ~512;\n    return false;\n  }\n  return n1.type === n2.type && n1.key === n2.key;\n}\nlet vnodeArgsTransformer;\nfunction transformVNodeArgs(transformer) {\n  vnodeArgsTransformer = transformer;\n}\nconst createVNodeWithArgsTransform = (...args) => {\n  return _createVNode(\n    ...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args\n  );\n};\nconst normalizeKey = ({ key }) => key != null ? key : null;\nconst normalizeRef = ({\n  ref,\n  ref_key,\n  ref_for\n}) => {\n  if (typeof ref === \"number\") {\n    ref = \"\" + ref;\n  }\n  return ref != null ? isString(ref) || isRef(ref) || isFunction(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;\n};\nfunction createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {\n  const vnode = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type,\n    props,\n    key: props && normalizeKey(props),\n    ref: props && normalizeRef(props),\n    scopeId: currentScopeId,\n    slotScopeIds: null,\n    children,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag,\n    patchFlag,\n    dynamicProps,\n    dynamicChildren: null,\n    appContext: null,\n    ctx: currentRenderingInstance\n  };\n  if (needFullChildrenNormalization) {\n    normalizeChildren(vnode, children);\n    if (shapeFlag & 128) {\n      type.normalize(vnode);\n    }\n  } else if (children) {\n    vnode.shapeFlag |= isString(children) ? 8 : 16;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && vnode.key !== vnode.key) {\n    warn$1(`VNode created with invalid key (NaN). VNode type:`, vnode.type);\n  }\n  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself\n  !isBlockNode && // has current parent block\n  currentBlock && // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn't need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  vnode.patchFlag !== 32) {\n    currentBlock.push(vnode);\n  }\n  return vnode;\n}\nconst createVNode = !!(process.env.NODE_ENV !== \"production\") ? createVNodeWithArgsTransform : _createVNode;\nfunction _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {\n  if (!type || type === NULL_DYNAMIC_COMPONENT) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !type) {\n      warn$1(`Invalid vnode type when creating vnode: ${type}.`);\n    }\n    type = Comment;\n  }\n  if (isVNode(type)) {\n    const cloned = cloneVNode(\n      type,\n      props,\n      true\n      /* mergeRef: true */\n    );\n    if (children) {\n      normalizeChildren(cloned, children);\n    }\n    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {\n      if (cloned.shapeFlag & 6) {\n        currentBlock[currentBlock.indexOf(type)] = cloned;\n      } else {\n        currentBlock.push(cloned);\n      }\n    }\n    cloned.patchFlag |= -2;\n    return cloned;\n  }\n  if (isClassComponent(type)) {\n    type = type.__vccOpts;\n  }\n  if (props) {\n    props = guardReactiveProps(props);\n    let { class: klass, style } = props;\n    if (klass && !isString(klass)) {\n      props.class = normalizeClass(klass);\n    }\n    if (isObject(style)) {\n      if (isProxy(style) && !isArray(style)) {\n        style = extend({}, style);\n      }\n      props.style = normalizeStyle(style);\n    }\n  }\n  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;\n  if (!!(process.env.NODE_ENV !== \"production\") && shapeFlag & 4 && isProxy(type)) {\n    type = toRaw(type);\n    warn$1(\n      `Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with \\`markRaw\\` or using \\`shallowRef\\` instead of \\`ref\\`.`,\n      `\nComponent that was made reactive: `,\n      type\n    );\n  }\n  return createBaseVNode(\n    type,\n    props,\n    children,\n    patchFlag,\n    dynamicProps,\n    shapeFlag,\n    isBlockNode,\n    true\n  );\n}\nfunction guardReactiveProps(props) {\n  if (!props)\n    return null;\n  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;\n}\nfunction cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {\n  const { props, ref, patchFlag, children, transition } = vnode;\n  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;\n  const cloned = {\n    __v_isVNode: true,\n    __v_skip: true,\n    type: vnode.type,\n    props: mergedProps,\n    key: mergedProps && normalizeKey(mergedProps),\n    ref: extraProps && extraProps.ref ? (\n      // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n      // if the vnode itself already has a ref, cloneVNode will need to merge\n      // the refs so the single vnode can be set on multiple refs\n      mergeRef && ref ? isArray(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)\n    ) : ref,\n    scopeId: vnode.scopeId,\n    slotScopeIds: vnode.slotScopeIds,\n    children: !!(process.env.NODE_ENV !== \"production\") && patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,\n    target: vnode.target,\n    targetAnchor: vnode.targetAnchor,\n    staticCount: vnode.staticCount,\n    shapeFlag: vnode.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,\n    dynamicProps: vnode.dynamicProps,\n    dynamicChildren: vnode.dynamicChildren,\n    appContext: vnode.appContext,\n    dirs: vnode.dirs,\n    transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: vnode.component,\n    suspense: vnode.suspense,\n    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),\n    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),\n    el: vnode.el,\n    anchor: vnode.anchor,\n    ctx: vnode.ctx,\n    ce: vnode.ce\n  };\n  if (transition && cloneTransition) {\n    cloned.transition = transition.clone(cloned);\n  }\n  return cloned;\n}\nfunction deepCloneVNode(vnode) {\n  const cloned = cloneVNode(vnode);\n  if (isArray(vnode.children)) {\n    cloned.children = vnode.children.map(deepCloneVNode);\n  }\n  return cloned;\n}\nfunction createTextVNode(text = \" \", flag = 0) {\n  return createVNode(Text, null, text, flag);\n}\nfunction createStaticVNode(content, numberOfNodes) {\n  const vnode = createVNode(Static, null, content);\n  vnode.staticCount = numberOfNodes;\n  return vnode;\n}\nfunction createCommentVNode(text = \"\", asBlock = false) {\n  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);\n}\nfunction normalizeVNode(child) {\n  if (child == null || typeof child === \"boolean\") {\n    return createVNode(Comment);\n  } else if (isArray(child)) {\n    return createVNode(\n      Fragment,\n      null,\n      // #3666, avoid reference pollution when reusing vnode\n      child.slice()\n    );\n  } else if (typeof child === \"object\") {\n    return cloneIfMounted(child);\n  } else {\n    return createVNode(Text, null, String(child));\n  }\n}\nfunction cloneIfMounted(child) {\n  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);\n}\nfunction normalizeChildren(vnode, children) {\n  let type = 0;\n  const { shapeFlag } = vnode;\n  if (children == null) {\n    children = null;\n  } else if (isArray(children)) {\n    type = 16;\n  } else if (typeof children === \"object\") {\n    if (shapeFlag & (1 | 64)) {\n      const slot = children.default;\n      if (slot) {\n        slot._c && (slot._d = false);\n        normalizeChildren(vnode, slot());\n        slot._c && (slot._d = true);\n      }\n      return;\n    } else {\n      type = 32;\n      const slotFlag = children._;\n      if (!slotFlag && !isInternalObject(children)) {\n        children._ctx = currentRenderingInstance;\n      } else if (slotFlag === 3 && currentRenderingInstance) {\n        if (currentRenderingInstance.slots._ === 1) {\n          children._ = 1;\n        } else {\n          children._ = 2;\n          vnode.patchFlag |= 1024;\n        }\n      }\n    }\n  } else if (isFunction(children)) {\n    children = { default: children, _ctx: currentRenderingInstance };\n    type = 32;\n  } else {\n    children = String(children);\n    if (shapeFlag & 64) {\n      type = 16;\n      children = [createTextVNode(children)];\n    } else {\n      type = 8;\n    }\n  }\n  vnode.children = children;\n  vnode.shapeFlag |= type;\n}\nfunction mergeProps(...args) {\n  const ret = {};\n  for (let i = 0; i < args.length; i++) {\n    const toMerge = args[i];\n    for (const key in toMerge) {\n      if (key === \"class\") {\n        if (ret.class !== toMerge.class) {\n          ret.class = normalizeClass([ret.class, toMerge.class]);\n        }\n      } else if (key === \"style\") {\n        ret.style = normalizeStyle([ret.style, toMerge.style]);\n      } else if (isOn(key)) {\n        const existing = ret[key];\n        const incoming = toMerge[key];\n        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {\n          ret[key] = existing ? [].concat(existing, incoming) : incoming;\n        }\n      } else if (key !== \"\") {\n        ret[key] = toMerge[key];\n      }\n    }\n  }\n  return ret;\n}\nfunction invokeVNodeHook(hook, instance, vnode, prevVNode = null) {\n  callWithAsyncErrorHandling(hook, instance, 7, [\n    vnode,\n    prevVNode\n  ]);\n}\n\nconst emptyAppContext = createAppContext();\nlet uid = 0;\nfunction createComponentInstance(vnode, parent, suspense) {\n  const type = vnode.type;\n  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;\n  const instance = {\n    uid: uid++,\n    vnode,\n    type,\n    parent,\n    appContext,\n    root: null,\n    // to be immediately set\n    next: null,\n    subTree: null,\n    // will be set synchronously right after creation\n    effect: null,\n    update: null,\n    // will be set synchronously right after creation\n    scope: new EffectScope(\n      true\n      /* detached */\n    ),\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    accessCache: null,\n    renderCache: [],\n    // local resolved assets\n    components: null,\n    directives: null,\n    // resolved props and emits options\n    propsOptions: normalizePropsOptions(type, appContext),\n    emitsOptions: normalizeEmitsOptions(type, appContext),\n    // emit\n    emit: null,\n    // to be set immediately\n    emitted: null,\n    // props default value\n    propsDefaults: EMPTY_OBJ,\n    // inheritAttrs\n    inheritAttrs: type.inheritAttrs,\n    // state\n    ctx: EMPTY_OBJ,\n    data: EMPTY_OBJ,\n    props: EMPTY_OBJ,\n    attrs: EMPTY_OBJ,\n    slots: EMPTY_OBJ,\n    refs: EMPTY_OBJ,\n    setupState: EMPTY_OBJ,\n    setupContext: null,\n    attrsProxy: null,\n    slotsProxy: null,\n    // suspense related\n    suspense,\n    suspenseId: suspense ? suspense.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: false,\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: false,\n    isUnmounted: false,\n    isDeactivated: false,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    instance.ctx = createDevRenderContext(instance);\n  } else {\n    instance.ctx = { _: instance };\n  }\n  instance.root = parent ? parent.root : instance;\n  instance.emit = emit.bind(null, instance);\n  if (vnode.ce) {\n    vnode.ce(instance);\n  }\n  return instance;\n}\nlet currentInstance = null;\nconst getCurrentInstance = () => currentInstance || currentRenderingInstance;\nlet internalSetCurrentInstance;\nlet setInSSRSetupState;\n{\n  const g = getGlobalThis();\n  const registerGlobalSetter = (key, setter) => {\n    let setters;\n    if (!(setters = g[key]))\n      setters = g[key] = [];\n    setters.push(setter);\n    return (v) => {\n      if (setters.length > 1)\n        setters.forEach((set) => set(v));\n      else\n        setters[0](v);\n    };\n  };\n  internalSetCurrentInstance = registerGlobalSetter(\n    `__VUE_INSTANCE_SETTERS__`,\n    (v) => currentInstance = v\n  );\n  setInSSRSetupState = registerGlobalSetter(\n    `__VUE_SSR_SETTERS__`,\n    (v) => isInSSRComponentSetup = v\n  );\n}\nconst setCurrentInstance = (instance) => {\n  const prev = currentInstance;\n  internalSetCurrentInstance(instance);\n  instance.scope.on();\n  return () => {\n    instance.scope.off();\n    internalSetCurrentInstance(prev);\n  };\n};\nconst unsetCurrentInstance = () => {\n  currentInstance && currentInstance.scope.off();\n  internalSetCurrentInstance(null);\n};\nconst isBuiltInTag = /* @__PURE__ */ makeMap(\"slot,component\");\nfunction validateComponentName(name, { isNativeTag }) {\n  if (isBuiltInTag(name) || isNativeTag(name)) {\n    warn$1(\n      \"Do not use built-in or reserved HTML elements as component id: \" + name\n    );\n  }\n}\nfunction isStatefulComponent(instance) {\n  return instance.vnode.shapeFlag & 4;\n}\nlet isInSSRComponentSetup = false;\nfunction setupComponent(instance, isSSR = false) {\n  isSSR && setInSSRSetupState(isSSR);\n  const { props, children } = instance.vnode;\n  const isStateful = isStatefulComponent(instance);\n  initProps(instance, props, isStateful, isSSR);\n  initSlots(instance, children);\n  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;\n  isSSR && setInSSRSetupState(false);\n  return setupResult;\n}\nfunction setupStatefulComponent(instance, isSSR) {\n  var _a;\n  const Component = instance.type;\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    if (Component.name) {\n      validateComponentName(Component.name, instance.appContext.config);\n    }\n    if (Component.components) {\n      const names = Object.keys(Component.components);\n      for (let i = 0; i < names.length; i++) {\n        validateComponentName(names[i], instance.appContext.config);\n      }\n    }\n    if (Component.directives) {\n      const names = Object.keys(Component.directives);\n      for (let i = 0; i < names.length; i++) {\n        validateDirectiveName(names[i]);\n      }\n    }\n    if (Component.compilerOptions && isRuntimeOnly()) {\n      warn$1(\n        `\"compilerOptions\" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`\n      );\n    }\n  }\n  instance.accessCache = /* @__PURE__ */ Object.create(null);\n  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    exposePropsOnRenderContext(instance);\n  }\n  const { setup } = Component;\n  if (setup) {\n    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;\n    const reset = setCurrentInstance(instance);\n    pauseTracking();\n    const setupResult = callWithErrorHandling(\n      setup,\n      instance,\n      0,\n      [\n        !!(process.env.NODE_ENV !== \"production\") ? shallowReadonly(instance.props) : instance.props,\n        setupContext\n      ]\n    );\n    resetTracking();\n    reset();\n    if (isPromise(setupResult)) {\n      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);\n      if (isSSR) {\n        return setupResult.then((resolvedResult) => {\n          handleSetupResult(instance, resolvedResult, isSSR);\n        }).catch((e) => {\n          handleError(e, instance, 0);\n        });\n      } else {\n        instance.asyncDep = setupResult;\n        if (!!(process.env.NODE_ENV !== \"production\") && !instance.suspense) {\n          const name = (_a = Component.name) != null ? _a : \"Anonymous\";\n          warn$1(\n            `Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`\n          );\n        }\n      }\n    } else {\n      handleSetupResult(instance, setupResult, isSSR);\n    }\n  } else {\n    finishComponentSetup(instance, isSSR);\n  }\n}\nfunction handleSetupResult(instance, setupResult, isSSR) {\n  if (isFunction(setupResult)) {\n    if (instance.type.__ssrInlineRender) {\n      instance.ssrRender = setupResult;\n    } else {\n      instance.render = setupResult;\n    }\n  } else if (isObject(setupResult)) {\n    if (!!(process.env.NODE_ENV !== \"production\") && isVNode(setupResult)) {\n      warn$1(\n        `setup() should not return VNodes directly - return a render function instead.`\n      );\n    }\n    if (!!(process.env.NODE_ENV !== \"production\") || __VUE_PROD_DEVTOOLS__) {\n      instance.devtoolsRawSetupState = setupResult;\n    }\n    instance.setupState = proxyRefs(setupResult);\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      exposeSetupStateOnRenderContext(instance);\n    }\n  } else if (!!(process.env.NODE_ENV !== \"production\") && setupResult !== void 0) {\n    warn$1(\n      `setup() should return an object. Received: ${setupResult === null ? \"null\" : typeof setupResult}`\n    );\n  }\n  finishComponentSetup(instance, isSSR);\n}\nlet compile;\nlet installWithProxy;\nfunction registerRuntimeCompiler(_compile) {\n  compile = _compile;\n  installWithProxy = (i) => {\n    if (i.render._rc) {\n      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);\n    }\n  };\n}\nconst isRuntimeOnly = () => !compile;\nfunction finishComponentSetup(instance, isSSR, skipOptions) {\n  const Component = instance.type;\n  if (!instance.render) {\n    if (!isSSR && compile && !Component.render) {\n      const template = Component.template || resolveMergedOptions(instance).template;\n      if (template) {\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          startMeasure(instance, `compile`);\n        }\n        const { isCustomElement, compilerOptions } = instance.appContext.config;\n        const { delimiters, compilerOptions: componentCompilerOptions } = Component;\n        const finalCompilerOptions = extend(\n          extend(\n            {\n              isCustomElement,\n              delimiters\n            },\n            compilerOptions\n          ),\n          componentCompilerOptions\n        );\n        Component.render = compile(template, finalCompilerOptions);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          endMeasure(instance, `compile`);\n        }\n      }\n    }\n    instance.render = Component.render || NOOP;\n    if (installWithProxy) {\n      installWithProxy(instance);\n    }\n  }\n  if (__VUE_OPTIONS_API__ && true) {\n    const reset = setCurrentInstance(instance);\n    pauseTracking();\n    try {\n      applyOptions(instance);\n    } finally {\n      resetTracking();\n      reset();\n    }\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && !Component.render && instance.render === NOOP && !isSSR) {\n    if (!compile && Component.template) {\n      warn$1(\n        `Component provided template option but runtime compilation is not supported in this build of Vue.` + (` Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".` )\n      );\n    } else {\n      warn$1(`Component is missing template or render function.`);\n    }\n  }\n}\nconst attrsProxyHandlers = !!(process.env.NODE_ENV !== \"production\") ? {\n  get(target, key) {\n    markAttrsAccessed();\n    track(target, \"get\", \"\");\n    return target[key];\n  },\n  set() {\n    warn$1(`setupContext.attrs is readonly.`);\n    return false;\n  },\n  deleteProperty() {\n    warn$1(`setupContext.attrs is readonly.`);\n    return false;\n  }\n} : {\n  get(target, key) {\n    track(target, \"get\", \"\");\n    return target[key];\n  }\n};\nfunction getSlotsProxy(instance) {\n  return instance.slotsProxy || (instance.slotsProxy = new Proxy(instance.slots, {\n    get(target, key) {\n      track(instance, \"get\", \"$slots\");\n      return target[key];\n    }\n  }));\n}\nfunction createSetupContext(instance) {\n  const expose = (exposed) => {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      if (instance.exposed) {\n        warn$1(`expose() should be called only once per setup().`);\n      }\n      if (exposed != null) {\n        let exposedType = typeof exposed;\n        if (exposedType === \"object\") {\n          if (isArray(exposed)) {\n            exposedType = \"array\";\n          } else if (isRef(exposed)) {\n            exposedType = \"ref\";\n          }\n        }\n        if (exposedType !== \"object\") {\n          warn$1(\n            `expose() should be passed a plain object, received ${exposedType}.`\n          );\n        }\n      }\n    }\n    instance.exposed = exposed || {};\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    let attrsProxy;\n    return Object.freeze({\n      get attrs() {\n        return attrsProxy || (attrsProxy = new Proxy(instance.attrs, attrsProxyHandlers));\n      },\n      get slots() {\n        return getSlotsProxy(instance);\n      },\n      get emit() {\n        return (event, ...args) => instance.emit(event, ...args);\n      },\n      expose\n    });\n  } else {\n    return {\n      attrs: new Proxy(instance.attrs, attrsProxyHandlers),\n      slots: instance.slots,\n      emit: instance.emit,\n      expose\n    };\n  }\n}\nfunction getExposeProxy(instance) {\n  if (instance.exposed) {\n    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {\n      get(target, key) {\n        if (key in target) {\n          return target[key];\n        } else if (key in publicPropertiesMap) {\n          return publicPropertiesMap[key](instance);\n        }\n      },\n      has(target, key) {\n        return key in target || key in publicPropertiesMap;\n      }\n    }));\n  }\n}\nconst classifyRE = /(?:^|[-_])(\\w)/g;\nconst classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, \"\");\nfunction getComponentName(Component, includeInferred = true) {\n  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;\n}\nfunction formatComponentName(instance, Component, isRoot = false) {\n  let name = getComponentName(Component);\n  if (!name && Component.__file) {\n    const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n    if (match) {\n      name = match[1];\n    }\n  }\n  if (!name && instance && instance.parent) {\n    const inferFromRegistry = (registry) => {\n      for (const key in registry) {\n        if (registry[key] === Component) {\n          return key;\n        }\n      }\n    };\n    name = inferFromRegistry(\n      instance.components || instance.parent.type.components\n    ) || inferFromRegistry(instance.appContext.components);\n  }\n  return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\nfunction isClassComponent(value) {\n  return isFunction(value) && \"__vccOpts\" in value;\n}\n\nconst computed = (getterOrOptions, debugOptions) => {\n  const c = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    const i = getCurrentInstance();\n    if (i && i.appContext.config.warnRecursiveComputed) {\n      c._warnRecursive = true;\n    }\n  }\n  return c;\n};\n\nfunction useModel(props, name, options = EMPTY_OBJ) {\n  const i = getCurrentInstance();\n  if (!!(process.env.NODE_ENV !== \"production\") && !i) {\n    warn$1(`useModel() called without active instance.`);\n    return ref();\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && !i.propsOptions[0][name]) {\n    warn$1(`useModel() called with prop \"${name}\" which is not declared.`);\n    return ref();\n  }\n  const camelizedName = camelize(name);\n  const hyphenatedName = hyphenate(name);\n  const res = customRef((track, trigger) => {\n    let localValue;\n    watchSyncEffect(() => {\n      const propValue = props[name];\n      if (hasChanged(localValue, propValue)) {\n        localValue = propValue;\n        trigger();\n      }\n    });\n    return {\n      get() {\n        track();\n        return options.get ? options.get(localValue) : localValue;\n      },\n      set(value) {\n        const rawProps = i.vnode.props;\n        if (!(rawProps && // check if parent has passed v-model\n        (name in rawProps || camelizedName in rawProps || hyphenatedName in rawProps) && (`onUpdate:${name}` in rawProps || `onUpdate:${camelizedName}` in rawProps || `onUpdate:${hyphenatedName}` in rawProps)) && hasChanged(value, localValue)) {\n          localValue = value;\n          trigger();\n        }\n        i.emit(`update:${name}`, options.set ? options.set(value) : value);\n      }\n    };\n  });\n  const modifierKey = name === \"modelValue\" ? \"modelModifiers\" : `${name}Modifiers`;\n  res[Symbol.iterator] = () => {\n    let i2 = 0;\n    return {\n      next() {\n        if (i2 < 2) {\n          return { value: i2++ ? props[modifierKey] || {} : res, done: false };\n        } else {\n          return { done: true };\n        }\n      }\n    };\n  };\n  return res;\n}\n\nfunction h(type, propsOrChildren, children) {\n  const l = arguments.length;\n  if (l === 2) {\n    if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {\n      if (isVNode(propsOrChildren)) {\n        return createVNode(type, null, [propsOrChildren]);\n      }\n      return createVNode(type, propsOrChildren);\n    } else {\n      return createVNode(type, null, propsOrChildren);\n    }\n  } else {\n    if (l > 3) {\n      children = Array.prototype.slice.call(arguments, 2);\n    } else if (l === 3 && isVNode(children)) {\n      children = [children];\n    }\n    return createVNode(type, propsOrChildren, children);\n  }\n}\n\nfunction initCustomFormatter() {\n  if (!!!(process.env.NODE_ENV !== \"production\") || typeof window === \"undefined\") {\n    return;\n  }\n  const vueStyle = { style: \"color:#3ba776\" };\n  const numberStyle = { style: \"color:#1677ff\" };\n  const stringStyle = { style: \"color:#f5222d\" };\n  const keywordStyle = { style: \"color:#eb2f96\" };\n  const formatter = {\n    header(obj) {\n      if (!isObject(obj)) {\n        return null;\n      }\n      if (obj.__isVue) {\n        return [\"div\", vueStyle, `VueInstance`];\n      } else if (isRef(obj)) {\n        return [\n          \"div\",\n          {},\n          [\"span\", vueStyle, genRefFlag(obj)],\n          \"<\",\n          formatValue(obj.value),\n          `>`\n        ];\n      } else if (isReactive(obj)) {\n        return [\n          \"div\",\n          {},\n          [\"span\", vueStyle, isShallow(obj) ? \"ShallowReactive\" : \"Reactive\"],\n          \"<\",\n          formatValue(obj),\n          `>${isReadonly(obj) ? ` (readonly)` : ``}`\n        ];\n      } else if (isReadonly(obj)) {\n        return [\n          \"div\",\n          {},\n          [\"span\", vueStyle, isShallow(obj) ? \"ShallowReadonly\" : \"Readonly\"],\n          \"<\",\n          formatValue(obj),\n          \">\"\n        ];\n      }\n      return null;\n    },\n    hasBody(obj) {\n      return obj && obj.__isVue;\n    },\n    body(obj) {\n      if (obj && obj.__isVue) {\n        return [\n          \"div\",\n          {},\n          ...formatInstance(obj.$)\n        ];\n      }\n    }\n  };\n  function formatInstance(instance) {\n    const blocks = [];\n    if (instance.type.props && instance.props) {\n      blocks.push(createInstanceBlock(\"props\", toRaw(instance.props)));\n    }\n    if (instance.setupState !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock(\"setup\", instance.setupState));\n    }\n    if (instance.data !== EMPTY_OBJ) {\n      blocks.push(createInstanceBlock(\"data\", toRaw(instance.data)));\n    }\n    const computed = extractKeys(instance, \"computed\");\n    if (computed) {\n      blocks.push(createInstanceBlock(\"computed\", computed));\n    }\n    const injected = extractKeys(instance, \"inject\");\n    if (injected) {\n      blocks.push(createInstanceBlock(\"injected\", injected));\n    }\n    blocks.push([\n      \"div\",\n      {},\n      [\n        \"span\",\n        {\n          style: keywordStyle.style + \";opacity:0.66\"\n        },\n        \"$ (internal): \"\n      ],\n      [\"object\", { object: instance }]\n    ]);\n    return blocks;\n  }\n  function createInstanceBlock(type, target) {\n    target = extend({}, target);\n    if (!Object.keys(target).length) {\n      return [\"span\", {}];\n    }\n    return [\n      \"div\",\n      { style: \"line-height:1.25em;margin-bottom:0.6em\" },\n      [\n        \"div\",\n        {\n          style: \"color:#476582\"\n        },\n        type\n      ],\n      [\n        \"div\",\n        {\n          style: \"padding-left:1.25em\"\n        },\n        ...Object.keys(target).map((key) => {\n          return [\n            \"div\",\n            {},\n            [\"span\", keywordStyle, key + \": \"],\n            formatValue(target[key], false)\n          ];\n        })\n      ]\n    ];\n  }\n  function formatValue(v, asRaw = true) {\n    if (typeof v === \"number\") {\n      return [\"span\", numberStyle, v];\n    } else if (typeof v === \"string\") {\n      return [\"span\", stringStyle, JSON.stringify(v)];\n    } else if (typeof v === \"boolean\") {\n      return [\"span\", keywordStyle, v];\n    } else if (isObject(v)) {\n      return [\"object\", { object: asRaw ? toRaw(v) : v }];\n    } else {\n      return [\"span\", stringStyle, String(v)];\n    }\n  }\n  function extractKeys(instance, type) {\n    const Comp = instance.type;\n    if (isFunction(Comp)) {\n      return;\n    }\n    const extracted = {};\n    for (const key in instance.ctx) {\n      if (isKeyOfType(Comp, key, type)) {\n        extracted[key] = instance.ctx[key];\n      }\n    }\n    return extracted;\n  }\n  function isKeyOfType(Comp, key, type) {\n    const opts = Comp[type];\n    if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {\n      return true;\n    }\n    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {\n      return true;\n    }\n    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {\n      return true;\n    }\n  }\n  function genRefFlag(v) {\n    if (isShallow(v)) {\n      return `ShallowRef`;\n    }\n    if (v.effect) {\n      return `ComputedRef`;\n    }\n    return `Ref`;\n  }\n  if (window.devtoolsFormatters) {\n    window.devtoolsFormatters.push(formatter);\n  } else {\n    window.devtoolsFormatters = [formatter];\n  }\n}\n\nfunction withMemo(memo, render, cache, index) {\n  const cached = cache[index];\n  if (cached && isMemoSame(cached, memo)) {\n    return cached;\n  }\n  const ret = render();\n  ret.memo = memo.slice();\n  return cache[index] = ret;\n}\nfunction isMemoSame(cached, memo) {\n  const prev = cached.memo;\n  if (prev.length != memo.length) {\n    return false;\n  }\n  for (let i = 0; i < prev.length; i++) {\n    if (hasChanged(prev[i], memo[i])) {\n      return false;\n    }\n  }\n  if (isBlockTreeEnabled > 0 && currentBlock) {\n    currentBlock.push(cached);\n  }\n  return true;\n}\n\nconst version = \"3.4.27\";\nconst warn = !!(process.env.NODE_ENV !== \"production\") ? warn$1 : NOOP;\nconst ErrorTypeStrings = ErrorTypeStrings$1 ;\nconst devtools = !!(process.env.NODE_ENV !== \"production\") || true ? devtools$1 : void 0;\nconst setDevtoolsHook = !!(process.env.NODE_ENV !== \"production\") || true ? setDevtoolsHook$1 : NOOP;\nconst _ssrUtils = {\n  createComponentInstance,\n  setupComponent,\n  renderComponentRoot,\n  setCurrentRenderingInstance,\n  isVNode: isVNode,\n  normalizeVNode\n};\nconst ssrUtils = _ssrUtils ;\nconst resolveFilter = null;\nconst compatUtils = null;\nconst DeprecationTypes = null;\n\nexport { BaseTransition, BaseTransitionPropsValidators, Comment, DeprecationTypes, ErrorCodes, ErrorTypeStrings, Fragment, KeepAlive, Static, Suspense, Teleport, Text, assertNumber, callWithAsyncErrorHandling, callWithErrorHandling, cloneVNode, compatUtils, computed, createBlock, createCommentVNode, createElementBlock, createBaseVNode as createElementVNode, createHydrationRenderer, createPropsRestProxy, createRenderer, createSlots, createStaticVNode, createTextVNode, createVNode, defineAsyncComponent, defineComponent, defineEmits, defineExpose, defineModel, defineOptions, defineProps, defineSlots, devtools, getCurrentInstance, getTransitionRawChildren, guardReactiveProps, h, handleError, hasInjectionContext, initCustomFormatter, inject, isMemoSame, isRuntimeOnly, isVNode, mergeDefaults, mergeModels, mergeProps, nextTick, onActivated, onBeforeMount, onBeforeUnmount, onBeforeUpdate, onDeactivated, onErrorCaptured, onMounted, onRenderTracked, onRenderTriggered, onServerPrefetch, onUnmounted, onUpdated, openBlock, popScopeId, provide, pushScopeId, queuePostFlushCb, registerRuntimeCompiler, renderList, renderSlot, resolveComponent, resolveDirective, resolveDynamicComponent, resolveFilter, resolveTransitionHooks, setBlockTracking, setDevtoolsHook, setTransitionHooks, ssrContextKey, ssrUtils, toHandlers, transformVNodeArgs, useAttrs, useModel, useSSRContext, useSlots, useTransitionState, version, warn, watch, watchEffect, watchPostEffect, watchSyncEffect, withAsyncContext, withCtx, withDefaults, withDirectives, withMemo, withScopeId };\n","/**\n* @vue/runtime-dom v3.4.27\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { h, BaseTransition, BaseTransitionPropsValidators, assertNumber, getCurrentInstance, warn, onMounted, watchPostEffect, onUnmounted, Fragment, Static, camelize, callWithAsyncErrorHandling, defineComponent, nextTick, createVNode, useTransitionState, onUpdated, toRaw, getTransitionRawChildren, setTransitionHooks, resolveTransitionHooks, isRuntimeOnly, createRenderer, createHydrationRenderer } from '@vue/runtime-core';\nexport * from '@vue/runtime-core';\nimport { extend, isObject, toNumber, isArray, isString, hyphenate, capitalize, isSpecialBooleanAttr, includeBooleanAttr, isFunction, NOOP, isOn, isModelListener, camelize as camelize$1, EMPTY_OBJ, looseToNumber, looseIndexOf, isSet, looseEqual, invokeArrayFns, isHTMLTag, isSVGTag, isMathMLTag } from '@vue/shared';\n\nconst svgNS = \"http://www.w3.org/2000/svg\";\nconst mathmlNS = \"http://www.w3.org/1998/Math/MathML\";\nconst doc = typeof document !== \"undefined\" ? document : null;\nconst templateContainer = doc && /* @__PURE__ */ doc.createElement(\"template\");\nconst nodeOps = {\n  insert: (child, parent, anchor) => {\n    parent.insertBefore(child, anchor || null);\n  },\n  remove: (child) => {\n    const parent = child.parentNode;\n    if (parent) {\n      parent.removeChild(child);\n    }\n  },\n  createElement: (tag, namespace, is, props) => {\n    const el = namespace === \"svg\" ? doc.createElementNS(svgNS, tag) : namespace === \"mathml\" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);\n    if (tag === \"select\" && props && props.multiple != null) {\n      el.setAttribute(\"multiple\", props.multiple);\n    }\n    return el;\n  },\n  createText: (text) => doc.createTextNode(text),\n  createComment: (text) => doc.createComment(text),\n  setText: (node, text) => {\n    node.nodeValue = text;\n  },\n  setElementText: (el, text) => {\n    el.textContent = text;\n  },\n  parentNode: (node) => node.parentNode,\n  nextSibling: (node) => node.nextSibling,\n  querySelector: (selector) => doc.querySelector(selector),\n  setScopeId(el, id) {\n    el.setAttribute(id, \"\");\n  },\n  // __UNSAFE__\n  // Reason: innerHTML.\n  // Static content here can only come from compiled templates.\n  // As long as the user only uses trusted templates, this is safe.\n  insertStaticContent(content, parent, anchor, namespace, start, end) {\n    const before = anchor ? anchor.previousSibling : parent.lastChild;\n    if (start && (start === end || start.nextSibling)) {\n      while (true) {\n        parent.insertBefore(start.cloneNode(true), anchor);\n        if (start === end || !(start = start.nextSibling))\n          break;\n      }\n    } else {\n      templateContainer.innerHTML = namespace === \"svg\" ? `<svg>${content}</svg>` : namespace === \"mathml\" ? `<math>${content}</math>` : content;\n      const template = templateContainer.content;\n      if (namespace === \"svg\" || namespace === \"mathml\") {\n        const wrapper = template.firstChild;\n        while (wrapper.firstChild) {\n          template.appendChild(wrapper.firstChild);\n        }\n        template.removeChild(wrapper);\n      }\n      parent.insertBefore(template, anchor);\n    }\n    return [\n      // first\n      before ? before.nextSibling : parent.firstChild,\n      // last\n      anchor ? anchor.previousSibling : parent.lastChild\n    ];\n  }\n};\n\nconst TRANSITION = \"transition\";\nconst ANIMATION = \"animation\";\nconst vtcKey = Symbol(\"_vtc\");\nconst Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);\nTransition.displayName = \"Transition\";\nconst DOMTransitionPropsValidators = {\n  name: String,\n  type: String,\n  css: {\n    type: Boolean,\n    default: true\n  },\n  duration: [String, Number, Object],\n  enterFromClass: String,\n  enterActiveClass: String,\n  enterToClass: String,\n  appearFromClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  leaveFromClass: String,\n  leaveActiveClass: String,\n  leaveToClass: String\n};\nconst TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(\n  {},\n  BaseTransitionPropsValidators,\n  DOMTransitionPropsValidators\n);\nconst callHook = (hook, args = []) => {\n  if (isArray(hook)) {\n    hook.forEach((h2) => h2(...args));\n  } else if (hook) {\n    hook(...args);\n  }\n};\nconst hasExplicitCallback = (hook) => {\n  return hook ? isArray(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;\n};\nfunction resolveTransitionProps(rawProps) {\n  const baseProps = {};\n  for (const key in rawProps) {\n    if (!(key in DOMTransitionPropsValidators)) {\n      baseProps[key] = rawProps[key];\n    }\n  }\n  if (rawProps.css === false) {\n    return baseProps;\n  }\n  const {\n    name = \"v\",\n    type,\n    duration,\n    enterFromClass = `${name}-enter-from`,\n    enterActiveClass = `${name}-enter-active`,\n    enterToClass = `${name}-enter-to`,\n    appearFromClass = enterFromClass,\n    appearActiveClass = enterActiveClass,\n    appearToClass = enterToClass,\n    leaveFromClass = `${name}-leave-from`,\n    leaveActiveClass = `${name}-leave-active`,\n    leaveToClass = `${name}-leave-to`\n  } = rawProps;\n  const durations = normalizeDuration(duration);\n  const enterDuration = durations && durations[0];\n  const leaveDuration = durations && durations[1];\n  const {\n    onBeforeEnter,\n    onEnter,\n    onEnterCancelled,\n    onLeave,\n    onLeaveCancelled,\n    onBeforeAppear = onBeforeEnter,\n    onAppear = onEnter,\n    onAppearCancelled = onEnterCancelled\n  } = baseProps;\n  const finishEnter = (el, isAppear, done) => {\n    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n    done && done();\n  };\n  const finishLeave = (el, done) => {\n    el._isLeaving = false;\n    removeTransitionClass(el, leaveFromClass);\n    removeTransitionClass(el, leaveToClass);\n    removeTransitionClass(el, leaveActiveClass);\n    done && done();\n  };\n  const makeEnterHook = (isAppear) => {\n    return (el, done) => {\n      const hook = isAppear ? onAppear : onEnter;\n      const resolve = () => finishEnter(el, isAppear, done);\n      callHook(hook, [el, resolve]);\n      nextFrame(() => {\n        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n        addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n        if (!hasExplicitCallback(hook)) {\n          whenTransitionEnds(el, type, enterDuration, resolve);\n        }\n      });\n    };\n  };\n  return extend(baseProps, {\n    onBeforeEnter(el) {\n      callHook(onBeforeEnter, [el]);\n      addTransitionClass(el, enterFromClass);\n      addTransitionClass(el, enterActiveClass);\n    },\n    onBeforeAppear(el) {\n      callHook(onBeforeAppear, [el]);\n      addTransitionClass(el, appearFromClass);\n      addTransitionClass(el, appearActiveClass);\n    },\n    onEnter: makeEnterHook(false),\n    onAppear: makeEnterHook(true),\n    onLeave(el, done) {\n      el._isLeaving = true;\n      const resolve = () => finishLeave(el, done);\n      addTransitionClass(el, leaveFromClass);\n      addTransitionClass(el, leaveActiveClass);\n      forceReflow();\n      nextFrame(() => {\n        if (!el._isLeaving) {\n          return;\n        }\n        removeTransitionClass(el, leaveFromClass);\n        addTransitionClass(el, leaveToClass);\n        if (!hasExplicitCallback(onLeave)) {\n          whenTransitionEnds(el, type, leaveDuration, resolve);\n        }\n      });\n      callHook(onLeave, [el, resolve]);\n    },\n    onEnterCancelled(el) {\n      finishEnter(el, false);\n      callHook(onEnterCancelled, [el]);\n    },\n    onAppearCancelled(el) {\n      finishEnter(el, true);\n      callHook(onAppearCancelled, [el]);\n    },\n    onLeaveCancelled(el) {\n      finishLeave(el);\n      callHook(onLeaveCancelled, [el]);\n    }\n  });\n}\nfunction normalizeDuration(duration) {\n  if (duration == null) {\n    return null;\n  } else if (isObject(duration)) {\n    return [NumberOf(duration.enter), NumberOf(duration.leave)];\n  } else {\n    const n = NumberOf(duration);\n    return [n, n];\n  }\n}\nfunction NumberOf(val) {\n  const res = toNumber(val);\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    assertNumber(res, \"<transition> explicit duration\");\n  }\n  return res;\n}\nfunction addTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach((c) => c && el.classList.add(c));\n  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);\n}\nfunction removeTransitionClass(el, cls) {\n  cls.split(/\\s+/).forEach((c) => c && el.classList.remove(c));\n  const _vtc = el[vtcKey];\n  if (_vtc) {\n    _vtc.delete(cls);\n    if (!_vtc.size) {\n      el[vtcKey] = void 0;\n    }\n  }\n}\nfunction nextFrame(cb) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(cb);\n  });\n}\nlet endId = 0;\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\n  const id = el._endId = ++endId;\n  const resolveIfNotStale = () => {\n    if (id === el._endId) {\n      resolve();\n    }\n  };\n  if (explicitTimeout) {\n    return setTimeout(resolveIfNotStale, explicitTimeout);\n  }\n  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\n  if (!type) {\n    return resolve();\n  }\n  const endEvent = type + \"end\";\n  let ended = 0;\n  const end = () => {\n    el.removeEventListener(endEvent, onEnd);\n    resolveIfNotStale();\n  };\n  const onEnd = (e) => {\n    if (e.target === el && ++ended >= propCount) {\n      end();\n    }\n  };\n  setTimeout(() => {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(endEvent, onEnd);\n}\nfunction getTransitionInfo(el, expectedType) {\n  const styles = window.getComputedStyle(el);\n  const getStyleProperties = (key) => (styles[key] || \"\").split(\", \");\n  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);\n  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);\n  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);\n  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);\n  const animationTimeout = getTimeout(animationDelays, animationDurations);\n  let type = null;\n  let timeout = 0;\n  let propCount = 0;\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;\n    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;\n  }\n  const hasTransform = type === TRANSITION && /\\b(transform|all)(,|$)/.test(\n    getStyleProperties(`${TRANSITION}Property`).toString()\n  );\n  return {\n    type,\n    timeout,\n    propCount,\n    hasTransform\n  };\n}\nfunction getTimeout(delays, durations) {\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n}\nfunction toMs(s) {\n  if (s === \"auto\")\n    return 0;\n  return Number(s.slice(0, -1).replace(\",\", \".\")) * 1e3;\n}\nfunction forceReflow() {\n  return document.body.offsetHeight;\n}\n\nfunction patchClass(el, value, isSVG) {\n  const transitionClasses = el[vtcKey];\n  if (transitionClasses) {\n    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(\" \");\n  }\n  if (value == null) {\n    el.removeAttribute(\"class\");\n  } else if (isSVG) {\n    el.setAttribute(\"class\", value);\n  } else {\n    el.className = value;\n  }\n}\n\nconst vShowOriginalDisplay = Symbol(\"_vod\");\nconst vShowHidden = Symbol(\"_vsh\");\nconst vShow = {\n  beforeMount(el, { value }, { transition }) {\n    el[vShowOriginalDisplay] = el.style.display === \"none\" ? \"\" : el.style.display;\n    if (transition && value) {\n      transition.beforeEnter(el);\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  mounted(el, { value }, { transition }) {\n    if (transition && value) {\n      transition.enter(el);\n    }\n  },\n  updated(el, { value, oldValue }, { transition }) {\n    if (!value === !oldValue)\n      return;\n    if (transition) {\n      if (value) {\n        transition.beforeEnter(el);\n        setDisplay(el, true);\n        transition.enter(el);\n      } else {\n        transition.leave(el, () => {\n          setDisplay(el, false);\n        });\n      }\n    } else {\n      setDisplay(el, value);\n    }\n  },\n  beforeUnmount(el, { value }) {\n    setDisplay(el, value);\n  }\n};\nif (!!(process.env.NODE_ENV !== \"production\")) {\n  vShow.name = \"show\";\n}\nfunction setDisplay(el, value) {\n  el.style.display = value ? el[vShowOriginalDisplay] : \"none\";\n  el[vShowHidden] = !value;\n}\nfunction initVShowForSSR() {\n  vShow.getSSRProps = ({ value }) => {\n    if (!value) {\n      return { style: { display: \"none\" } };\n    }\n  };\n}\n\nconst CSS_VAR_TEXT = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"CSS_VAR_TEXT\" : \"\");\nfunction useCssVars(getter) {\n  const instance = getCurrentInstance();\n  if (!instance) {\n    !!(process.env.NODE_ENV !== \"production\") && warn(`useCssVars is called without current active component instance.`);\n    return;\n  }\n  const updateTeleports = instance.ut = (vars = getter(instance.proxy)) => {\n    Array.from(\n      document.querySelectorAll(`[data-v-owner=\"${instance.uid}\"]`)\n    ).forEach((node) => setVarsOnNode(node, vars));\n  };\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    instance.getCssVars = () => getter(instance.proxy);\n  }\n  const setVars = () => {\n    const vars = getter(instance.proxy);\n    setVarsOnVNode(instance.subTree, vars);\n    updateTeleports(vars);\n  };\n  onMounted(() => {\n    watchPostEffect(setVars);\n    const ob = new MutationObserver(setVars);\n    ob.observe(instance.subTree.el.parentNode, { childList: true });\n    onUnmounted(() => ob.disconnect());\n  });\n}\nfunction setVarsOnVNode(vnode, vars) {\n  if (vnode.shapeFlag & 128) {\n    const suspense = vnode.suspense;\n    vnode = suspense.activeBranch;\n    if (suspense.pendingBranch && !suspense.isHydrating) {\n      suspense.effects.push(() => {\n        setVarsOnVNode(suspense.activeBranch, vars);\n      });\n    }\n  }\n  while (vnode.component) {\n    vnode = vnode.component.subTree;\n  }\n  if (vnode.shapeFlag & 1 && vnode.el) {\n    setVarsOnNode(vnode.el, vars);\n  } else if (vnode.type === Fragment) {\n    vnode.children.forEach((c) => setVarsOnVNode(c, vars));\n  } else if (vnode.type === Static) {\n    let { el, anchor } = vnode;\n    while (el) {\n      setVarsOnNode(el, vars);\n      if (el === anchor)\n        break;\n      el = el.nextSibling;\n    }\n  }\n}\nfunction setVarsOnNode(el, vars) {\n  if (el.nodeType === 1) {\n    const style = el.style;\n    let cssText = \"\";\n    for (const key in vars) {\n      style.setProperty(`--${key}`, vars[key]);\n      cssText += `--${key}: ${vars[key]};`;\n    }\n    style[CSS_VAR_TEXT] = cssText;\n  }\n}\n\nconst displayRE = /(^|;)\\s*display\\s*:/;\nfunction patchStyle(el, prev, next) {\n  const style = el.style;\n  const isCssString = isString(next);\n  let hasControlledDisplay = false;\n  if (next && !isCssString) {\n    if (prev) {\n      if (!isString(prev)) {\n        for (const key in prev) {\n          if (next[key] == null) {\n            setStyle(style, key, \"\");\n          }\n        }\n      } else {\n        for (const prevStyle of prev.split(\";\")) {\n          const key = prevStyle.slice(0, prevStyle.indexOf(\":\")).trim();\n          if (next[key] == null) {\n            setStyle(style, key, \"\");\n          }\n        }\n      }\n    }\n    for (const key in next) {\n      if (key === \"display\") {\n        hasControlledDisplay = true;\n      }\n      setStyle(style, key, next[key]);\n    }\n  } else {\n    if (isCssString) {\n      if (prev !== next) {\n        const cssVarText = style[CSS_VAR_TEXT];\n        if (cssVarText) {\n          next += \";\" + cssVarText;\n        }\n        style.cssText = next;\n        hasControlledDisplay = displayRE.test(next);\n      }\n    } else if (prev) {\n      el.removeAttribute(\"style\");\n    }\n  }\n  if (vShowOriginalDisplay in el) {\n    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : \"\";\n    if (el[vShowHidden]) {\n      style.display = \"none\";\n    }\n  }\n}\nconst semicolonRE = /[^\\\\];\\s*$/;\nconst importantRE = /\\s*!important$/;\nfunction setStyle(style, name, val) {\n  if (isArray(val)) {\n    val.forEach((v) => setStyle(style, name, v));\n  } else {\n    if (val == null)\n      val = \"\";\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      if (semicolonRE.test(val)) {\n        warn(\n          `Unexpected semicolon at the end of '${name}' style value: '${val}'`\n        );\n      }\n    }\n    if (name.startsWith(\"--\")) {\n      style.setProperty(name, val);\n    } else {\n      const prefixed = autoPrefix(style, name);\n      if (importantRE.test(val)) {\n        style.setProperty(\n          hyphenate(prefixed),\n          val.replace(importantRE, \"\"),\n          \"important\"\n        );\n      } else {\n        style[prefixed] = val;\n      }\n    }\n  }\n}\nconst prefixes = [\"Webkit\", \"Moz\", \"ms\"];\nconst prefixCache = {};\nfunction autoPrefix(style, rawName) {\n  const cached = prefixCache[rawName];\n  if (cached) {\n    return cached;\n  }\n  let name = camelize(rawName);\n  if (name !== \"filter\" && name in style) {\n    return prefixCache[rawName] = name;\n  }\n  name = capitalize(name);\n  for (let i = 0; i < prefixes.length; i++) {\n    const prefixed = prefixes[i] + name;\n    if (prefixed in style) {\n      return prefixCache[rawName] = prefixed;\n    }\n  }\n  return rawName;\n}\n\nconst xlinkNS = \"http://www.w3.org/1999/xlink\";\nfunction patchAttr(el, key, value, isSVG, instance) {\n  if (isSVG && key.startsWith(\"xlink:\")) {\n    if (value == null) {\n      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    const isBoolean = isSpecialBooleanAttr(key);\n    if (value == null || isBoolean && !includeBooleanAttr(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, isBoolean ? \"\" : value);\n    }\n  }\n}\n\nfunction patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {\n  if (key === \"innerHTML\" || key === \"textContent\") {\n    if (prevChildren) {\n      unmountChildren(prevChildren, parentComponent, parentSuspense);\n    }\n    el[key] = value == null ? \"\" : value;\n    return;\n  }\n  const tag = el.tagName;\n  if (key === \"value\" && tag !== \"PROGRESS\" && // custom elements may use _value internally\n  !tag.includes(\"-\")) {\n    const oldValue = tag === \"OPTION\" ? el.getAttribute(\"value\") || \"\" : el.value;\n    const newValue = value == null ? \"\" : value;\n    if (oldValue !== newValue || !(\"_value\" in el)) {\n      el.value = newValue;\n    }\n    if (value == null) {\n      el.removeAttribute(key);\n    }\n    el._value = value;\n    return;\n  }\n  let needRemove = false;\n  if (value === \"\" || value == null) {\n    const type = typeof el[key];\n    if (type === \"boolean\") {\n      value = includeBooleanAttr(value);\n    } else if (value == null && type === \"string\") {\n      value = \"\";\n      needRemove = true;\n    } else if (type === \"number\") {\n      value = 0;\n      needRemove = true;\n    }\n  }\n  try {\n    el[key] = value;\n  } catch (e) {\n    if (!!(process.env.NODE_ENV !== \"production\") && !needRemove) {\n      warn(\n        `Failed setting prop \"${key}\" on <${tag.toLowerCase()}>: value ${value} is invalid.`,\n        e\n      );\n    }\n  }\n  needRemove && el.removeAttribute(key);\n}\n\nfunction addEventListener(el, event, handler, options) {\n  el.addEventListener(event, handler, options);\n}\nfunction removeEventListener(el, event, handler, options) {\n  el.removeEventListener(event, handler, options);\n}\nconst veiKey = Symbol(\"_vei\");\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\n  const invokers = el[veiKey] || (el[veiKey] = {});\n  const existingInvoker = invokers[rawName];\n  if (nextValue && existingInvoker) {\n    existingInvoker.value = !!(process.env.NODE_ENV !== \"production\") ? sanitizeEventValue(nextValue, rawName) : nextValue;\n  } else {\n    const [name, options] = parseName(rawName);\n    if (nextValue) {\n      const invoker = invokers[rawName] = createInvoker(\n        !!(process.env.NODE_ENV !== \"production\") ? sanitizeEventValue(nextValue, rawName) : nextValue,\n        instance\n      );\n      addEventListener(el, name, invoker, options);\n    } else if (existingInvoker) {\n      removeEventListener(el, name, existingInvoker, options);\n      invokers[rawName] = void 0;\n    }\n  }\n}\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\nfunction parseName(name) {\n  let options;\n  if (optionsModifierRE.test(name)) {\n    options = {};\n    let m;\n    while (m = name.match(optionsModifierRE)) {\n      name = name.slice(0, name.length - m[0].length);\n      options[m[0].toLowerCase()] = true;\n    }\n  }\n  const event = name[2] === \":\" ? name.slice(3) : hyphenate(name.slice(2));\n  return [event, options];\n}\nlet cachedNow = 0;\nconst p = /* @__PURE__ */ Promise.resolve();\nconst getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());\nfunction createInvoker(initialValue, instance) {\n  const invoker = (e) => {\n    if (!e._vts) {\n      e._vts = Date.now();\n    } else if (e._vts <= invoker.attached) {\n      return;\n    }\n    callWithAsyncErrorHandling(\n      patchStopImmediatePropagation(e, invoker.value),\n      instance,\n      5,\n      [e]\n    );\n  };\n  invoker.value = initialValue;\n  invoker.attached = getNow();\n  return invoker;\n}\nfunction sanitizeEventValue(value, propName) {\n  if (isFunction(value) || isArray(value)) {\n    return value;\n  }\n  warn(\n    `Wrong type passed as event handler to ${propName} - did you forget @ or : in front of your prop?\nExpected function or array of functions, received type ${typeof value}.`\n  );\n  return NOOP;\n}\nfunction patchStopImmediatePropagation(e, value) {\n  if (isArray(value)) {\n    const originalStop = e.stopImmediatePropagation;\n    e.stopImmediatePropagation = () => {\n      originalStop.call(e);\n      e._stopped = true;\n    };\n    return value.map(\n      (fn) => (e2) => !e2._stopped && fn && fn(e2)\n    );\n  } else {\n    return value;\n  }\n}\n\nconst isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter\nkey.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;\nconst patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\n  const isSVG = namespace === \"svg\";\n  if (key === \"class\") {\n    patchClass(el, nextValue, isSVG);\n  } else if (key === \"style\") {\n    patchStyle(el, prevValue, nextValue);\n  } else if (isOn(key)) {\n    if (!isModelListener(key)) {\n      patchEvent(el, key, prevValue, nextValue, parentComponent);\n    }\n  } else if (key[0] === \".\" ? (key = key.slice(1), true) : key[0] === \"^\" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {\n    patchDOMProp(\n      el,\n      key,\n      nextValue,\n      prevChildren,\n      parentComponent,\n      parentSuspense,\n      unmountChildren\n    );\n  } else {\n    if (key === \"true-value\") {\n      el._trueValue = nextValue;\n    } else if (key === \"false-value\") {\n      el._falseValue = nextValue;\n    }\n    patchAttr(el, key, nextValue, isSVG);\n  }\n};\nfunction shouldSetAsProp(el, key, value, isSVG) {\n  if (isSVG) {\n    if (key === \"innerHTML\" || key === \"textContent\") {\n      return true;\n    }\n    if (key in el && isNativeOn(key) && isFunction(value)) {\n      return true;\n    }\n    return false;\n  }\n  if (key === \"spellcheck\" || key === \"draggable\" || key === \"translate\") {\n    return false;\n  }\n  if (key === \"form\") {\n    return false;\n  }\n  if (key === \"list\" && el.tagName === \"INPUT\") {\n    return false;\n  }\n  if (key === \"type\" && el.tagName === \"TEXTAREA\") {\n    return false;\n  }\n  if (key === \"width\" || key === \"height\") {\n    const tag = el.tagName;\n    if (tag === \"IMG\" || tag === \"VIDEO\" || tag === \"CANVAS\" || tag === \"SOURCE\") {\n      return false;\n    }\n  }\n  if (isNativeOn(key) && isString(value)) {\n    return false;\n  }\n  return key in el;\n}\n\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction defineCustomElement(options, hydrate2) {\n  const Comp = defineComponent(options);\n  class VueCustomElement extends VueElement {\n    constructor(initialProps) {\n      super(Comp, initialProps, hydrate2);\n    }\n  }\n  VueCustomElement.def = Comp;\n  return VueCustomElement;\n}\n/*! #__NO_SIDE_EFFECTS__ */\nconst defineSSRCustomElement = /* @__NO_SIDE_EFFECTS__ */ (options) => {\n  return /* @__PURE__ */ defineCustomElement(options, hydrate);\n};\nconst BaseClass = typeof HTMLElement !== \"undefined\" ? HTMLElement : class {\n};\nclass VueElement extends BaseClass {\n  constructor(_def, _props = {}, hydrate2) {\n    super();\n    this._def = _def;\n    this._props = _props;\n    /**\n     * @internal\n     */\n    this._instance = null;\n    this._connected = false;\n    this._resolved = false;\n    this._numberProps = null;\n    this._ob = null;\n    if (this.shadowRoot && hydrate2) {\n      hydrate2(this._createVNode(), this.shadowRoot);\n    } else {\n      if (!!(process.env.NODE_ENV !== \"production\") && this.shadowRoot) {\n        warn(\n          `Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \\`defineSSRCustomElement\\`.`\n        );\n      }\n      this.attachShadow({ mode: \"open\" });\n      if (!this._def.__asyncLoader) {\n        this._resolveProps(this._def);\n      }\n    }\n  }\n  connectedCallback() {\n    this._connected = true;\n    if (!this._instance) {\n      if (this._resolved) {\n        this._update();\n      } else {\n        this._resolveDef();\n      }\n    }\n  }\n  disconnectedCallback() {\n    this._connected = false;\n    if (this._ob) {\n      this._ob.disconnect();\n      this._ob = null;\n    }\n    nextTick(() => {\n      if (!this._connected) {\n        render(null, this.shadowRoot);\n        this._instance = null;\n      }\n    });\n  }\n  /**\n   * resolve inner component definition (handle possible async component)\n   */\n  _resolveDef() {\n    this._resolved = true;\n    for (let i = 0; i < this.attributes.length; i++) {\n      this._setAttr(this.attributes[i].name);\n    }\n    this._ob = new MutationObserver((mutations) => {\n      for (const m of mutations) {\n        this._setAttr(m.attributeName);\n      }\n    });\n    this._ob.observe(this, { attributes: true });\n    const resolve = (def, isAsync = false) => {\n      const { props, styles } = def;\n      let numberProps;\n      if (props && !isArray(props)) {\n        for (const key in props) {\n          const opt = props[key];\n          if (opt === Number || opt && opt.type === Number) {\n            if (key in this._props) {\n              this._props[key] = toNumber(this._props[key]);\n            }\n            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[camelize$1(key)] = true;\n          }\n        }\n      }\n      this._numberProps = numberProps;\n      if (isAsync) {\n        this._resolveProps(def);\n      }\n      this._applyStyles(styles);\n      this._update();\n    };\n    const asyncDef = this._def.__asyncLoader;\n    if (asyncDef) {\n      asyncDef().then((def) => resolve(def, true));\n    } else {\n      resolve(this._def);\n    }\n  }\n  _resolveProps(def) {\n    const { props } = def;\n    const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});\n    for (const key of Object.keys(this)) {\n      if (key[0] !== \"_\" && declaredPropKeys.includes(key)) {\n        this._setProp(key, this[key], true, false);\n      }\n    }\n    for (const key of declaredPropKeys.map(camelize$1)) {\n      Object.defineProperty(this, key, {\n        get() {\n          return this._getProp(key);\n        },\n        set(val) {\n          this._setProp(key, val);\n        }\n      });\n    }\n  }\n  _setAttr(key) {\n    let value = this.hasAttribute(key) ? this.getAttribute(key) : void 0;\n    const camelKey = camelize$1(key);\n    if (this._numberProps && this._numberProps[camelKey]) {\n      value = toNumber(value);\n    }\n    this._setProp(camelKey, value, false);\n  }\n  /**\n   * @internal\n   */\n  _getProp(key) {\n    return this._props[key];\n  }\n  /**\n   * @internal\n   */\n  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {\n    if (val !== this._props[key]) {\n      this._props[key] = val;\n      if (shouldUpdate && this._instance) {\n        this._update();\n      }\n      if (shouldReflect) {\n        if (val === true) {\n          this.setAttribute(hyphenate(key), \"\");\n        } else if (typeof val === \"string\" || typeof val === \"number\") {\n          this.setAttribute(hyphenate(key), val + \"\");\n        } else if (!val) {\n          this.removeAttribute(hyphenate(key));\n        }\n      }\n    }\n  }\n  _update() {\n    render(this._createVNode(), this.shadowRoot);\n  }\n  _createVNode() {\n    const vnode = createVNode(this._def, extend({}, this._props));\n    if (!this._instance) {\n      vnode.ce = (instance) => {\n        this._instance = instance;\n        instance.isCE = true;\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          instance.ceReload = (newStyles) => {\n            if (this._styles) {\n              this._styles.forEach((s) => this.shadowRoot.removeChild(s));\n              this._styles.length = 0;\n            }\n            this._applyStyles(newStyles);\n            this._instance = null;\n            this._update();\n          };\n        }\n        const dispatch = (event, args) => {\n          this.dispatchEvent(\n            new CustomEvent(event, {\n              detail: args\n            })\n          );\n        };\n        instance.emit = (event, ...args) => {\n          dispatch(event, args);\n          if (hyphenate(event) !== event) {\n            dispatch(hyphenate(event), args);\n          }\n        };\n        let parent = this;\n        while (parent = parent && (parent.parentNode || parent.host)) {\n          if (parent instanceof VueElement) {\n            instance.parent = parent._instance;\n            instance.provides = parent._instance.provides;\n            break;\n          }\n        }\n      };\n    }\n    return vnode;\n  }\n  _applyStyles(styles) {\n    if (styles) {\n      styles.forEach((css) => {\n        const s = document.createElement(\"style\");\n        s.textContent = css;\n        this.shadowRoot.appendChild(s);\n        if (!!(process.env.NODE_ENV !== \"production\")) {\n          (this._styles || (this._styles = [])).push(s);\n        }\n      });\n    }\n  }\n}\n\nfunction useCssModule(name = \"$style\") {\n  {\n    const instance = getCurrentInstance();\n    if (!instance) {\n      !!(process.env.NODE_ENV !== \"production\") && warn(`useCssModule must be called inside setup()`);\n      return EMPTY_OBJ;\n    }\n    const modules = instance.type.__cssModules;\n    if (!modules) {\n      !!(process.env.NODE_ENV !== \"production\") && warn(`Current instance does not have CSS modules injected.`);\n      return EMPTY_OBJ;\n    }\n    const mod = modules[name];\n    if (!mod) {\n      !!(process.env.NODE_ENV !== \"production\") && warn(`Current instance does not have CSS module named \"${name}\".`);\n      return EMPTY_OBJ;\n    }\n    return mod;\n  }\n}\n\nconst positionMap = /* @__PURE__ */ new WeakMap();\nconst newPositionMap = /* @__PURE__ */ new WeakMap();\nconst moveCbKey = Symbol(\"_moveCb\");\nconst enterCbKey = Symbol(\"_enterCb\");\nconst TransitionGroupImpl = {\n  name: \"TransitionGroup\",\n  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {\n    tag: String,\n    moveClass: String\n  }),\n  setup(props, { slots }) {\n    const instance = getCurrentInstance();\n    const state = useTransitionState();\n    let prevChildren;\n    let children;\n    onUpdated(() => {\n      if (!prevChildren.length) {\n        return;\n      }\n      const moveClass = props.moveClass || `${props.name || \"v\"}-move`;\n      if (!hasCSSTransform(\n        prevChildren[0].el,\n        instance.vnode.el,\n        moveClass\n      )) {\n        return;\n      }\n      prevChildren.forEach(callPendingCbs);\n      prevChildren.forEach(recordPosition);\n      const movedChildren = prevChildren.filter(applyTranslation);\n      forceReflow();\n      movedChildren.forEach((c) => {\n        const el = c.el;\n        const style = el.style;\n        addTransitionClass(el, moveClass);\n        style.transform = style.webkitTransform = style.transitionDuration = \"\";\n        const cb = el[moveCbKey] = (e) => {\n          if (e && e.target !== el) {\n            return;\n          }\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(\"transitionend\", cb);\n            el[moveCbKey] = null;\n            removeTransitionClass(el, moveClass);\n          }\n        };\n        el.addEventListener(\"transitionend\", cb);\n      });\n    });\n    return () => {\n      const rawProps = toRaw(props);\n      const cssTransitionProps = resolveTransitionProps(rawProps);\n      let tag = rawProps.tag || Fragment;\n      prevChildren = [];\n      if (children) {\n        for (let i = 0; i < children.length; i++) {\n          const child = children[i];\n          if (child.el && child.el instanceof Element) {\n            prevChildren.push(child);\n            setTransitionHooks(\n              child,\n              resolveTransitionHooks(\n                child,\n                cssTransitionProps,\n                state,\n                instance\n              )\n            );\n            positionMap.set(\n              child,\n              child.el.getBoundingClientRect()\n            );\n          }\n        }\n      }\n      children = slots.default ? getTransitionRawChildren(slots.default()) : [];\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        if (child.key != null) {\n          setTransitionHooks(\n            child,\n            resolveTransitionHooks(child, cssTransitionProps, state, instance)\n          );\n        } else if (!!(process.env.NODE_ENV !== \"production\")) {\n          warn(`<TransitionGroup> children must be keyed.`);\n        }\n      }\n      return createVNode(tag, null, children);\n    };\n  }\n};\nconst removeMode = (props) => delete props.mode;\n/* @__PURE__ */ removeMode(TransitionGroupImpl.props);\nconst TransitionGroup = TransitionGroupImpl;\nfunction callPendingCbs(c) {\n  const el = c.el;\n  if (el[moveCbKey]) {\n    el[moveCbKey]();\n  }\n  if (el[enterCbKey]) {\n    el[enterCbKey]();\n  }\n}\nfunction recordPosition(c) {\n  newPositionMap.set(c, c.el.getBoundingClientRect());\n}\nfunction applyTranslation(c) {\n  const oldPos = positionMap.get(c);\n  const newPos = newPositionMap.get(c);\n  const dx = oldPos.left - newPos.left;\n  const dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    const s = c.el.style;\n    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n    s.transitionDuration = \"0s\";\n    return c;\n  }\n}\nfunction hasCSSTransform(el, root, moveClass) {\n  const clone = el.cloneNode();\n  const _vtc = el[vtcKey];\n  if (_vtc) {\n    _vtc.forEach((cls) => {\n      cls.split(/\\s+/).forEach((c) => c && clone.classList.remove(c));\n    });\n  }\n  moveClass.split(/\\s+/).forEach((c) => c && clone.classList.add(c));\n  clone.style.display = \"none\";\n  const container = root.nodeType === 1 ? root : root.parentNode;\n  container.appendChild(clone);\n  const { hasTransform } = getTransitionInfo(clone);\n  container.removeChild(clone);\n  return hasTransform;\n}\n\nconst getModelAssigner = (vnode) => {\n  const fn = vnode.props[\"onUpdate:modelValue\"] || false;\n  return isArray(fn) ? (value) => invokeArrayFns(fn, value) : fn;\n};\nfunction onCompositionStart(e) {\n  e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n  const target = e.target;\n  if (target.composing) {\n    target.composing = false;\n    target.dispatchEvent(new Event(\"input\"));\n  }\n}\nconst assignKey = Symbol(\"_assign\");\nconst vModelText = {\n  created(el, { modifiers: { lazy, trim, number } }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    const castToNumber = number || vnode.props && vnode.props.type === \"number\";\n    addEventListener(el, lazy ? \"change\" : \"input\", (e) => {\n      if (e.target.composing)\n        return;\n      let domValue = el.value;\n      if (trim) {\n        domValue = domValue.trim();\n      }\n      if (castToNumber) {\n        domValue = looseToNumber(domValue);\n      }\n      el[assignKey](domValue);\n    });\n    if (trim) {\n      addEventListener(el, \"change\", () => {\n        el.value = el.value.trim();\n      });\n    }\n    if (!lazy) {\n      addEventListener(el, \"compositionstart\", onCompositionStart);\n      addEventListener(el, \"compositionend\", onCompositionEnd);\n      addEventListener(el, \"change\", onCompositionEnd);\n    }\n  },\n  // set value on mounted so it's after min/max for type=\"range\"\n  mounted(el, { value }) {\n    el.value = value == null ? \"\" : value;\n  },\n  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    if (el.composing)\n      return;\n    const elValue = (number || el.type === \"number\") && !/^0\\d/.test(el.value) ? looseToNumber(el.value) : el.value;\n    const newValue = value == null ? \"\" : value;\n    if (elValue === newValue) {\n      return;\n    }\n    if (document.activeElement === el && el.type !== \"range\") {\n      if (lazy) {\n        return;\n      }\n      if (trim && el.value.trim() === newValue) {\n        return;\n      }\n    }\n    el.value = newValue;\n  }\n};\nconst vModelCheckbox = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: true,\n  created(el, _, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    addEventListener(el, \"change\", () => {\n      const modelValue = el._modelValue;\n      const elementValue = getValue(el);\n      const checked = el.checked;\n      const assign = el[assignKey];\n      if (isArray(modelValue)) {\n        const index = looseIndexOf(modelValue, elementValue);\n        const found = index !== -1;\n        if (checked && !found) {\n          assign(modelValue.concat(elementValue));\n        } else if (!checked && found) {\n          const filtered = [...modelValue];\n          filtered.splice(index, 1);\n          assign(filtered);\n        }\n      } else if (isSet(modelValue)) {\n        const cloned = new Set(modelValue);\n        if (checked) {\n          cloned.add(elementValue);\n        } else {\n          cloned.delete(elementValue);\n        }\n        assign(cloned);\n      } else {\n        assign(getCheckboxValue(el, checked));\n      }\n    });\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: setChecked,\n  beforeUpdate(el, binding, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    setChecked(el, binding, vnode);\n  }\n};\nfunction setChecked(el, { value, oldValue }, vnode) {\n  el._modelValue = value;\n  if (isArray(value)) {\n    el.checked = looseIndexOf(value, vnode.props.value) > -1;\n  } else if (isSet(value)) {\n    el.checked = value.has(vnode.props.value);\n  } else if (value !== oldValue) {\n    el.checked = looseEqual(value, getCheckboxValue(el, true));\n  }\n}\nconst vModelRadio = {\n  created(el, { value }, vnode) {\n    el.checked = looseEqual(value, vnode.props.value);\n    el[assignKey] = getModelAssigner(vnode);\n    addEventListener(el, \"change\", () => {\n      el[assignKey](getValue(el));\n    });\n  },\n  beforeUpdate(el, { value, oldValue }, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n    if (value !== oldValue) {\n      el.checked = looseEqual(value, vnode.props.value);\n    }\n  }\n};\nconst vModelSelect = {\n  // <select multiple> value need to be deep traversed\n  deep: true,\n  created(el, { value, modifiers: { number } }, vnode) {\n    const isSetModel = isSet(value);\n    addEventListener(el, \"change\", () => {\n      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map(\n        (o) => number ? looseToNumber(getValue(o)) : getValue(o)\n      );\n      el[assignKey](\n        el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]\n      );\n      el._assigning = true;\n      nextTick(() => {\n        el._assigning = false;\n      });\n    });\n    el[assignKey] = getModelAssigner(vnode);\n  },\n  // set value in mounted & updated because <select> relies on its children\n  // <option>s.\n  mounted(el, { value, modifiers: { number } }) {\n    setSelected(el, value);\n  },\n  beforeUpdate(el, _binding, vnode) {\n    el[assignKey] = getModelAssigner(vnode);\n  },\n  updated(el, { value, modifiers: { number } }) {\n    if (!el._assigning) {\n      setSelected(el, value);\n    }\n  }\n};\nfunction setSelected(el, value, number) {\n  const isMultiple = el.multiple;\n  const isArrayValue = isArray(value);\n  if (isMultiple && !isArrayValue && !isSet(value)) {\n    !!(process.env.NODE_ENV !== \"production\") && warn(\n      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value).slice(8, -1)}.`\n    );\n    return;\n  }\n  for (let i = 0, l = el.options.length; i < l; i++) {\n    const option = el.options[i];\n    const optionValue = getValue(option);\n    if (isMultiple) {\n      if (isArrayValue) {\n        const optionType = typeof optionValue;\n        if (optionType === \"string\" || optionType === \"number\") {\n          option.selected = value.some((v) => String(v) === String(optionValue));\n        } else {\n          option.selected = looseIndexOf(value, optionValue) > -1;\n        }\n      } else {\n        option.selected = value.has(optionValue);\n      }\n    } else if (looseEqual(getValue(option), value)) {\n      if (el.selectedIndex !== i)\n        el.selectedIndex = i;\n      return;\n    }\n  }\n  if (!isMultiple && el.selectedIndex !== -1) {\n    el.selectedIndex = -1;\n  }\n}\nfunction getValue(el) {\n  return \"_value\" in el ? el._value : el.value;\n}\nfunction getCheckboxValue(el, checked) {\n  const key = checked ? \"_trueValue\" : \"_falseValue\";\n  return key in el ? el[key] : checked;\n}\nconst vModelDynamic = {\n  created(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, \"created\");\n  },\n  mounted(el, binding, vnode) {\n    callModelHook(el, binding, vnode, null, \"mounted\");\n  },\n  beforeUpdate(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, \"beforeUpdate\");\n  },\n  updated(el, binding, vnode, prevVNode) {\n    callModelHook(el, binding, vnode, prevVNode, \"updated\");\n  }\n};\nfunction resolveDynamicModel(tagName, type) {\n  switch (tagName) {\n    case \"SELECT\":\n      return vModelSelect;\n    case \"TEXTAREA\":\n      return vModelText;\n    default:\n      switch (type) {\n        case \"checkbox\":\n          return vModelCheckbox;\n        case \"radio\":\n          return vModelRadio;\n        default:\n          return vModelText;\n      }\n  }\n}\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\n  const modelToUse = resolveDynamicModel(\n    el.tagName,\n    vnode.props && vnode.props.type\n  );\n  const fn = modelToUse[hook];\n  fn && fn(el, binding, vnode, prevVNode);\n}\nfunction initVModelForSSR() {\n  vModelText.getSSRProps = ({ value }) => ({ value });\n  vModelRadio.getSSRProps = ({ value }, vnode) => {\n    if (vnode.props && looseEqual(vnode.props.value, value)) {\n      return { checked: true };\n    }\n  };\n  vModelCheckbox.getSSRProps = ({ value }, vnode) => {\n    if (isArray(value)) {\n      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {\n        return { checked: true };\n      }\n    } else if (isSet(value)) {\n      if (vnode.props && value.has(vnode.props.value)) {\n        return { checked: true };\n      }\n    } else if (value) {\n      return { checked: true };\n    }\n  };\n  vModelDynamic.getSSRProps = (binding, vnode) => {\n    if (typeof vnode.type !== \"string\") {\n      return;\n    }\n    const modelToUse = resolveDynamicModel(\n      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n      vnode.type.toUpperCase(),\n      vnode.props && vnode.props.type\n    );\n    if (modelToUse.getSSRProps) {\n      return modelToUse.getSSRProps(binding, vnode);\n    }\n  };\n}\n\nconst systemModifiers = [\"ctrl\", \"shift\", \"alt\", \"meta\"];\nconst modifierGuards = {\n  stop: (e) => e.stopPropagation(),\n  prevent: (e) => e.preventDefault(),\n  self: (e) => e.target !== e.currentTarget,\n  ctrl: (e) => !e.ctrlKey,\n  shift: (e) => !e.shiftKey,\n  alt: (e) => !e.altKey,\n  meta: (e) => !e.metaKey,\n  left: (e) => \"button\" in e && e.button !== 0,\n  middle: (e) => \"button\" in e && e.button !== 1,\n  right: (e) => \"button\" in e && e.button !== 2,\n  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))\n};\nconst withModifiers = (fn, modifiers) => {\n  const cache = fn._withMods || (fn._withMods = {});\n  const cacheKey = modifiers.join(\".\");\n  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {\n    for (let i = 0; i < modifiers.length; i++) {\n      const guard = modifierGuards[modifiers[i]];\n      if (guard && guard(event, modifiers))\n        return;\n    }\n    return fn(event, ...args);\n  });\n};\nconst keyNames = {\n  esc: \"escape\",\n  space: \" \",\n  up: \"arrow-up\",\n  left: \"arrow-left\",\n  right: \"arrow-right\",\n  down: \"arrow-down\",\n  delete: \"backspace\"\n};\nconst withKeys = (fn, modifiers) => {\n  const cache = fn._withKeys || (fn._withKeys = {});\n  const cacheKey = modifiers.join(\".\");\n  return cache[cacheKey] || (cache[cacheKey] = (event) => {\n    if (!(\"key\" in event)) {\n      return;\n    }\n    const eventKey = hyphenate(event.key);\n    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {\n      return fn(event);\n    }\n  });\n};\n\nconst rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);\nlet renderer;\nlet enabledHydration = false;\nfunction ensureRenderer() {\n  return renderer || (renderer = createRenderer(rendererOptions));\n}\nfunction ensureHydrationRenderer() {\n  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);\n  enabledHydration = true;\n  return renderer;\n}\nconst render = (...args) => {\n  ensureRenderer().render(...args);\n};\nconst hydrate = (...args) => {\n  ensureHydrationRenderer().hydrate(...args);\n};\nconst createApp = (...args) => {\n  const app = ensureRenderer().createApp(...args);\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    injectNativeTagCheck(app);\n    injectCompilerOptionsCheck(app);\n  }\n  const { mount } = app;\n  app.mount = (containerOrSelector) => {\n    const container = normalizeContainer(containerOrSelector);\n    if (!container)\n      return;\n    const component = app._component;\n    if (!isFunction(component) && !component.render && !component.template) {\n      component.template = container.innerHTML;\n    }\n    container.innerHTML = \"\";\n    const proxy = mount(container, false, resolveRootNamespace(container));\n    if (container instanceof Element) {\n      container.removeAttribute(\"v-cloak\");\n      container.setAttribute(\"data-v-app\", \"\");\n    }\n    return proxy;\n  };\n  return app;\n};\nconst createSSRApp = (...args) => {\n  const app = ensureHydrationRenderer().createApp(...args);\n  if (!!(process.env.NODE_ENV !== \"production\")) {\n    injectNativeTagCheck(app);\n    injectCompilerOptionsCheck(app);\n  }\n  const { mount } = app;\n  app.mount = (containerOrSelector) => {\n    const container = normalizeContainer(containerOrSelector);\n    if (container) {\n      return mount(container, true, resolveRootNamespace(container));\n    }\n  };\n  return app;\n};\nfunction resolveRootNamespace(container) {\n  if (container instanceof SVGElement) {\n    return \"svg\";\n  }\n  if (typeof MathMLElement === \"function\" && container instanceof MathMLElement) {\n    return \"mathml\";\n  }\n}\nfunction injectNativeTagCheck(app) {\n  Object.defineProperty(app.config, \"isNativeTag\", {\n    value: (tag) => isHTMLTag(tag) || isSVGTag(tag) || isMathMLTag(tag),\n    writable: false\n  });\n}\nfunction injectCompilerOptionsCheck(app) {\n  if (isRuntimeOnly()) {\n    const isCustomElement = app.config.isCustomElement;\n    Object.defineProperty(app.config, \"isCustomElement\", {\n      get() {\n        return isCustomElement;\n      },\n      set() {\n        warn(\n          `The \\`isCustomElement\\` config option is deprecated. Use \\`compilerOptions.isCustomElement\\` instead.`\n        );\n      }\n    });\n    const compilerOptions = app.config.compilerOptions;\n    const msg = `The \\`compilerOptions\\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka \"full build\"). Since you are using the runtime-only build, \\`compilerOptions\\` must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\n- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc`;\n    Object.defineProperty(app.config, \"compilerOptions\", {\n      get() {\n        warn(msg);\n        return compilerOptions;\n      },\n      set() {\n        warn(msg);\n      }\n    });\n  }\n}\nfunction normalizeContainer(container) {\n  if (isString(container)) {\n    const res = document.querySelector(container);\n    if (!!(process.env.NODE_ENV !== \"production\") && !res) {\n      warn(\n        `Failed to mount app: mount target selector \"${container}\" returned null.`\n      );\n    }\n    return res;\n  }\n  if (!!(process.env.NODE_ENV !== \"production\") && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === \"closed\") {\n    warn(\n      `mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`\n    );\n  }\n  return container;\n}\nlet ssrDirectiveInitialized = false;\nconst initDirectivesForSSR = () => {\n  if (!ssrDirectiveInitialized) {\n    ssrDirectiveInitialized = true;\n    initVModelForSSR();\n    initVShowForSSR();\n  }\n} ;\n\nexport { Transition, TransitionGroup, VueElement, createApp, createSSRApp, defineCustomElement, defineSSRCustomElement, hydrate, initDirectivesForSSR, render, useCssModule, useCssVars, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, vShow, withKeys, withModifiers };\n","/**\n* @vue/shared v3.4.27\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction makeMap(str, expectsLowerCase) {\n  const set = new Set(str.split(\",\"));\n  return expectsLowerCase ? (val) => set.has(val.toLowerCase()) : (val) => set.has(val);\n}\n\nconst EMPTY_OBJ = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze({}) : {};\nconst EMPTY_ARR = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze([]) : [];\nconst NOOP = () => {\n};\nconst NO = () => false;\nconst isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter\n(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);\nconst isModelListener = (key) => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isDate = (val) => toTypeString(val) === \"[object Date]\";\nconst isRegExp = (val) => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n);\nconst isBuiltInDirective = /* @__PURE__ */ makeMap(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n);\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(\n  (str) => str.replace(hyphenateRE, \"-$1\").toLowerCase()\n);\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst toHandlerKey = cacheStringFunction((str) => {\n  const s = str ? `on${capitalize(str)}` : ``;\n  return s;\n});\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg);\n  }\n};\nconst def = (obj, key, value, writable = false) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    writable,\n    value\n  });\n};\nconst looseToNumber = (val) => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = (val) => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\n\nconst PatchFlags = {\n  \"TEXT\": 1,\n  \"1\": \"TEXT\",\n  \"CLASS\": 2,\n  \"2\": \"CLASS\",\n  \"STYLE\": 4,\n  \"4\": \"STYLE\",\n  \"PROPS\": 8,\n  \"8\": \"PROPS\",\n  \"FULL_PROPS\": 16,\n  \"16\": \"FULL_PROPS\",\n  \"NEED_HYDRATION\": 32,\n  \"32\": \"NEED_HYDRATION\",\n  \"STABLE_FRAGMENT\": 64,\n  \"64\": \"STABLE_FRAGMENT\",\n  \"KEYED_FRAGMENT\": 128,\n  \"128\": \"KEYED_FRAGMENT\",\n  \"UNKEYED_FRAGMENT\": 256,\n  \"256\": \"UNKEYED_FRAGMENT\",\n  \"NEED_PATCH\": 512,\n  \"512\": \"NEED_PATCH\",\n  \"DYNAMIC_SLOTS\": 1024,\n  \"1024\": \"DYNAMIC_SLOTS\",\n  \"DEV_ROOT_FRAGMENT\": 2048,\n  \"2048\": \"DEV_ROOT_FRAGMENT\",\n  \"HOISTED\": -1,\n  \"-1\": \"HOISTED\",\n  \"BAIL\": -2,\n  \"-2\": \"BAIL\"\n};\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `NEED_HYDRATION`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `HOISTED`,\n  [-2]: `BAIL`\n};\n\nconst ShapeFlags = {\n  \"ELEMENT\": 1,\n  \"1\": \"ELEMENT\",\n  \"FUNCTIONAL_COMPONENT\": 2,\n  \"2\": \"FUNCTIONAL_COMPONENT\",\n  \"STATEFUL_COMPONENT\": 4,\n  \"4\": \"STATEFUL_COMPONENT\",\n  \"TEXT_CHILDREN\": 8,\n  \"8\": \"TEXT_CHILDREN\",\n  \"ARRAY_CHILDREN\": 16,\n  \"16\": \"ARRAY_CHILDREN\",\n  \"SLOTS_CHILDREN\": 32,\n  \"32\": \"SLOTS_CHILDREN\",\n  \"TELEPORT\": 64,\n  \"64\": \"TELEPORT\",\n  \"SUSPENSE\": 128,\n  \"128\": \"SUSPENSE\",\n  \"COMPONENT_SHOULD_KEEP_ALIVE\": 256,\n  \"256\": \"COMPONENT_SHOULD_KEEP_ALIVE\",\n  \"COMPONENT_KEPT_ALIVE\": 512,\n  \"512\": \"COMPONENT_KEPT_ALIVE\",\n  \"COMPONENT\": 6,\n  \"6\": \"COMPONENT\"\n};\n\nconst SlotFlags = {\n  \"STABLE\": 1,\n  \"1\": \"STABLE\",\n  \"DYNAMIC\": 2,\n  \"2\": \"DYNAMIC\",\n  \"FORWARDED\": 3,\n  \"3\": \"FORWARDED\"\n};\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\n\nconst GLOBALS_ALLOWED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error\";\nconst isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);\nconst isGloballyWhitelisted = isGloballyAllowed;\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length)\n          continue;\n        const line = j + 1;\n        res.push(\n          `${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`\n        );\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          );\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value) || isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach((item) => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  let ret = \"\";\n  if (!styles || isString(styles)) {\n    return ret;\n  }\n  for (const key in styles) {\n    const value = styles[key];\n    if (isString(value) || typeof value === \"number\") {\n      const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props)\n    return null;\n  let { class: klass, style } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst MATH_TAGS = \"annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\nconst isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);\nconst isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */ makeMap(\n  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`\n);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`\n);\nconst isKnownSvgAttr = /* @__PURE__ */ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n);\nfunction isRenderableAttrValue(value) {\n  if (value == null) {\n    return false;\n  }\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"boolean\";\n}\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\n\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length)\n    return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b)\n    return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex((item) => looseEqual(item, val));\n}\n\nconst toDisplayString = (val) => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (val && val.__v_isRef) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce(\n        (entries, [key, val2], i) => {\n          entries[stringifySymbol(key, i) + \" =>\"] = val2;\n          return entries;\n        },\n        {}\n      )\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))\n    };\n  } else if (isSymbol(val)) {\n    return stringifySymbol(val);\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst stringifySymbol = (v, i = \"\") => {\n  var _a;\n  return (\n    // Symbol.description in es2019+ so we need to cast here to pass\n    // the lib: es2016 check\n    isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v\n  );\n};\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, PatchFlags, ShapeFlags, SlotFlags, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, genPropsAccessExp, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyAllowed, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownSvgAttr, isMap, isMathMLTag, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isRenderableAttrValue, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.default = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n","'use strict';\nvar isCallable = require('../internals/is-callable');\nvar tryToString = require('../internals/try-to-string');\n\nvar $TypeError = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nmodule.exports = function (argument) {\n  if (isCallable(argument)) return argument;\n  throw new $TypeError(tryToString(argument) + ' is not a function');\n};\n","'use strict';\nvar isObject = require('../internals/is-object');\n\nvar $String = String;\nvar $TypeError = TypeError;\n\n// `Assert: Type(argument) is Object`\nmodule.exports = function (argument) {\n  if (isObject(argument)) return argument;\n  throw new $TypeError($String(argument) + ' is not an object');\n};\n","'use strict';\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = lengthOfArrayLike(O);\n    if (length === 0) return !IS_INCLUDES && -1;\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el !== el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value !== value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar isArray = require('../internals/is-array');\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Safari < 13 does not throw an error in this case\nvar SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !function () {\n  // makes no sense without proper strict mode support\n  if (this !== undefined) return true;\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).length = 1;\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n}();\n\nmodule.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {\n  if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {\n    throw new $TypeError('Cannot set read only .length');\n  } return O.length = length;\n} : function (O, length) {\n  return O.length = length;\n};\n","'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\n\nmodule.exports = function (it) {\n  return stringSlice(toString(it), 8, -1);\n};\n","'use strict';\nvar hasOwn = require('../internals/has-own-property');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","'use strict';\nmodule.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","'use strict';\nvar isCallable = require('../internals/is-callable');\nvar definePropertyModule = require('../internals/object-define-property');\nvar makeBuiltIn = require('../internals/make-built-in');\nvar defineGlobalProperty = require('../internals/define-global-property');\n\nmodule.exports = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n","'use strict';\nvar global = require('../internals/global');\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\n\nmodule.exports = function (key, value) {\n  try {\n    defineProperty(global, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n","'use strict';\nvar fails = require('../internals/fails');\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;\n});\n","'use strict';\nvar global = require('../internals/global');\nvar isObject = require('../internals/is-object');\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n","'use strict';\nvar $TypeError = TypeError;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991\n\nmodule.exports = function (it) {\n  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');\n  return it;\n};\n","'use strict';\nmodule.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';\n","'use strict';\nvar global = require('../internals/global');\nvar userAgent = require('../internals/engine-user-agent');\n\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nmodule.exports = version;\n","'use strict';\n// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n","'use strict';\nvar global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar defineBuiltIn = require('../internals/define-built-in');\nvar defineGlobalProperty = require('../internals/define-global-property');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = global[TARGET] && global[TARGET].prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n","'use strict';\nmodule.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n","'use strict';\nvar NATIVE_BIND = require('../internals/function-bind-native');\n\nvar call = Function.prototype.call;\n\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n  return call.apply(call, arguments);\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar hasOwn = require('../internals/has-own-property');\n\nvar FunctionPrototype = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));\n\nmodule.exports = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n","'use strict';\nvar NATIVE_BIND = require('../internals/function-bind-native');\n\nvar FunctionPrototype = Function.prototype;\nvar call = FunctionPrototype.call;\nvar uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\n\nmodule.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {\n  return function () {\n    return call.apply(fn, arguments);\n  };\n};\n","'use strict';\nvar global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\n\nvar aFunction = function (argument) {\n  return isCallable(argument) ? argument : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n","'use strict';\nvar aCallable = require('../internals/a-callable');\nvar isNullOrUndefined = require('../internals/is-null-or-undefined');\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nmodule.exports = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined(func) ? undefined : aCallable(func);\n};\n","'use strict';\nvar check = function (it) {\n  return it && it.Math === Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  check(typeof this == 'object' && this) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n","'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar toObject = require('../internals/to-object');\n\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject(it), key);\n};\n","'use strict';\nmodule.exports = {};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar createElement = require('../internals/document-create-element');\n\n// Thanks to IE8 for its funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a !== 7;\n});\n","'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\n\nvar $Object = Object;\nvar split = uncurryThis(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) === 'String' ? split(it, '') : $Object(it);\n} : $Object;\n","'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar isCallable = require('../internals/is-callable');\nvar store = require('../internals/shared-store');\n\nvar functionToString = uncurryThis(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n","'use strict';\nvar NATIVE_WEAK_MAP = require('../internals/weak-map-basic-detection');\nvar global = require('../internals/global');\nvar isObject = require('../internals/is-object');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar hasOwn = require('../internals/has-own-property');\nvar shared = require('../internals/shared-store');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw new TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store.get = store.get;\n  store.has = store.has;\n  store.set = store.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  set = function (it, metadata) {\n    if (store.has(it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store.set(it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return store.get(it) || {};\n  };\n  has = function (it) {\n    return store.has(it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (hasOwn(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return hasOwn(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n","'use strict';\nvar classof = require('../internals/classof-raw');\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(argument) {\n  return classof(argument) === 'Array';\n};\n","'use strict';\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nvar documentAll = typeof document == 'object' && document.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\n// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing\nmodule.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll;\n} : function (argument) {\n  return typeof argument == 'function';\n};\n","'use strict';\nvar fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value === POLYFILL ? true\n    : value === NATIVE ? false\n    : isCallable(detection) ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n","'use strict';\n// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nmodule.exports = function (it) {\n  return it === null || it === undefined;\n};\n","'use strict';\nvar isCallable = require('../internals/is-callable');\n\nmodule.exports = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable(it);\n};\n","'use strict';\nmodule.exports = false;\n","'use strict';\nvar getBuiltIn = require('../internals/get-built-in');\nvar isCallable = require('../internals/is-callable');\nvar isPrototypeOf = require('../internals/object-is-prototype-of');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar $Object = Object;\n\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn('Symbol');\n  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n","'use strict';\nvar toLength = require('../internals/to-length');\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nmodule.exports = function (obj) {\n  return toLength(obj.length);\n};\n","'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar fails = require('../internals/fails');\nvar isCallable = require('../internals/is-callable');\nvar hasOwn = require('../internals/has-own-property');\nvar DESCRIPTORS = require('../internals/descriptors');\nvar CONFIGURABLE_FUNCTION_NAME = require('../internals/function-name').CONFIGURABLE;\nvar inspectSource = require('../internals/inspect-source');\nvar InternalStateModule = require('../internals/internal-state');\n\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\nvar $String = String;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty = Object.defineProperty;\nvar stringSlice = uncurryThis(''.slice);\nvar replace = uncurryThis(''.replace);\nvar join = uncurryThis([].join);\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n  return defineProperty(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn = module.exports = function (value, name, options) {\n  if (stringSlice($String(name), 0, 7) === 'Symbol(') {\n    name = '[' + replace($String(name), /^Symbol\\(([^)]*)\\).*$/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {\n    if (DESCRIPTORS) defineProperty(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n    defineProperty(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS) defineProperty(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState(value);\n  if (!hasOwn(state, 'source')) {\n    state.source = join(TEMPLATE, typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn(function toString() {\n  return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n","'use strict';\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nmodule.exports = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor : ceil)(n);\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar V8_PROTOTYPE_DEFINE_BUG = require('../internals/v8-prototype-define-bug');\nvar anObject = require('../internals/an-object');\nvar toPropertyKey = require('../internals/to-property-key');\n\nvar $TypeError = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPropertyKey(P);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar call = require('../internals/function-call');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPropertyKey = require('../internals/to-property-key');\nvar hasOwn = require('../internals/has-own-property');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPropertyKey(P);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n","'use strict';\nvar internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","'use strict';\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n","'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nmodule.exports = uncurryThis({}.isPrototypeOf);\n","'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar hasOwn = require('../internals/has-own-property');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar indexOf = require('../internals/array-includes').indexOf;\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar push = uncurryThis([].push);\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn(O, key = names[i++])) {\n    ~indexOf(result, key) || push(result, key);\n  }\n  return result;\n};\n","'use strict';\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n","'use strict';\nvar call = require('../internals/function-call');\nvar isCallable = require('../internals/is-callable');\nvar isObject = require('../internals/is-object');\n\nvar $TypeError = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nmodule.exports = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;\n  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;\n  throw new $TypeError(\"Can't convert object to primitive value\");\n};\n","'use strict';\nvar getBuiltIn = require('../internals/get-built-in');\nvar uncurryThis = require('../internals/function-uncurry-this');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\nvar concat = uncurryThis([].concat);\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n","'use strict';\nvar isNullOrUndefined = require('../internals/is-null-or-undefined');\n\nvar $TypeError = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (isNullOrUndefined(it)) throw new $TypeError(\"Can't call method on \" + it);\n  return it;\n};\n","'use strict';\nvar shared = require('../internals/shared');\nvar uid = require('../internals/uid');\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n","'use strict';\nvar IS_PURE = require('../internals/is-pure');\nvar globalThis = require('../internals/global');\nvar defineGlobalProperty = require('../internals/define-global-property');\n\nvar SHARED = '__core-js_shared__';\nvar store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});\n\n(store.versions || (store.versions = [])).push({\n  version: '3.37.1',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: ' 2014-2024 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.37.1/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n","'use strict';\nvar store = require('../internals/shared-store');\n\nmodule.exports = function (key, value) {\n  return store[key] || (store[key] = value || {});\n};\n","'use strict';\n/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = require('../internals/engine-v8-version');\nvar fails = require('../internals/fails');\nvar global = require('../internals/global');\n\nvar $String = global.String;\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol('symbol detection');\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,\n  // of course, fail.\n  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n","'use strict';\nvar toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toIntegerOrInfinity(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n","'use strict';\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n","'use strict';\nvar trunc = require('../internals/math-trunc');\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nmodule.exports = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n","'use strict';\nvar toIntegerOrInfinity = require('../internals/to-integer-or-infinity');\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  var len = toIntegerOrInfinity(argument);\n  return len > 0 ? min(len, 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n","'use strict';\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nvar $Object = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return $Object(requireObjectCoercible(argument));\n};\n","'use strict';\nvar call = require('../internals/function-call');\nvar isObject = require('../internals/is-object');\nvar isSymbol = require('../internals/is-symbol');\nvar getMethod = require('../internals/get-method');\nvar ordinaryToPrimitive = require('../internals/ordinary-to-primitive');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nmodule.exports = function (input, pref) {\n  if (!isObject(input) || isSymbol(input)) return input;\n  var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call(exoticToPrim, input, pref);\n    if (!isObject(result) || isSymbol(result)) return result;\n    throw new $TypeError(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n","'use strict';\nvar toPrimitive = require('../internals/to-primitive');\nvar isSymbol = require('../internals/is-symbol');\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nmodule.exports = function (argument) {\n  var key = toPrimitive(argument, 'string');\n  return isSymbol(key) ? key : key + '';\n};\n","'use strict';\nvar $String = String;\n\nmodule.exports = function (argument) {\n  try {\n    return $String(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n","'use strict';\nvar uncurryThis = require('../internals/function-uncurry-this');\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\n\nmodule.exports = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n","'use strict';\n/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nmodule.exports = DESCRIPTORS && fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype !== 42;\n});\n","'use strict';\nvar global = require('../internals/global');\nvar isCallable = require('../internals/is-callable');\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));\n","'use strict';\nvar global = require('../internals/global');\nvar shared = require('../internals/shared');\nvar hasOwn = require('../internals/has-own-property');\nvar uid = require('../internals/uid');\nvar NATIVE_SYMBOL = require('../internals/symbol-constructor-detection');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar Symbol = global.Symbol;\nvar WellKnownSymbolsStore = shared('wks');\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!hasOwn(WellKnownSymbolsStore, name)) {\n    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)\n      ? Symbol[name]\n      : createWellKnownSymbol('Symbol.' + name);\n  } return WellKnownSymbolsStore[name];\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar toObject = require('../internals/to-object');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\nvar setArrayLength = require('../internals/array-set-length');\nvar doesNotExceedSafeInteger = require('../internals/does-not-exceed-safe-integer');\nvar fails = require('../internals/fails');\n\nvar INCORRECT_TO_LENGTH = fails(function () {\n  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;\n});\n\n// V8 <= 121 and Safari <= 15.4; FF < 23 throws InternalError\n// https://bugs.chromium.org/p/v8/issues/detail?id=12681\nvar properErrorOnNonWritableLength = function () {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).push();\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n};\n\nvar FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();\n\n// `Array.prototype.push` method\n// https://tc39.es/ecma262/#sec-array.prototype.push\n$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  push: function push(item) {\n    var O = toObject(this);\n    var len = lengthOfArrayLike(O);\n    var argCount = arguments.length;\n    doesNotExceedSafeInteger(len + argCount);\n    for (var i = 0; i < argCount; i++) {\n      O[len] = arguments[i];\n      len++;\n    }\n    setArrayLength(O, len);\n    return len;\n  }\n});\n","/*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","/*!\n * Chart.js v4.4.3\n * https://www.chartjs.org\n * (c) 2024 Chart.js Contributors\n * Released under the MIT License\n */\nimport { Color } from '@kurkle/color';\n\n/**\n * @namespace Chart.helpers\n */ /**\n * An empty function that can be used, for example, for optional callback.\n */ function noop() {\n/* noop */ }\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */ const uid = (()=>{\n    let id = 0;\n    return ()=>id++;\n})();\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isNullOrUndef(value) {\n    return value === null || typeof value === 'undefined';\n}\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */ function isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n        return true;\n    }\n    return false;\n}\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */ function isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */ function isNumberFinite(value) {\n    return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */ function finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */ function valueOrDefault(value, defaultValue) {\n    return typeof value === 'undefined' ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 : +value / dimension;\nconst toDimension = (value, dimension)=>typeof value === 'string' && value.endsWith('%') ? parseFloat(value) / 100 * dimension : +value;\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */ function callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === 'function') {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */ function _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */ function clone(source) {\n    if (isArray(source)) {\n        return source.map(clone);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        '__proto__',\n        'prototype',\n        'constructor'\n    ].indexOf(key) === -1;\n}\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */ function _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    let current;\n    for(let i = 0; i < ilen; ++i){\n        current = sources[i];\n        if (!isObject(current)) {\n            continue;\n        }\n        const keys = Object.keys(current);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, current, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */ function _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone(sval);\n    }\n}\n/**\n * @private\n */ function _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n    // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n    '': (v)=>v,\n    // default resolvers\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\n/**\n * @private\n */ function _splitKey(key) {\n    const parts = key.split('.');\n    const keys = [];\n    let tmp = '';\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith('\\\\')) {\n            tmp = tmp.slice(0, -1) + '.';\n        } else {\n            keys.push(tmp);\n            tmp = '';\n        }\n    }\n    return keys;\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === '') {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\n/**\n * @private\n */ function _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== 'undefined';\nconst isFunction = (value)=>typeof value === 'function';\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * @param e - The event\n * @private\n */ function _isClickEvent(e) {\n    return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */ const PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */ function niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */ function _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\nfunction isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\n/**\n * @private\n */ function _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */ function _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\n// Gets the angle from vertical upright to the point about a centre.\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */ function _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */ function _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\n/**\n * @private\n */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */ function _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\n/**\n * @param {number} value\n * @private\n */ function _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */ function _isBetween(value, start, end, epsilon = 1e-6) {\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */ const _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>{\n        const ti = table[index][key];\n        return ti < value || ti === value && table[index + 1][key] === value;\n    } : (index)=>table[index][key] < value);\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */ const _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */ function _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    'push',\n    'pop',\n    'shift',\n    'splice',\n    'unshift'\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, '_chartjs', {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = '_onData' + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value (...args) {\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === 'function') {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\n/**\n * @param items\n */ function _arrayUnique(items) {\n    const set = new Set(items);\n    if (set.size === items.length) {\n        return items;\n    }\n    return Array.from(set);\n}\n\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n/**\n* Request animation polyfill\n*/ const requestAnimFrame = function() {\n    if (typeof window === 'undefined') {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */ function throttled(fn, thisArg) {\n    let argsToUse = [];\n    let ticking = false;\n    return function(...args) {\n        // Save the args for use later\n        argsToUse = args;\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, argsToUse);\n            });\n        }\n    };\n}\n/**\n * Debounces calling `fn` for `delay` ms\n */ function debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */ const _toLeftRightCenter = (align)=>align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */ const _alignStartEnd = (align, start, end)=>align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */ const _textX = (align, left, right, rtl)=>{\n    const check = rtl ? 'left' : 'right';\n    return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n/**\n * Return start and count of visible points.\n * @private\n */ function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale , _parsed  } = meta;\n        const axis = iScale.axis;\n        const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n        if (minDefined) {\n            start = _limitValue(Math.min(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            count = _limitValue(Math.max(// @ts-expect-error Need to type _parsed\n            _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey\n            animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */ function _scaleRangesChanged(meta) {\n    const { xScale , yScale , _scaleRanges  } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\n\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */ const effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === 'object') {\n        const type = value.toString();\n        return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : new Color(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n\nconst numbers = [\n    'x',\n    'y',\n    'borderWidth',\n    'radius',\n    'tension'\n];\nconst colors = [\n    'color',\n    'borderColor',\n    'backgroundColor'\n];\nfunction applyAnimationsDefaults(defaults) {\n    defaults.set('animation', {\n        delay: undefined,\n        duration: 1000,\n        easing: 'easeOutQuart',\n        fn: undefined,\n        from: undefined,\n        loop: undefined,\n        to: undefined,\n        type: undefined\n    });\n    defaults.describe('animation', {\n        _fallback: false,\n        _indexable: false,\n        _scriptable: (name)=>name !== 'onProgress' && name !== 'onComplete' && name !== 'fn'\n    });\n    defaults.set('animations', {\n        colors: {\n            type: 'color',\n            properties: colors\n        },\n        numbers: {\n            type: 'number',\n            properties: numbers\n        }\n    });\n    defaults.describe('animations', {\n        _fallback: 'animation'\n    });\n    defaults.set('transitions', {\n        active: {\n            animation: {\n                duration: 400\n            }\n        },\n        resize: {\n            animation: {\n                duration: 0\n            }\n        },\n        show: {\n            animations: {\n                colors: {\n                    from: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    duration: 0\n                }\n            }\n        },\n        hide: {\n            animations: {\n                colors: {\n                    to: 'transparent'\n                },\n                visible: {\n                    type: 'boolean',\n                    easing: 'linear',\n                    fn: (v)=>v | 0\n                }\n            }\n        }\n    });\n}\n\nfunction applyLayoutsDefaults(defaults) {\n    defaults.set('layout', {\n        autoPadding: true,\n        padding: {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        }\n    });\n}\n\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\n\nconst formatters = {\n values (value) {\n        return isArray(value) ?  value : '' + value;\n    },\n numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = 'scientific';\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = log10(Math.abs(delta));\n        const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return formatNumber(tickValue, locale, options);\n    },\n logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return '0';\n        }\n        const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n        if ([\n            1,\n            2,\n            3,\n            5,\n            10,\n            15\n        ].includes(remain) || index > 0.8 * ticks.length) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return '';\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\n var Ticks = {\n    formatters\n};\n\nfunction applyScaleDefaults(defaults) {\n    defaults.set('scale', {\n        display: true,\n        offset: false,\n        reverse: false,\n        beginAtZero: false,\n bounds: 'ticks',\n        clip: true,\n grace: 0,\n        grid: {\n            display: true,\n            lineWidth: 1,\n            drawOnChartArea: true,\n            drawTicks: true,\n            tickLength: 8,\n            tickWidth: (_ctx, options)=>options.lineWidth,\n            tickColor: (_ctx, options)=>options.color,\n            offset: false\n        },\n        border: {\n            display: true,\n            dash: [],\n            dashOffset: 0.0,\n            width: 1\n        },\n        title: {\n            display: false,\n            text: '',\n            padding: {\n                top: 4,\n                bottom: 4\n            }\n        },\n        ticks: {\n            minRotation: 0,\n            maxRotation: 50,\n            mirror: false,\n            textStrokeWidth: 0,\n            textStrokeColor: '',\n            padding: 3,\n            display: true,\n            autoSkip: true,\n            autoSkipPadding: 3,\n            labelOffset: 0,\n            callback: Ticks.formatters.values,\n            minor: {},\n            major: {},\n            align: 'center',\n            crossAlign: 'near',\n            showLabelBackdrop: false,\n            backdropColor: 'rgba(255, 255, 255, 0.75)',\n            backdropPadding: 2\n        }\n    });\n    defaults.route('scale.ticks', 'color', '', 'color');\n    defaults.route('scale.grid', 'color', '', 'borderColor');\n    defaults.route('scale.border', 'color', '', 'borderColor');\n    defaults.route('scale.title', 'color', '', 'color');\n    defaults.describe('scale', {\n        _fallback: false,\n        _scriptable: (name)=>!name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n        _indexable: (name)=>name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash'\n    });\n    defaults.describe('scales', {\n        _fallback: 'scale'\n    });\n    defaults.describe('scale.ticks', {\n        _scriptable: (name)=>name !== 'backdropPadding' && name !== 'callback',\n        _indexable: (name)=>name !== 'backdropPadding'\n    });\n}\n\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\n function getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split('.');\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === 'string') {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, ''), scope);\n}\n class Defaults {\n    constructor(_descriptors, _appliers){\n        this.animation = undefined;\n        this.backgroundColor = 'rgba(0,0,0,0.1)';\n        this.borderColor = 'rgba(0,0,0,0.1)';\n        this.color = '#666';\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            'mousemove',\n            'mouseout',\n            'click',\n            'touchstart',\n            'touchmove'\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: 'normal',\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = 'x';\n        this.interaction = {\n            mode: 'nearest',\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n        this.apply(_appliers);\n    }\n set(scope, values) {\n        return set(this, scope, values);\n    }\n get(scope) {\n        return getScope$1(this, scope);\n    }\n describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = '_' + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n    apply(appliers) {\n        appliers.forEach((apply)=>apply(this));\n    }\n}\nvar defaults = /* #__PURE__ */ new Defaults({\n    _scriptable: (name)=>!name.startsWith('on'),\n    _indexable: (name)=>name !== 'events',\n    hover: {\n        _fallback: 'interaction'\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n}, [\n    applyAnimationsDefaults,\n    applyLayoutsDefaults,\n    applyScaleDefaults\n]);\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */ function toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;\n}\n/**\n * @private\n */ function _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\n/**\n * @private\n */ // eslint-disable-next-line complexity\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        // Undefined strings and arrays should not be measured\n        if (thing !== undefined && thing !== null && !isArray(thing)) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            // if it is an array lets measure each element\n            // to do maybe simplify this function a bit so we can do this more recursively?\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                // Undefined strings and arrays should not be measured\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */ function _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n/**\n * Clears the entire canvas.\n */ function clearCanvas(canvas, ctx) {\n    if (!ctx && !canvas) {\n        return;\n    }\n    ctx = ctx || canvas.getContext('2d');\n    ctx.save();\n    // canvas.width and canvas.height do not consider the canvas transform,\n    // while clearRect does\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    drawPointLegend(ctx, options, x, y, null);\n}\n// eslint-disable-next-line complexity\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === 'object') {\n        type = style.toString();\n        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        // Default includes circle\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case 'triangle':\n            width = w ? w / 2 : radius;\n            ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case 'rectRounded':\n            // NOTE: the rounded rect implementation changed to use `arc` instead of\n            // `quadraticCurveTo` since it generates better results when rect is\n            // almost a circle. 0.516 (instead of 0.5) produces results with visually\n            // closer proportion to the previous impl and it is inscribed in the\n            // circle with `radius`. For more details, see the following PRs:\n            // https://github.com/chartjs/Chart.js/issues/5597\n            // https://github.com/chartjs/Chart.js/issues/5858\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n            ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case 'rect':\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        /* falls through */ case 'rectRot':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            ctx.closePath();\n            break;\n        case 'crossRot':\n            rad += QUARTER_PI;\n        /* falls through */ case 'cross':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'star':\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            rad += QUARTER_PI;\n            xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n            ctx.moveTo(x - xOffsetW, y - yOffset);\n            ctx.lineTo(x + xOffsetW, y + yOffset);\n            ctx.moveTo(x + yOffsetW, y - xOffset);\n            ctx.lineTo(x - yOffsetW, y + xOffset);\n            break;\n        case 'line':\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case 'dash':\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n            break;\n        case false:\n            ctx.closePath();\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */ function _isPointInArea(point, area, margin) {\n    margin = margin || 0.5; // margin - default is to match rounded decimals\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\n/**\n * @private\n */ function _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === 'middle') {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === 'after' !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\n/**\n * @private\n */ function _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */ const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction drawBackdrop(ctx, opts) {\n    const oldColor = ctx.fillStyle;\n    ctx.fillStyle = opts.color;\n    ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n    ctx.fillStyle = oldColor;\n}\n/**\n * Render text onto the canvas\n */ function renderText(ctx, text, x, y, font, opts = {}) {\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (opts.backdrop) {\n            drawBackdrop(ctx, opts.backdrop);\n        }\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += Number(font.lineHeight);\n    }\n    ctx.restore();\n}\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */ function addRoundedRectPath(ctx, rect) {\n    const { x , y , w , h , radius  } = rect;\n    // top left arc\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n    // line from top left to bottom left\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    // bottom left arc\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    // line from bottom left to bottom right\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    // bottom right arc\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    // line from bottom right to top right\n    ctx.lineTo(x + w, y + radius.topRight);\n    // top right arc\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    // line from top right to top left\n    ctx.lineTo(x + radius.topLeft, y);\n}\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n/**\n * @alias Chart.helpers.options\n * @namespace\n */ /**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */ function toLineHeight(value, size) {\n    const matches = ('' + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === 'normal') {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case 'px':\n            return value;\n        case '%':\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */ function toTRBL(value) {\n    return _readValueToProps(value, {\n        top: 'y',\n        right: 'x',\n        bottom: 'y',\n        left: 'x'\n    });\n}\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */ function toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        'topLeft',\n        'topRight',\n        'bottomLeft',\n        'bottomRight'\n    ]);\n}\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */ function toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */ function toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === 'string') {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !('' + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = undefined;\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: ''\n    };\n    font.string = toFontString(font);\n    return font;\n}\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */ function resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === 'function') {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */ function _addGrace(minmax, grace, beginAtZero) {\n    const { min , max  } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */ function _createResolver(scopes, prefixes = [\n    ''\n], rootScopes, fallback, getTarget = ()=>scopes[0]) {\n    const finalRootScopes = rootScopes || scopes;\n    if (typeof fallback === 'undefined') {\n        fallback = _resolve('_fallback', scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: 'Object',\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: finalRootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, finalRootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete target._keys; // remove cached keys\n            delete scopes[0][prop]; // remove from top level scope\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value; // set to top level scope + cache\n            delete target._keys; // remove cached keys\n            return true;\n        }\n    });\n}\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */ function _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        /**\n     * A trap for the delete operator.\n     */ deleteProperty (target, prop) {\n            delete target[prop]; // remove from cache\n            delete proxy[prop]; // remove from proxy\n            return true;\n        },\n        /**\n     * A trap for getting property values.\n     */ get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */ getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        /**\n     * A trap for Object.getPrototypeOf.\n     */ getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        /**\n     * A trap for the in operator.\n     */ has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */ ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        /**\n     * A trap for setting property values.\n     */ set (target, prop, value) {\n            proxy[prop] = value; // set to proxy\n            delete target[prop]; // remove from cache\n            return true;\n        }\n    });\n}\n/**\n * @private\n */ function _descriptors(proxy, defaults = {\n    scriptable: true,\n    indexable: true\n}) {\n    const { _scriptable =defaults.scriptable , _indexable =defaults.indexable , _allKeys =defaults.allKeys  } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== 'adapters' && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop) || prop === 'constructor') {\n        return target[prop];\n    }\n    const value = resolve();\n    // cache the resolved value\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    let value = _proxy[prop]; // resolve from proxy\n    // resolve with context\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        // if the resolved value is an object, create a sub resolver for it\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, getValue, target, receiver) {\n    const { _proxy , _context , _subProxy , _stack  } = target;\n    if (_stack.has(prop)) {\n        throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n    }\n    _stack.add(prop);\n    let value = getValue(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        // When scriptable option returns an object, create a resolver on that.\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy , _context , _subProxy , _descriptors: descriptors  } = target;\n    if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n        return value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        // Array of objects, return array or resolvers\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n                // When we reach the descriptor that defines a new _fallback, return that.\n                // The fallback will resume to that new scope.\n                return fallback;\n            }\n        } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n            // Fallback to `false` results to `false`, when falling back to different key.\n            // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (typeof fallback !== 'undefined' && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        ''\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        // For array of objects, the object is used to store updated values\n        return value;\n    }\n    return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (typeof value !== 'undefined') {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith('_'))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale  } = meta;\n    const { key ='r'  } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\n\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === 'x' ? 'y' : 'x';\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    // Props to Rob Spencer at scaled innovation for his post on splining between points\n    // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n    // This function must also respect \"skipped\" points\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    // If all points are the same, s01 & s02 will be inf\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01; // scaling factor for triangle Ta\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\n/**\n * Adjust tangents to ensure monotonic properties\n */ function monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n        }\n    }\n}\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */ function splineCurveMonotone(points, indexAxis = 'x') {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    // Calculate slopes (deltaK) and initialize tangents (mK)\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\n/**\n * @private\n */ function _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    // Only consider points that are drawn in case the spanGaps option is used\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === 'monotone') {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */ /**\n * @private\n */ function _isDomSupported() {\n    return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n/**\n * @private\n */ function _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === '[object ShadowRoot]') {\n        parent = parent.host;\n    }\n    return parent;\n}\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */ function parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === 'string') {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf('%') !== -1) {\n            // percentage * size in dimension\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    'top',\n    'right',\n    'bottom',\n    'left'\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? '-' + suffix : '';\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */ function getCanvasPosition(e, canvas) {\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX , offsetY  } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */ function getRelativePosition(event, chart) {\n    if ('native' in event) {\n        return event;\n    }\n    const { canvas , currentDevicePixelRatio  } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === 'border-box';\n    const paddings = getPositionedStyle(style, 'padding');\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const { x , y , box  } = getCanvasPosition(event, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width , height  } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = canvas && _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect(); // this is the border box of the container\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n            const containerPadding = getPositionedStyle(containerStyle, 'padding');\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\n// eslint-disable-next-line complexity\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, 'margin');\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width , height  } = containerSize;\n    if (style.boxSizing === 'content-box') {\n        const borders = getPositionedStyle(style, 'border', 'width');\n        const paddings = getPositionedStyle(style, 'padding');\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        // https://github.com/chartjs/Chart.js/issues/4659\n        // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n        height = round1(width / 2);\n    }\n    const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n    if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n        height = containerSize.height;\n        width = round1(Math.floor(height * aspectRatio));\n    }\n    return {\n        width,\n        height\n    };\n}\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */ function retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = Math.floor(chart.height * pixelRatio);\n    const deviceWidth = Math.floor(chart.width * pixelRatio);\n    chart.height = Math.floor(chart.height);\n    chart.width = Math.floor(chart.width);\n    const canvas = chart.canvas;\n    // If no style has been set on the canvas, the render size is used as display size,\n    // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n    // See https://github.com/chartjs/Chart.js/issues/3575\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = `${chart.height}px`;\n        canvas.style.width = `${chart.width}px`;\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */ const supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        if (_isDomSupported()) {\n            window.addEventListener('test', null, options);\n            window.removeEventListener('test', null, options);\n        }\n    } catch (e) {\n    // continue regardless of error\n    }\n    return passiveSupported;\n}();\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */ function readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\n\n/**\n * @private\n */ function _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\n/**\n * @private\n */ function _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y : mode === 'after' ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\n/**\n * @private\n */ function _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\n\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === 'center') {\n                return align;\n            }\n            return align === 'right' ? 'left' : 'right';\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === 'ltr' || direction === 'rtl') {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue('direction'),\n            style.getPropertyPriority('direction')\n        ];\n        style.setProperty('direction', direction, 'important');\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty('direction', original[0], original[1]);\n    }\n}\n\nfunction propertyFn(property) {\n    if (property === 'angle') {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment({ start , end , count , loop , style  }) {\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property , start: startBound , end: endBound  } = bounds;\n    const { between , normalize  } = propertyFn(property);\n    const count = points.length;\n    let { start , end , loop  } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\n function _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property , start: startBound , end: endBound  } = bounds;\n    const count = points.length;\n    const { compare , between , normalize  } = propertyFn(property);\n    const { start , end , loop , style  } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\n function _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\n function findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\n function solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\n function _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start , end  } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n function splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\n function doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex , options: { spanGaps  }  } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: 'segment',\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    if (!prevStyle) {\n        return false;\n    }\n    const cache = [];\n    const replacer = function(key, value) {\n        if (!isPatternOrGradient(value)) {\n            return value;\n        }\n        if (!cache.includes(value)) {\n            cache.push(value);\n        }\n        return cache.indexOf(value);\n    };\n    return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n\nexport { unclipArea as $, _rlookupByKey as A, _lookupByKey as B, _isPointInArea as C, getAngleFromPoint as D, toPadding as E, each as F, getMaximumSize as G, HALF_PI as H, _getParentNode as I, readUsedSize as J, supportsEventListenerOptions as K, throttled as L, _isDomSupported as M, _factorize as N, finiteOrDefault as O, PI as P, callback as Q, _addGrace as R, _limitValue as S, TAU as T, toDegrees as U, _measureText as V, _int16Range as W, _alignPixel as X, clipArea as Y, renderText as Z, _arrayUnique as _, resolve as a, fontString as a$, toFont as a0, _toLeftRightCenter as a1, _alignStartEnd as a2, overrides as a3, merge as a4, _capitalize as a5, descriptors as a6, isFunction as a7, _attachContext as a8, _createResolver as a9, overrideTextDirection as aA, _textX as aB, restoreTextDirection as aC, drawPointLegend as aD, distanceBetweenPoints as aE, noop as aF, _setMinAndMaxByKey as aG, niceNum as aH, almostWhole as aI, almostEquals as aJ, _decimalPlaces as aK, Ticks as aL, log10 as aM, _longestText as aN, _filterBetween as aO, _lookup as aP, isPatternOrGradient as aQ, getHoverColor as aR, clone as aS, _merger as aT, _mergerIf as aU, _deprecated as aV, _splitKey as aW, toFontString as aX, splineCurve as aY, splineCurveMonotone as aZ, getStyle as a_, _descriptors as aa, mergeIf as ab, uid as ac, debounce as ad, retinaScale as ae, clearCanvas as af, setsEqual as ag, _elementsEqual as ah, _isClickEvent as ai, _isBetween as aj, _readValueToProps as ak, _updateBezierControlPoints as al, _computeSegments as am, _boundSegments as an, _steppedInterpolation as ao, _bezierInterpolation as ap, _pointInLine as aq, _steppedLineTo as ar, _bezierCurveTo as as, drawPoint as at, addRoundedRectPath as au, toTRBL as av, toTRBLCorners as aw, _boundSegment as ax, _normalizeAngle as ay, getRtlAdapter as az, isArray as b, toLineHeight as b0, PITAU as b1, INFINITY as b2, RAD_PER_DEG as b3, QUARTER_PI as b4, TWO_THIRDS_PI as b5, _angleDiff as b6, color as c, defaults as d, effects as e, resolveObjectKey as f, isNumberFinite as g, defined as h, isObject as i, createContext as j, isNullOrUndef as k, listenArrayEvents as l, toPercentage as m, toDimension as n, formatNumber as o, _angleBetween as p, _getStartAndCountOfVisiblePoints as q, requestAnimFrame as r, sign as s, toRadians as t, unlistenArrayEvents as u, valueOrDefault as v, _scaleRangesChanged as w, isNumber as x, _parseObjectDataRadialScale as y, getRelativePosition as z };\n//# sourceMappingURL=helpers.segment.js.map\n","/*!\n * Chart.js v4.4.3\n * https://www.chartjs.org\n * (c) 2024 Chart.js Contributors\n * Released under the MIT License\n */\nimport { r as requestAnimFrame, a as resolve, e as effects, c as color, i as isObject, d as defaults, b as isArray, v as valueOrDefault, u as unlistenArrayEvents, l as listenArrayEvents, f as resolveObjectKey, g as isNumberFinite, h as defined, s as sign, j as createContext, k as isNullOrUndef, _ as _arrayUnique, t as toRadians, m as toPercentage, n as toDimension, T as TAU, o as formatNumber, p as _angleBetween, H as HALF_PI, P as PI, q as _getStartAndCountOfVisiblePoints, w as _scaleRangesChanged, x as isNumber, y as _parseObjectDataRadialScale, z as getRelativePosition, A as _rlookupByKey, B as _lookupByKey, C as _isPointInArea, D as getAngleFromPoint, E as toPadding, F as each, G as getMaximumSize, I as _getParentNode, J as readUsedSize, K as supportsEventListenerOptions, L as throttled, M as _isDomSupported, N as _factorize, O as finiteOrDefault, Q as callback, R as _addGrace, S as _limitValue, U as toDegrees, V as _measureText, W as _int16Range, X as _alignPixel, Y as clipArea, Z as renderText, $ as unclipArea, a0 as toFont, a1 as _toLeftRightCenter, a2 as _alignStartEnd, a3 as overrides, a4 as merge, a5 as _capitalize, a6 as descriptors, a7 as isFunction, a8 as _attachContext, a9 as _createResolver, aa as _descriptors, ab as mergeIf, ac as uid, ad as debounce, ae as retinaScale, af as clearCanvas, ag as setsEqual, ah as _elementsEqual, ai as _isClickEvent, aj as _isBetween, ak as _readValueToProps, al as _updateBezierControlPoints, am as _computeSegments, an as _boundSegments, ao as _steppedInterpolation, ap as _bezierInterpolation, aq as _pointInLine, ar as _steppedLineTo, as as _bezierCurveTo, at as drawPoint, au as addRoundedRectPath, av as toTRBL, aw as toTRBLCorners, ax as _boundSegment, ay as _normalizeAngle, az as getRtlAdapter, aA as overrideTextDirection, aB as _textX, aC as restoreTextDirection, aD as drawPointLegend, aE as distanceBetweenPoints, aF as noop, aG as _setMinAndMaxByKey, aH as niceNum, aI as almostWhole, aJ as almostEquals, aK as _decimalPlaces, aL as Ticks, aM as log10, aN as _longestText, aO as _filterBetween, aP as _lookup } from './chunks/helpers.segment.js';\nimport '@kurkle/color';\n\nclass Animator {\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = requestAnimFrame.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n _update(date = Date.now()) {\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, 'progress');\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, 'complete');\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), 'complete');\n    }\n remove(chart) {\n        return this._charts.delete(chart);\n    }\n}\nvar animator = /* #__PURE__ */ new Animator();\n\nconst transparent = 'transparent';\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n color (from, to, factor) {\n        const c0 = color(from || transparent);\n        const c1 = c0.valid && color(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = resolve([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = resolve([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = effects[cfg.easing] || effects.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = resolve([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = resolve([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? 'res' : 'rej';\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n}\n\nclass Animations {\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n    configure(config) {\n        if (!isObject(config)) {\n            return;\n        }\n        const animationOptions = Object.keys(defaults.animation);\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!isObject(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            (isArray(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{\n            });\n        }\n        return animations;\n    }\n _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === '$') {\n                continue;\n            }\n            if (prop === 'options') {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\n\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if (isObject(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n    const keys = stack.keys;\n    const singleMode = options.mode === 'single';\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {\n            value += otherValue;\n        }\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data, meta) {\n    const { iScale , vScale  } = meta;\n    const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';\n    const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            [iAxisKey]: key,\n            [vAxisKey]: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n    const { min , max , minDefined , maxDefined  } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart , _cachedMeta: meta  } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale , vScale , index: datasetIndex  } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index , [vAxis]: value  } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n        const visualValues = stack._visualValues || (stack._visualValues = {});\n        visualValues[datasetIndex] = value;\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return createContext(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: 'default',\n        type: 'dataset'\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return createContext(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: 'default',\n        type: 'data'\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n        if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n            delete stacks[axis]._visualValues[datasetIndex];\n        }\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n static defaults = {};\n static datasetElementType = null;\n static dataElementType = null;\n constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n         this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.datasetElementType = new.target.datasetElementType;\n        this.dataElementType = new.target.dataElementType;\n        this.initialize();\n    }\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n        if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n            console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n        }\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === 'x' ? x : axis === 'r' ? r : y;\n        const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n        const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n        const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update('reset');\n    }\n _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            unlistenArrayEvents(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if (isObject(data)) {\n            const meta = this._cachedMeta;\n            this._data = convertObjectDataToArray(data, meta);\n        } else if (_data !== data) {\n            if (_data) {\n                unlistenArrayEvents(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                listenArrayEvents(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n        }\n    }\n configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n parse(start, count) {\n        const { _cachedMeta: meta , _data: data  } = this;\n        const { iScale , _stacked  } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if (isArray(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if (isObject(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const { xScale , yScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n                y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]._visualValues\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin , max: otherMax  } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if (isNumberFinite(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n getMaxOverflow() {\n        return false;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n            value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n        };\n    }\n _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || 'default');\n        meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n getStyle(index, active) {\n        const mode = active ? 'active' : 'default';\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n _resolveElementOptions(elementType, mode = 'default', index) {\n        const active = mode === 'active';\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + '-' + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && defined(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            `${elementType}Hover`,\n            'hover',\n            elementType,\n            ''\n        ] : [\n            elementType,\n            ''\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(defaults.elements[elementType]);\n        const context = ()=>this.getContext(index, active, mode);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = `animation-${transition}`;\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, 'active', true);\n    }\n _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', false);\n        }\n    }\n _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, 'active', true);\n        }\n    }\n _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n _insertElements(start, count, resetNewElements = true) {\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, 'reset');\n        }\n    }\n    updateElements(element, start, count, mode) {}\n _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            '_insertElements',\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            '_removeElements',\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            '_removeElements',\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                '_removeElements',\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                '_insertElements',\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            '_insertElements',\n            0,\n            arguments.length\n        ]);\n    }\n}\n\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = _arrayUnique(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\n function computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if (defined(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\n function computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if (isNullOrUndef(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\n function computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if (isArray(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return sign(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = 'left';\n        end = 'right';\n    } else {\n        reverse = properties.base < properties.y;\n        start = 'bottom';\n        end = 'top';\n    }\n    if (reverse) {\n        top = 'end';\n        bottom = 'start';\n    } else {\n        top = 'start';\n        bottom = 'end';\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start , end , reverse , top , bottom  } = borderProps(properties);\n    if (edge === 'middle' && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === 'start' ? start : v === 'end' ? end : v;\n}\nfunction setInflateAmount(properties, { inflateAmount  }, ratio) {\n    properties.inflateAmount = inflateAmount === 'auto' ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    static id = 'bar';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'bar',\n        categoryPercentage: 0.8,\n        barPercentage: 0.9,\n        grouped: true,\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'base',\n                    'width',\n                    'height'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category',\n                offset: true,\n                grid: {\n                    offset: true\n                }\n            },\n            _value_: {\n                type: 'linear',\n                beginAtZero: true\n            }\n        }\n    };\n parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n parseObjectData(meta, data, start, count) {\n        const { iScale , vScale  } = meta;\n        const { xAxisKey ='x' , yAxisKey ='y'  } = this._parsing;\n        const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n            parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n getMaxOverflow() {\n        return 0;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale , vScale  } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? '[' + custom.start + ', ' + custom.end + ']' : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === 'reset';\n        const { index , _cachedMeta: { vScale  }  } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n _getStacks(last, dataIndex) {\n        const { iScale  } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const skipNull = (meta)=>{\n            const parsed = meta.controller.getParsed(dataIndex);\n            const val = parsed && parsed[meta.vScale.axis];\n            if (isNullOrUndef(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale , _stacked , index: datasetIndex  } , options: { base: baseValue , minBarLength  }  } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n            if (_stacked && !floating) {\n                parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n            }\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n        let center, size;\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\n\nclass BubbleController extends DatasetController {\n    static id = 'bubble';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'borderWidth',\n                    'radius'\n                ]\n            }\n        }\n    };\n static overrides = {\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== 'active') {\n            values.radius = 0;\n        }\n        values.radius += valueOrDefault(parsed && parsed._custom, radius);\n        return values;\n    }\n}\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < TAU) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>_angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(HALF_PI, startY, endY);\n        const minX = calcMin(PI, startX, endX);\n        const minY = calcMin(PI + HALF_PI, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    static id = 'doughnut';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: false\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'circumference',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius',\n                    'startAngle',\n                    'x',\n                    'y',\n                    'offset',\n                    'borderWidth',\n                    'spacing'\n                ]\n            }\n        },\n        cutout: '50%',\n        rotation: 0,\n        circumference: 360,\n        radius: '100%',\n        spacing: 0,\n        indexAxis: 'r'\n    };\n    static descriptors = {\n        _scriptable: (name)=>name !== 'spacing',\n        _indexable: (name)=>name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash')\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n    linkScales() {}\n parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if (isObject(data[start])) {\n                const { key ='value'  } = this._parsing;\n                getter = (i)=>+resolveObjectKey(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n _getRotation() {\n        return toRadians(this.options.rotation - 90);\n    }\n _getCircumference() {\n        return toRadians(this.options.circumference);\n    }\n _getRotationExtents() {\n        let min = TAU;\n        let max = -TAU;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n update(mode) {\n        const chart = this.chart;\n        const { chartArea  } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference , rotation  } = this._getRotationExtents();\n        const { ratioX , ratioY , offsetX , offsetY  } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = toDimension(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return TAU * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = formatNumber(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== 'inner') {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n _getRingWeight(datasetIndex) {\n        return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n}\n\nclass LineController extends DatasetController {\n    static id = 'line';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        showLine: true,\n        spanGaps: false\n    };\n static overrides = {\n        scales: {\n            _index_: {\n                type: 'category'\n            },\n            _value_: {\n                type: 'linear'\n            }\n        }\n    };\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line , data: points = [] , _dataset  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (_scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const { sharedOptions , includeOptions  } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        const end = start + count;\n        const pointsCount = points.length;\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = 0; i < pointsCount; ++i){\n            const point = points[i];\n            const properties = directUpdate ? point : {};\n            if (i < start || i >= end) {\n                properties.skip = true;\n                continue;\n            }\n            const parsed = this.getParsed(i);\n            const nullData = isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\n\nclass PolarAreaController extends DatasetController {\n    static id = 'polarArea';\n static defaults = {\n        dataElementType: 'arc',\n        animation: {\n            animateRotate: true,\n            animateScale: true\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'startAngle',\n                    'endAngle',\n                    'innerRadius',\n                    'outerRadius'\n                ]\n            }\n        },\n        indexAxis: 'r',\n        startAngle: 0\n    };\n static overrides = {\n        aspectRatio: 1,\n        plugins: {\n            legend: {\n                labels: {\n                    generateLabels (chart) {\n                        const data = chart.data;\n                        if (data.labels.length && data.datasets.length) {\n                            const { labels: { pointStyle , color  }  } = chart.legend.options;\n                            return data.labels.map((label, i)=>{\n                                const meta = chart.getDatasetMeta(0);\n                                const style = meta.controller.getStyle(i);\n                                return {\n                                    text: label,\n                                    fillStyle: style.backgroundColor,\n                                    strokeStyle: style.borderColor,\n                                    fontColor: color,\n                                    lineWidth: style.borderWidth,\n                                    pointStyle: pointStyle,\n                                    hidden: !chart.getDataVisibility(i),\n                                    index: i\n                                };\n                            });\n                        }\n                        return [];\n                    }\n                },\n                onClick (e, legendItem, legend) {\n                    legend.chart.toggleDataVisibility(legendItem.index);\n                    legend.chart.update();\n                }\n            }\n        },\n        scales: {\n            r: {\n                type: 'radialLinear',\n                angleLines: {\n                    display: false\n                },\n                beginAtZero: true,\n                grid: {\n                    circular: true\n                },\n                pointLabels: {\n                    display: false\n                },\n                startAngle: 0\n            }\n        }\n    };\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || '',\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === 'reset';\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n}\n\nclass PieController extends DoughnutController {\n    static id = 'pie';\n static defaults = {\n        cutout: 0,\n        rotation: 0,\n        circumference: 360,\n        radius: '100%'\n    };\n}\n\nclass RadarController extends DatasetController {\n    static id = 'radar';\n static defaults = {\n        datasetElementType: 'line',\n        dataElementType: 'point',\n        indexAxis: 'r',\n        showLine: true,\n        elements: {\n            line: {\n                fill: 'start'\n            }\n        }\n    };\n static overrides = {\n        aspectRatio: 1,\n        scales: {\n            r: {\n                type: 'radialLinear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== 'resize') {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === 'reset';\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\n\nclass ScatterController extends DatasetController {\n    static id = 'scatter';\n static defaults = {\n        datasetElementType: false,\n        dataElementType: 'point',\n        showLine: false,\n        fill: false\n    };\n static overrides = {\n        interaction: {\n            mode: 'point'\n        },\n        scales: {\n            x: {\n                type: 'linear'\n            },\n            y: {\n                type: 'linear'\n            }\n        }\n    };\n getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const labels = this.chart.data.labels || [];\n        const { xScale , yScale  } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        return {\n            label: labels[index] || '',\n            value: '(' + x + ', ' + y + ')'\n        };\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = []  } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start , count  } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if (_scaleRangesChanged(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            if (!this.datasetElementType) {\n                this.addElements();\n            }\n            const { dataset: line , _dataset  } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        } else if (this.datasetElementType) {\n            delete meta.dataset;\n            this.datasetElementType = false;\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine  } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = this.chart.registry.getElement('line');\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === 'reset';\n        const { iScale , vScale , _stacked , _dataset  } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps , segment  } = this.options;\n        const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = isNullOrUndef(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\n\nvar controllers = /*#__PURE__*/Object.freeze({\n__proto__: null,\nBarController: BarController,\nBubbleController: BubbleController,\nDoughnutController: DoughnutController,\nLineController: LineController,\nPieController: PieController,\nPolarAreaController: PolarAreaController,\nRadarController: RadarController,\nScatterController: ScatterController\n});\n\n/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */ function abstract() {\n    throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */ class DateAdapterBase {\n    /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */ static override(members) {\n        Object.assign(DateAdapterBase.prototype, members);\n    }\n    options;\n    constructor(options){\n        this.options = options || {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    init() {}\n    formats() {\n        return abstract();\n    }\n    parse() {\n        return abstract();\n    }\n    format() {\n        return abstract();\n    }\n    add() {\n        return abstract();\n    }\n    diff() {\n        return abstract();\n    }\n    startOf() {\n        return abstract();\n    }\n    endOf() {\n        return abstract();\n    }\n}\nvar adapters = {\n    _date: DateAdapterBase\n};\n\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller , data , _sorted  } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n        if (!intersect) {\n            return lookupMethod(data, axis, value);\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === 'function' && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\n function evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index , data  } = metasets[i];\n        const { lo , hi  } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\n function getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf('x') !== -1;\n    const useY = axis.indexOf('y') !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\n function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\n function getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle , endAngle  } = element.getProps([\n            'startAngle',\n            'endAngle'\n        ], useFinalPosition);\n        const { angle  } = getAngleFromPoint(element, {\n            x: position.x,\n            y: position.y\n        });\n        if (_angleBetween(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\n function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === 'r' && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n function getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\n var Interaction = {\n    evaluateInteractionItems,\n    modes: {\n index (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'x';\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n dataset (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n point (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n nearest (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            const axis = options.axis || 'xy';\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n x (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n        },\n y (chart, e, options, useFinalPosition) {\n            const position = getRelativePosition(e, chart);\n            return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n        }\n    }\n};\n\nconst STATIC_POSITIONS = [\n    'left',\n    'top',\n    'right',\n    'bottom'\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos , options: { stack , stackWeight =1  }  } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack , pos , stackWeight  } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\n function setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth , hBoxMaxHeight  } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize  } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n    const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos , box  } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!isObject(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos('top');\n    chartArea.x += updatePos('left');\n    updatePos('right');\n    updatePos('bottom');\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        'left',\n        'right'\n    ]) : marginForPositions([\n        'top',\n        'bottom'\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same , other  } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x , y  } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if (defined(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if (defined(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\nvar layouts = {\n addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || 'top';\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = toPadding(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        each(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === 'function') {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, toPadding(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        each(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\n\nclass BasePlatform {\n acquireContext(canvas, aspectRatio) {}\n releaseContext(context) {\n        return false;\n    }\n addEventListener(chart, type, listener) {}\n removeEventListener(chart, type, listener) {}\n getDevicePixelRatio() {\n        return 1;\n    }\n getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n isAttached(canvas) {\n        return true;\n    }\n updateConfig(config) {\n    }\n}\n\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext('2d') || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\n\nconst EXPANDO_KEY = '$chartjs';\n const EVENT_TYPES = {\n    touchstart: 'mousedown',\n    touchmove: 'mousemove',\n    touchend: 'mouseup',\n    pointerenter: 'mouseenter',\n    pointerdown: 'mousedown',\n    pointermove: 'mousemove',\n    pointerup: 'mouseup',\n    pointerleave: 'mouseout',\n    pointerout: 'mouseout'\n};\nconst isNullOrEmpty = (value)=>value === null || value === '';\n function initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute('height');\n    const renderWidth = canvas.getAttribute('width');\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || 'block';\n    style.boxSizing = style.boxSizing || 'border-box';\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = readUsedSize(canvas, 'width');\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === '') {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = readUsedSize(canvas, 'height');\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = supportsEventListenerOptions ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    if (node) {\n        node.addEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction removeListener(chart, type, listener) {\n    if (chart && chart.canvas) {\n        chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n    }\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x , y  } = getRelativePosition(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener('resize', onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener('resize', onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = throttled((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === 'resize') {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = throttled((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart);\n    addListener(canvas, type, proxy);\n    return proxy;\n}\n class DomPlatform extends BasePlatform {\n acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext('2d');\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            'height',\n            'width'\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if (isNullOrUndef(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n getMaximumSize(canvas, width, height, aspectRatio) {\n        return getMaximumSize(canvas, width, height, aspectRatio);\n    }\n isAttached(canvas) {\n        const container = canvas && _getParentNode(canvas);\n        return !!(container && container.isConnected);\n    }\n}\n\nfunction _detectPlatform(canvas) {\n    if (!_isDomSupported() || typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\n\nclass Element {\n    static defaults = {};\n    static defaultRoutes = undefined;\n    x;\n    y;\n    active = false;\n    options;\n    $animations;\n    tooltipPosition(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return isNumber(this.x) && isNumber(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            // let's not create an object, if not needed\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n}\n\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const determinedMaxTicks = determineMaxTicks(scale);\n    const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\n function calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = _factorize(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\n function getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n function skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\n function skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = valueOrDefault(majorStart, 0);\n    const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\n function getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\n\nconst reverseAlign = (align)=>align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit)=>Math.min(maxTicksLimit || ticksLength, ticksLength);\n function sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\n function getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\n function garbageCollect(caches, length) {\n    each(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\n function getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\n function getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = toFont(options.font, fallback);\n    const padding = toPadding(options.padding);\n    const lines = isArray(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return createContext(parent, {\n        scale,\n        type: 'scale'\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return createContext(parent, {\n        tick,\n        index,\n        type: 'tick'\n    });\n}\nfunction titleAlign(align, position, reverse) {\n     let ret = _toLeftRightCenter(align);\n    if (reverse && position !== 'right' || !reverse && position === 'right') {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top , left , bottom , right , chart  } = scale;\n    const { chartArea , scales  } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = _alignStartEnd(align, left, right);\n        if (isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === 'center') {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if (isObject(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === 'center') {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = position === 'left' ? -HALF_PI : HALF_PI;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    constructor(cfg){\n        super();\n         this.id = cfg.id;\n         this.type = cfg.type;\n         this.options = undefined;\n         this.ctx = cfg.ctx;\n         this.chart = cfg.chart;\n         this.top = undefined;\n         this.bottom = undefined;\n         this.left = undefined;\n         this.right = undefined;\n         this.width = undefined;\n         this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n         this.maxWidth = undefined;\n         this.maxHeight = undefined;\n         this.paddingTop = undefined;\n         this.paddingBottom = undefined;\n         this.paddingLeft = undefined;\n         this.paddingRight = undefined;\n         this.axis = undefined;\n         this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n         this.ticks = [];\n         this._gridLineItems = null;\n         this._labelItems = null;\n         this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n         this._startPixel = undefined;\n         this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n parse(raw, index) {\n        return raw;\n    }\n getUserBounds() {\n        let { _userMin , _userMax , _suggestedMin , _suggestedMax  } = this;\n        _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: finiteOrDefault(_userMin, _suggestedMin),\n            max: finiteOrDefault(_userMax, _suggestedMax),\n            minDefined: isNumberFinite(_userMin),\n            maxDefined: isNumberFinite(_userMax)\n        };\n    }\n getMinMax(canStack) {\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: finiteOrDefault(min, finiteOrDefault(max, min)),\n            max: finiteOrDefault(max, finiteOrDefault(min, max))\n        };\n    }\n getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n getTicks() {\n        return this.ticks;\n    }\n getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n getLabelItems(chartArea = this.chart.chartArea) {\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        return items;\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        callback(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n update(maxWidth, maxHeight, margins) {\n        const { beginAtZero , grace , ticks: tickOpts  } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = _addGrace(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        callback(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        callback(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        callback(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        callback(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks('beforeDataLimits');\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks('afterDataLimits');\n    }\n    beforeBuildTicks() {\n        this._callHooks('beforeBuildTicks');\n    }\n buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks('afterBuildTicks');\n    }\n    beforeTickToLabelConversion() {\n        callback(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = callback(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        callback(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        callback(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        callback(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        callback(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart , options: { ticks: tickOpts , title: titleOpts , grid: gridOpts  }  } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first , last , widest , highest  } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = toRadians(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align , padding  } , position  } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === 'start') {\n                paddingRight = last.width;\n            } else if (align === 'end') {\n                paddingLeft = first.width;\n            } else if (align !== 'inner') {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === 'start') {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === 'end') {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        callback(this.options.afterFit, [\n            this\n        ]);\n    }\n isHorizontal() {\n        const { axis , position  } = this.options;\n        return position === 'top' || position === 'bottom' || axis === 'x';\n    }\n isFullSize() {\n        return this.options.fullSize;\n    }\n _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if (isNullOrUndef(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n        }\n        return labelSizes;\n    }\n _computeLabelSizes(ticks, length, maxTicksLimit) {\n        const { ctx , _longestTextCache: caches  } = this;\n        const widths = [];\n        const heights = [];\n        const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; i += increment){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!isNullOrUndef(label) && !isArray(label)) {\n                width = _measureText(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if (isArray(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel =  label[j];\n                    if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n                        width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n getLabelForValue(value) {\n        return value;\n    }\n getPixelForValue(value, index) {\n        return NaN;\n    }\n getValueForPixel(pixel) {}\n getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n    }\n getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n getBaseValue() {\n        const { min , max  } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = toRadians(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n _isVisible() {\n        const display = this.options.display;\n        if (display !== 'auto') {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid , position , border  } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = borderOpts.display ? borderOpts.width : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return _alignPixel(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === 'top') {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === 'bottom') {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === 'left') {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === 'right') {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const context = this.getContext(i);\n            const optsAtIndex = grid.setContext(context);\n            const optsAtIndexBorder = border.setContext(context);\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndexBorder.dash || [];\n            const borderDashOffset = optsAtIndexBorder.dashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position , ticks: optionTicks  } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align , crossAlign , padding , mirror  } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -toRadians(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = 'middle';\n        if (position === 'top') {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'bottom') {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === 'left') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === 'right') {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === 'x') {\n            if (position === 'center') {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === 'y') {\n            if (position === 'center') {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if (isObject(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === 'y') {\n            if (align === 'start') {\n                textBaseline = 'top';\n            } else if (align === 'end') {\n                textBaseline = 'bottom';\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = isArray(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === 'inner') {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? 'right' : 'left';\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? 'left' : 'right';\n                    } else {\n                        tickTextAlign = 'center';\n                    }\n                }\n                if (position === 'top') {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === 'near' || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === 'center') {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n                    x += lineHeight / 2 * Math.sin(rotation);\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = toPadding(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = textOffset - labelPadding.top;\n                let left = 0 - labelPadding.left;\n                switch(textBaseline){\n                    case 'middle':\n                        top -= height / 2;\n                        break;\n                    case 'bottom':\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case 'center':\n                        left -= width / 2;\n                        break;\n                    case 'right':\n                        left -= width;\n                        break;\n                    case 'inner':\n                        if (i === ilen - 1) {\n                            left -= width;\n                        } else if (i > 0) {\n                            left -= width / 2;\n                        }\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                label,\n                font,\n                textOffset,\n                options: {\n                    rotation,\n                    color,\n                    strokeColor,\n                    strokeWidth,\n                    textAlign: tickTextAlign,\n                    textBaseline,\n                    translation: [\n                        x,\n                        y\n                    ],\n                    backdrop\n                }\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position , ticks  } = this.options;\n        const rotation = -toRadians(this.labelRotation);\n        if (rotation) {\n            return position === 'top' ? 'left' : 'right';\n        }\n        let align = 'center';\n        if (ticks.align === 'start') {\n            align = 'left';\n        } else if (ticks.align === 'end') {\n            align = 'right';\n        } else if (ticks.align === 'inner') {\n            align = 'inner';\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position , ticks: { crossAlign , mirror , padding  }  } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === 'left') {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x = this.left;\n                }\n            }\n        } else if (position === 'right') {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === 'near') {\n                    textAlign = 'right';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x -= widest / 2;\n                } else {\n                    textAlign = 'left';\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === 'near') {\n                    textAlign = 'left';\n                } else if (crossAlign === 'center') {\n                    textAlign = 'center';\n                    x += widest / 2;\n                } else {\n                    textAlign = 'right';\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = 'right';\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === 'left' || position === 'right') {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === 'top' || position === 'bottom') {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n drawBackground() {\n        const { ctx , options: { backgroundColor  } , left , top , width , height  } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n drawBorder() {\n        const { chart , ctx , options: { border , grid  }  } = this;\n        const borderOpts = border.setContext(this.getContext());\n        const axisWidth = border.display ? borderOpts.width : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.width;\n        ctx.strokeStyle = borderOpts.color;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            clipArea(ctx, area);\n        }\n        const items = this.getLabelItems(chartArea);\n        for (const item of items){\n            const renderTextOptions = item.options;\n            const tickFont = item.font;\n            const label = item.label;\n            const y = item.textOffset;\n            renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n        }\n        if (area) {\n            unclipArea(ctx);\n        }\n    }\n drawTitle() {\n        const { ctx , options: { position , title , reverse  }  } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = toFont(title.font);\n        const padding = toPadding(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === 'bottom' || position === 'center' || isObject(position)) {\n            offset += padding.bottom;\n            if (isArray(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX , titleY , maxWidth , rotation  } = titleArgs(this, offset, position, align);\n        renderText(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n        const bz = valueOrDefault(opts.border && opts.border.z, 0);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: bz,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + 'AxisID';\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return toFont(opts.font);\n    }\n _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n}\n\nclass TypedRegistry {\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + '.' + id;\n        if (!id) {\n            throw new Error('class does not have id: ' + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            defaults.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n get(id) {\n        return this.items[id];\n    }\n unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in defaults[scope]) {\n            delete defaults[scope][id];\n            if (this.override) {\n                delete overrides[id];\n            }\n        }\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = merge(Object.create(null), [\n        parentScope ? defaults.get(parentScope) : {},\n        defaults.get(scope),\n        item.defaults\n    ]);\n    defaults.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        defaults.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split('.');\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join('.');\n        const parts = routes[property].split('.');\n        const targetName = parts.pop();\n        const targetScope = parts.join('.');\n        defaults.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return 'id' in proto && 'defaults' in proto;\n}\n\nclass Registry {\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n        this.elements = new TypedRegistry(Element, 'elements');\n        this.plugins = new TypedRegistry(Object, 'plugins');\n        this.scales = new TypedRegistry(Scale, 'scales');\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n add(...args) {\n        this._each('register', args);\n    }\n    remove(...args) {\n        this._each('unregister', args);\n    }\n addControllers(...args) {\n        this._each('register', args, this.controllers);\n    }\n addElements(...args) {\n        this._each('register', args, this.elements);\n    }\n addPlugins(...args) {\n        this._each('register', args, this.plugins);\n    }\n addScales(...args) {\n        this._each('register', args, this.scales);\n    }\n getController(id) {\n        return this._get(id, this.controllers, 'controller');\n    }\n getElement(id) {\n        return this._get(id, this.elements, 'element');\n    }\n getPlugin(id) {\n        return this._get(id, this.plugins, 'plugin');\n    }\n getScale(id) {\n        return this._get(id, this.scales, 'scale');\n    }\n removeControllers(...args) {\n        this._each('unregister', args, this.controllers);\n    }\n removeElements(...args) {\n        this._each('unregister', args, this.elements);\n    }\n removePlugins(...args) {\n        this._each('unregister', args, this.plugins);\n    }\n removeScales(...args) {\n        this._each('unregister', args, this.scales);\n    }\n _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                each(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n _exec(method, registry, component) {\n        const camelMethod = _capitalize(method);\n        callback(component['before' + camelMethod], [], component);\n        registry[method](component);\n        callback(component['after' + camelMethod], [], component);\n    }\n _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n        }\n        return item;\n    }\n}\nvar registry = /* #__PURE__ */ new Registry();\n\nclass PluginService {\n    constructor(){\n        this._init = [];\n    }\n notify(chart, hook, args, filter) {\n        if (hook === 'beforeInit') {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, 'install');\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === 'afterDestroy') {\n            this._notify(descriptors, chart, 'stop');\n            this._notify(this._init, chart, 'uninstall');\n        }\n        return result;\n    }\n _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if (callback(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!isNullOrUndef(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = valueOrDefault(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n        this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n    }\n}\n function allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, { plugins , localIds  }, options, all) {\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, { plugin , local  }, opts, context) {\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        ''\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\n\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = defaults.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === '_index_') {\n        axis = indexAxis;\n    } else if (id === '_value_') {\n        axis = indexAxis === 'x' ? 'y' : 'x';\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? '_index_' : '_value_';\n}\nfunction idMatchesAxis(id) {\n    if (id === 'x' || id === 'y' || id === 'r') {\n        return id;\n    }\n}\nfunction axisFromPosition(position) {\n    if (position === 'top' || position === 'bottom') {\n        return 'x';\n    }\n    if (position === 'left' || position === 'right') {\n        return 'y';\n    }\n}\nfunction determineAxis(id, ...scaleOptions) {\n    if (idMatchesAxis(id)) {\n        return id;\n    }\n    for (const opts of scaleOptions){\n        const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n        if (axis) {\n            return axis;\n        }\n    }\n    throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\nfunction getAxisFromDataset(id, axis, dataset) {\n    if (dataset[axis + 'AxisID'] === id) {\n        return {\n            axis\n        };\n    }\n}\nfunction retrieveAxisFromDatasets(id, config) {\n    if (config.data && config.data.datasets) {\n        const boundDs = config.data.datasets.filter((d)=>d.xAxisID === id || d.yAxisID === id);\n        if (boundDs.length) {\n            return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n        }\n    }\n    return {};\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = overrides[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!isObject(scaleConf)) {\n            return console.error(`Invalid scale configuration for scale: ${id}`);\n        }\n        if (scaleConf._proxy) {\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n        }\n        const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        scales[id] = mergeIf(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = overrides[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + 'AxisID'] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            mergeIf(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        mergeIf(scale, [\n            defaults.scales[scale.type],\n            defaults.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = valueOrDefault(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = resolveObjectKey(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\n                [\n                    `datasets.${datasetType}.transitions.${transition}`,\n                    `transitions.${transition}`\n                ],\n                [\n                    `datasets.${datasetType}`,\n                    ''\n                ]\n            ]);\n    }\n datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\n                [\n                    `datasets.${datasetType}.elements.${elementType}`,\n                    `datasets.${datasetType}`,\n                    `elements.${elementType}`,\n                    ''\n                ]\n            ]);\n    }\n pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\n                [\n                    `plugins.${id}`,\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options , type  } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, overrides[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, defaults, key));\n            keys.forEach((key)=>addIfFound(scopes, descriptors, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n chartOptionScopes() {\n        const { options , type  } = this;\n        return [\n            options,\n            overrides[type] || {},\n            defaults.datasets[type] || {},\n            {\n                type\n            },\n            defaults,\n            descriptors\n        ];\n    }\n resolveNamedOptions(scopes, names, context, prefixes = [\n        ''\n    ]) {\n        const result = {\n            $shared: true\n        };\n        const { resolver , subPrefixes  } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = isFunction(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = _attachContext(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n createResolver(scopes, context, prefixes = [\n        ''\n    ], descriptorDefaults) {\n        const { resolver  } = getResolver(this._resolverCache, scopes, prefixes);\n        return isObject(context) ? _attachContext(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = _createResolver(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes('hover'))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>isObject(value) && Object.getOwnPropertyNames(value).some((key)=>isFunction(value[key]));\nfunction needContext(proxy, names) {\n    const { isScriptable , isIndexable  } = _descriptors(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar version = \"4.4.3\";\n\nconst KNOWN_POSITIONS = [\n    'top',\n    'bottom',\n    'left',\n    'right',\n    'chartArea'\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === 'top' || position === 'bottom' || KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x';\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins('afterRender');\n    callback(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    callback(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\n function getCanvas(item) {\n    if (_isDomSupported() && typeof item === 'string') {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\n function determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === 'mouseout') {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nfunction getSizeForArea(scale, chartArea, field) {\n    return scale.options.clip ? scale[field] : chartArea[field];\n}\nfunction getDatasetArea(meta, chartArea) {\n    const { xScale , yScale  } = meta;\n    if (xScale && yScale) {\n        return {\n            left: getSizeForArea(xScale, chartArea, 'left'),\n            right: getSizeForArea(xScale, chartArea, 'right'),\n            top: getSizeForArea(yScale, chartArea, 'top'),\n            bottom: getSizeForArea(yScale, chartArea, 'bottom')\n        };\n    }\n    return chartArea;\n}\nclass Chart {\n    static defaults = defaults;\n    static instances = instances;\n    static overrides = overrides;\n    static registry = registry;\n    static version = version;\n    static getChart = getChart;\n    static register(...items) {\n        registry.add(...items);\n        invalidatePlugins();\n    }\n    static unregister(...items) {\n        registry.remove(...items);\n        invalidatePlugins();\n    }\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error('Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' + ' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.');\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = uid();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n         this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = debounce((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, 'complete', onAnimationsComplete);\n        animator.listen(this, 'progress', onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio , maintainAspectRatio  } , width , height , _aspectRatio  } = this;\n        if (!isNullOrUndef(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    get registry() {\n        return registry;\n    }\n _initialize() {\n        this.notifyPlugins('beforeInit');\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            retinaScale(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins('afterInit');\n        return this;\n    }\n    clear() {\n        clearCanvas(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? 'resize' : 'attach';\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!retinaScale(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins('resize', {\n            size: newSize\n        });\n        callback(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        each(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === 'r';\n                const isHorizontal = axis === 'x';\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n                    dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n                };\n            }));\n        }\n        each(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        each(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        each(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n    }\n _removeUnreferencedMetasets() {\n        const { _metasets: metasets , data: { datasets  }  } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = '' + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType , dataElementType  } = defaults.datasets[type];\n                Object.assign(ControllerClass, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n _resetElements() {\n        each(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n reset() {\n        this._resetElements();\n        this.notifyPlugins('reset');\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins('beforeUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins('beforeElementsUpdate');\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller  } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            each(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins('afterUpdate', {\n            mode\n        });\n        this._layers.sort(compare2Level('z', '_idx'));\n        const { _active , _lastEvent  } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n _updateScales() {\n        each(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n _updateHiddenIndices() {\n        const { _hiddenIndices  } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method , start , count  } of changes){\n            const move = method === '_removeElements' ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + ',' + c.splice(1).join(',')));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!setsEqual(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(',')).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n _updateLayout(minPadding) {\n        if (this.notifyPlugins('beforeLayout', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        each(this.boxes, (box)=>{\n            if (noArea && box.position === 'chartArea') {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins('afterLayout');\n    }\n _updateDatasets(mode) {\n        if (this.notifyPlugins('beforeDatasetsUpdate', {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, isFunction(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins('afterDatasetsUpdate', {\n            mode\n        });\n    }\n _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetUpdate', args);\n    }\n    render() {\n        if (this.notifyPlugins('beforeRender', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width , height  } = this._resizeBeforeDraw;\n            this._resize(width, height);\n            this._resizeBeforeDraw = null;\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins('beforeDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins('afterDraw');\n    }\n _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n _drawDatasets() {\n        if (this.notifyPlugins('beforeDatasetsDraw', {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins('afterDatasetsDraw');\n    }\n _drawDataset(meta) {\n        const ctx = this.ctx;\n        const clip = meta._clip;\n        const useClip = !clip.disabled;\n        const area = getDatasetArea(meta, this.chartArea);\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n            return;\n        }\n        if (useClip) {\n            clipArea(ctx, {\n                left: clip.left === false ? 0 : area.left - clip.left,\n                right: clip.right === false ? this.width : area.right + clip.right,\n                top: clip.top === false ? 0 : area.top - clip.top,\n                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n            });\n        }\n        meta.controller.draw();\n        if (useClip) {\n            unclipArea(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins('afterDatasetDraw', args);\n    }\n isPointInArea(point) {\n        return _isPointInArea(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === 'function') {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = createContext(null, {\n            chart: this,\n            type: 'chart'\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? 'show' : 'hide';\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if (defined(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins('beforeDestroy');\n        const { canvas , ctx  } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            clearCanvas(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        delete instances[this.id];\n        this.notifyPlugins('afterDestroy');\n    }\n    toBase64Image(...args) {\n        return this.canvas.toDataURL(...args);\n    }\n bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        each(this.options.events, (type)=>_add(type, listener));\n    }\n bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove('attach', attached);\n            this.attached = true;\n            this.resize();\n            _add('resize', listener);\n            _add('detach', detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove('resize', listener);\n            this._stop();\n            this._resize(0, 0);\n            _add('attach', attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n unbindEvents() {\n        each(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        each(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? 'set' : 'remove';\n        let meta, item, i, ilen;\n        if (mode === 'dataset') {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller['_' + prefix + 'DatasetHoverStyle']();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('No dataset found at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !_elementsEqual(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n isPluginEnabled(pluginId) {\n        return this._plugins._cache.filter((p)=>p.plugin.id === pluginId).length === 1;\n    }\n _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins('afterEvent', args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [] , options  } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = _isClickEvent(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            callback(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                callback(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !_elementsEqual(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n}\nfunction invalidatePlugins() {\n    return each(Chart.instances, (chart)=>chart._plugins.invalidate());\n}\n\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle , pixelMargin , x , y , outerRadius , innerRadius  } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    // Draw an inner border by clipping the arc and drawing a double-width border\n    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return _readValueToProps(value, [\n        'outerStart',\n        'outerEnd',\n        'innerStart',\n        'innerEnd'\n    ]);\n}\n/**\n * Parse border radius from the provided options\n */ function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    // Outer limits are complicated. We want to compute the available angular distance at\n    // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n    // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n    //\n    // If the borderRadius is large, that value can become negative.\n    // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n    // we know that the thickness term will dominate and compute the limits at that point\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: _limitValue(o.innerStart, 0, innerLimit),\n        innerEnd: _limitValue(o.innerEnd, 0, innerLimit)\n    };\n}\n/**\n * Convert (r, ) to (x, y)\n */ function rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */ function pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x , y , startAngle: start , pixelMargin , innerRadius: innerR  } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        // When spacing is present, it is the same for all items\n        // So we adjust the start and end angle of the arc such that\n        // the distance is the same as it would be without the spacing\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart , outerEnd , innerStart , innerEnd  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        // The first arc segments from point 1 to point a to point 2\n        const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n        ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n        // The corner segment from point 2 to point 3\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n        }\n        // The line from point 3 to point 4\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        // The corner segment from point 4 to point 5\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n        }\n        // The inner arc from point 5 to point b to point 6\n        const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\n        ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\n        // The corner segment from point 6 to point 7\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n        }\n        // The line from point 7 to point 8\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        // The corner segment from point 8 to point 1\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference  } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % TAU || TAU);\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawBorder(ctx, element, offset, spacing, circular) {\n    const { fullCircles , startAngle , circumference , options  } = element;\n    const { borderWidth , borderJoinStyle , borderDash , borderDashOffset  } = options;\n    const inner = options.borderAlign === 'inner';\n    if (!borderWidth) {\n        return;\n    }\n    ctx.setLineDash(borderDash || []);\n    ctx.lineDashOffset = borderDashOffset;\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || 'round';\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || 'bevel';\n    }\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.stroke();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + (circumference % TAU || TAU);\n        }\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    if (!fullCircles) {\n        pathArc(ctx, element, offset, spacing, endAngle, circular);\n        ctx.stroke();\n    }\n}\nclass ArcElement extends Element {\n    static id = 'arc';\n    static defaults = {\n        borderAlign: 'center',\n        borderColor: '#fff',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: undefined,\n        borderRadius: 0,\n        borderWidth: 2,\n        offset: 0,\n        spacing: 0,\n        angle: undefined,\n        circular: true\n    };\n    static defaultRoutes = {\n        backgroundColor: 'backgroundColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash'\n    };\n    circumference;\n    endAngle;\n    fullCircles;\n    innerRadius;\n    outerRadius;\n    pixelMargin;\n    startAngle;\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        const { angle , distance  } = getAngleFromPoint(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle , endAngle , innerRadius , outerRadius , circumference  } = this.getProps([\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius',\n            'circumference'\n        ], useFinalPosition);\n        const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n        const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n        const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n        const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , startAngle , endAngle , innerRadius , outerRadius  } = this.getProps([\n            'x',\n            'y',\n            'startAngle',\n            'endAngle',\n            'innerRadius',\n            'outerRadius'\n        ], useFinalPosition);\n        const { offset , spacing  } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options , circumference  } = this;\n        const offset = (options.offset || 0) / 4;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;\n        this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        const halfAngle = (this.startAngle + this.endAngle) / 2;\n        ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n        const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n        const radiusOffset = offset * fix;\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, circular);\n        ctx.restore();\n    }\n}\n\nfunction setStyle(ctx, options, style = options) {\n    ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\n function getLineMethod(options) {\n    if (options.stepped) {\n        return _steppedLineTo;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _bezierCurveTo;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n    const count = points.length;\n    const { start: paramsStart = 0 , end: paramsEnd = count - 1  } = params;\n    const { start: segmentStart , end: segmentEnd  } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\n function pathSegment(ctx, line, segment, params) {\n    const { points , options  } = line;\n    const { count , start , loop , ilen  } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move =true , reverse  } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\n function fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count , start , ilen  } = pathVars(points, segment, params);\n    const { move =true , reverse  } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\n function _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\n function _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _steppedInterpolation;\n    }\n    if (options.tension || options.cubicInterpolationMode === 'monotone') {\n        return _bezierInterpolation;\n    }\n    return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments , options  } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === 'function';\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    static id = 'line';\n static defaults = {\n        borderCapStyle: 'butt',\n        borderDash: [],\n        borderDashOffset: 0,\n        borderJoinStyle: 'miter',\n        borderWidth: 3,\n        capBezierPoints: true,\n        cubicInterpolationMode: 'default',\n        fill: false,\n        spanGaps: false,\n        stepped: false,\n        tension: 0\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    static descriptors = {\n        _scriptable: true,\n        _indexable: (name)=>name !== 'borderDash' && name !== 'fill'\n    };\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n    }\n first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = _boundSegments(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start , end  } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n}\n\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value  } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    static id = 'point';\n    parsed;\n    skip;\n    stop;\n    /**\n   * @type {any}\n   */ static defaults = {\n        borderWidth: 1,\n        hitRadius: 1,\n        hoverBorderWidth: 1,\n        hoverRadius: 4,\n        pointStyle: 'circle',\n        radius: 3,\n        rotation: 0\n    };\n    /**\n   * @type {any}\n   */ static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, 'x', useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, 'y', useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y  } = this.getProps([\n            'x',\n            'y'\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        drawPoint(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        // @ts-expect-error Fallbacks should never be hit in practice\n        return options.radius + options.hitRadius;\n    }\n}\n\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x , y , base , width , height  } =  bar.getProps([\n        'x',\n        'y',\n        'base',\n        'width',\n        'height'\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = toTRBL(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius  } = bar.getProps([\n        'enableBorderRadius'\n    ]);\n    const value = bar.options.borderRadius;\n    const o = toTRBLCorners(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || isObject(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n function addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    static id = 'bar';\n static defaults = {\n        borderSkipped: 'start',\n        borderWidth: 0,\n        borderRadius: 0,\n        inflateAmount: 'auto',\n        pointStyle: undefined\n    };\n static defaultRoutes = {\n        backgroundColor: 'backgroundColor',\n        borderColor: 'borderColor'\n    };\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    draw(ctx) {\n        const { inflateAmount , options: { borderColor , backgroundColor  }  } = this;\n        const { inner , outer  } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill('evenodd');\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x , y , base , horizontal  } =  this.getProps([\n            'x',\n            'y',\n            'base',\n            'horizontal'\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === 'x' ? this.width / 2 : this.height / 2;\n    }\n}\n\nvar elements = /*#__PURE__*/Object.freeze({\n__proto__: null,\nArcElement: ArcElement,\nBarElement: BarElement,\nLineElement: LineElement,\nPointElement: PointElement\n});\n\nconst BORDER_COLORS = [\n    'rgb(54, 162, 235)',\n    'rgb(255, 99, 132)',\n    'rgb(255, 159, 64)',\n    'rgb(255, 205, 86)',\n    'rgb(75, 192, 192)',\n    'rgb(153, 102, 255)',\n    'rgb(201, 203, 207)' // grey\n];\n// Border colors with 50% transparency\nconst BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color)=>color.replace('rgb(', 'rgba(').replace(')', ', 0.5)'));\nfunction getBorderColor(i) {\n    return BORDER_COLORS[i % BORDER_COLORS.length];\n}\nfunction getBackgroundColor(i) {\n    return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\nfunction colorizeDefaultDataset(dataset, i) {\n    dataset.borderColor = getBorderColor(i);\n    dataset.backgroundColor = getBackgroundColor(i);\n    return ++i;\n}\nfunction colorizeDoughnutDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBorderColor(i++));\n    return i;\n}\nfunction colorizePolarAreaDataset(dataset, i) {\n    dataset.backgroundColor = dataset.data.map(()=>getBackgroundColor(i++));\n    return i;\n}\nfunction getColorizer(chart) {\n    let i = 0;\n    return (dataset, datasetIndex)=>{\n        const controller = chart.getDatasetMeta(datasetIndex).controller;\n        if (controller instanceof DoughnutController) {\n            i = colorizeDoughnutDataset(dataset, i);\n        } else if (controller instanceof PolarAreaController) {\n            i = colorizePolarAreaDataset(dataset, i);\n        } else if (controller) {\n            i = colorizeDefaultDataset(dataset, i);\n        }\n    };\n}\nfunction containsColorsDefinitions(descriptors) {\n    let k;\n    for(k in descriptors){\n        if (descriptors[k].borderColor || descriptors[k].backgroundColor) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction containsColorsDefinition(descriptor) {\n    return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\nvar plugin_colors = {\n    id: 'colors',\n    defaults: {\n        enabled: true,\n        forceOverride: false\n    },\n    beforeLayout (chart, _args, options) {\n        if (!options.enabled) {\n            return;\n        }\n        const { data: { datasets  } , options: chartOptions  } = chart.config;\n        const { elements  } = chartOptions;\n        if (!options.forceOverride && (containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements))) {\n            return;\n        }\n        const colorizer = getColorizer(chart);\n        datasets.forEach(colorizer);\n    }\n};\n\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx , y: pointAy  } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, 'data', {\n            configurable: true,\n            enumerable: true,\n            writable: true,\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale  } = meta;\n    const { min , max , minDefined , maxDefined  } = iScale.getUserBounds();\n    if (minDefined) {\n        start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: 'decimation',\n    defaults: {\n        algorithm: 'min-max',\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data , indexAxis  } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if (resolve([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === 'y') {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== 'linear' && xAxis.type !== 'time') {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start , count  } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if (isNullOrUndef(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, 'data', {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case 'lttb':\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case 'min-max':\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\n\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start , end  } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = _boundSegments(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = _boundSegment(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, 'start', Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, 'end', Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === 'angle') {\n        start = _normalizeAngle(start);\n        end = _normalizeAngle(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x =null , y =null  } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach(({ start , end  })=>{\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\n\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if (isArray(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\n\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!isNumberFinite(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\n function _decodeFill(line, index, count) {\n     const fill = parseFillOption(line);\n    if (isObject(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if (isNumberFinite(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        'origin',\n        'start',\n        'end',\n        'stack',\n        'shape'\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === '-' || firstCh === '+') {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\n function _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === 'start') {\n        pixel = scale.bottom;\n    } else if (fill === 'end') {\n        pixel = scale.top;\n    } else if (isObject(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\n function _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === 'start') {\n        value = startValue;\n    } else if (fill === 'end') {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if (isObject(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\n function parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = valueOrDefault(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return 'origin';\n    }\n    return fill;\n}\n\nfunction _buildStackLine(source) {\n    const { scale , index , line  } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\n function getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas('line');\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\n function addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first , last , point  } = findPoint(line, sourcePoint, 'x');\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\n function findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if (_isBetween(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\n\nclass simpleArc {\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n    pathSegment(ctx, bounds, opts) {\n        const { x , y , radius  } = this;\n        bounds = bounds || {\n            start: 0,\n            end: TAU\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x , y , radius  } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n}\n\nfunction _getTarget(source) {\n    const { chart , fill , line  } = source;\n    if (isNumberFinite(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === 'stack') {\n        return _buildStackLine(source);\n    }\n    if (fill === 'shape') {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\n function getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale ={} , fill  } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if (isNumberFinite(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale , fill  } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\n\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { line , scale , axis  } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above =color , below =color  } = fillOption || {};\n    if (target && line.points.length) {\n        clipArea(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis\n        });\n        unclipArea(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line , target , above , below , area , scale  } = cfg;\n    const property = line._loop ? 'angle' : cfg.axis;\n    ctx.save();\n    if (property === 'x' && below !== above) {\n        clipVertical(ctx, target, area.top);\n        fill(ctx, {\n            line,\n            target,\n            color: above,\n            scale,\n            property\n        });\n        ctx.restore();\n        ctx.save();\n        clipVertical(ctx, target, area.bottom);\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: below,\n        scale,\n        property\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments , points  } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start , end  } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line , target , property , color , scale  } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src , target: tgt , start , end  } of segments){\n        const { style: { backgroundColor =color  } = {}  } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? 'evenodd' : 'nonzero');\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, bounds) {\n    const { top , bottom  } = scale.chart.chartArea;\n    const { property , start , end  } = bounds || {};\n    if (property === 'x') {\n        ctx.beginPath();\n        ctx.rect(start, top, end - start, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\n\nvar index = {\n    id: 'filler',\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === 'beforeDraw';\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== 'beforeDatasetsDraw') {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== 'beforeDatasetDraw') {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: 'beforeDatasetDraw'\n    }\n};\n\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight =fontSize , boxWidth =fontSize  } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = callback(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options , ctx  } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = toFont(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx , maxWidth , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n        const { ctx , maxHeight , options: { labels: { padding  }  }  } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const { itemWidth , itemHeight  } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes , options: { align , labels: { padding  } , rtl  }  } = this;\n        const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === 'top' || this.options.position === 'bottom';\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            clipArea(ctx, this);\n            this._draw();\n            unclipArea(ctx);\n        }\n    }\n _draw() {\n        const { options: opts , columnSizes , lineWidths , ctx  } = this;\n        const { align , labels: labelOpts  } = opts;\n        const defaultColor = defaults.color;\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n        const labelFont = toFont(labelOpts.font);\n        const { padding  } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign('left');\n        ctx.textBaseline = 'middle';\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth , boxHeight , itemHeight  } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n            ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n            ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = toTRBLCorners(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    addRoundedRectPath(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        overrideTextDirection(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor;\n            ctx.fillStyle = legendItem.fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else if (typeof legendItem.text !== 'string') {\n                const fontLineHeight = labelFont.lineHeight;\n                cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        restoreTextDirection(this.ctx, opts.textDirection);\n    }\n drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = toFont(titleOpts.font);\n        const titlePadding = toPadding(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = _alignStartEnd(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n        ctx.textBaseline = 'middle';\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        renderText(ctx, titleOpts.text, x, y, titleFont);\n    }\n _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = toFont(titleOpts.font);\n        const titlePadding = toPadding(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === 'mousemove' || e.type === 'mouseout') {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                callback(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                callback(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            callback(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n}\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n    const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n    const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n    return {\n        itemWidth,\n        itemHeight\n    };\n}\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n    let legendItemText = legendItem.text;\n    if (legendItemText && typeof legendItemText !== 'string') {\n        legendItemText = legendItemText.reduce((a, b)=>a.length > b.length ? a : b);\n    }\n    return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\n}\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n    let itemHeight = _itemHeight;\n    if (typeof legendItem.text !== 'string') {\n        itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n    }\n    return itemHeight;\n}\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n    const labelHeight = legendItem.text ? legendItem.text.length : 0;\n    return fontLineHeight * labelHeight;\n}\nfunction isListened(type, opts) {\n    if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: 'legend',\n _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: 'top',\n        align: 'center',\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle , pointStyle , textAlign , color , useBorderRadius , borderRadius  }  } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = toPadding(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: 'center',\n            text: ''\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith('on'),\n        labels: {\n            _scriptable: (name)=>![\n                    'generateLabels',\n                    'filter',\n                    'sort'\n                ].includes(name)\n        }\n    }\n};\n\nclass Title extends Element {\n constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = isArray(opts.text) ? opts.text.length : 1;\n        this._padding = toPadding(opts.padding);\n        const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === 'top' || pos === 'bottom';\n    }\n    _drawArgs(offset) {\n        const { top , left , bottom , right , options  } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = _alignStartEnd(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === 'left') {\n                titleX = left + offset;\n                titleY = _alignStartEnd(align, bottom, top);\n                rotation = PI * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = _alignStartEnd(align, top, bottom);\n                rotation = PI * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = toFont(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX , titleY , maxWidth , rotation  } = this._drawArgs(offset);\n        renderText(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: _toLeftRightCenter(opts.align),\n            textBaseline: 'middle',\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: 'title',\n _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'bold'\n        },\n        fullSize: true,\n        padding: 10,\n        position: 'top',\n        text: '',\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: 'subtitle',\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: 'center',\n        display: false,\n        font: {\n            weight: 'normal'\n        },\n        fullSize: true,\n        padding: 0,\n        position: 'top',\n        text: '',\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: 'color'\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\n\nconst positioners = {\n average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let xSet = new Set();\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                xSet.add(pos.x);\n                y += pos.y;\n                ++count;\n            }\n        }\n        const xAverage = [\n            ...xSet\n        ].reduce((a, b)=>a + b) / xSet.size;\n        return {\n            x: xAverage,\n            y: y / count\n        };\n    },\n nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = distanceBetweenPoints(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if (isArray(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\n function splitNewlines(str) {\n    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n        return str.split('\\n');\n    }\n    return str;\n}\n function createTooltipItem(chart, item) {\n    const { element , datasetIndex , index  } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label , value  } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\n function getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body , footer , title  } = tooltip;\n    const { boxWidth , boxHeight  } = options;\n    const bodyFont = toFont(options.bodyFont);\n    const titleFont = toFont(options.titleFont);\n    const footerFont = toFont(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = toPadding(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    each(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    each(body, (bodyItem)=>{\n        each(bodyItem.before, maxLineWidth);\n        each(bodyItem.lines, maxLineWidth);\n        each(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    each(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y , height  } = size;\n    if (y < height / 2) {\n        return 'top';\n    } else if (y > chart.height - height / 2) {\n        return 'bottom';\n    }\n    return 'center';\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x , width  } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === 'left' && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === 'right' && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x , width  } = size;\n    const { width: chartWidth , chartArea: { left , right  }  } = chart;\n    let xAlign = 'center';\n    if (yAlign === 'center') {\n        xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n    } else if (x <= width / 2) {\n        xAlign = 'left';\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = 'right';\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = 'center';\n    }\n    return xAlign;\n}\n function determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x , width  } = size;\n    if (xAlign === 'right') {\n        x -= width;\n    } else if (xAlign === 'center') {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y , height  } = size;\n    if (yAlign === 'top') {\n        y += paddingAndSize;\n    } else if (yAlign === 'bottom') {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\n function getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize , caretPadding , cornerRadius  } = options;\n    const { xAlign , yAlign  } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === 'center') {\n        if (xAlign === 'left') {\n            x += paddingAndSize;\n        } else if (xAlign === 'right') {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === 'left') {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === 'right') {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: _limitValue(x, 0, chart.width - size.width),\n        y: _limitValue(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = toPadding(options.padding);\n    return align === 'center' ? tooltip.x + tooltip.width / 2 : align === 'right' ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\n function getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return createContext(parent, {\n        tooltip,\n        tooltipItems,\n        type: 'tooltip'\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nconst defaultCallbacks = {\n    beforeTitle: noop,\n    title (tooltipItems) {\n        if (tooltipItems.length > 0) {\n            const item = tooltipItems[0];\n            const labels = item.chart.data.labels;\n            const labelCount = labels ? labels.length : 0;\n            if (this && this.options && this.options.mode === 'dataset') {\n                return item.dataset.label || '';\n            } else if (item.label) {\n                return item.label;\n            } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                return labels[item.dataIndex];\n            }\n        }\n        return '';\n    },\n    afterTitle: noop,\n    beforeBody: noop,\n    beforeLabel: noop,\n    label (tooltipItem) {\n        if (this && this.options && this.options.mode === 'dataset') {\n            return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n        }\n        let label = tooltipItem.dataset.label || '';\n        if (label) {\n            label += ': ';\n        }\n        const value = tooltipItem.formattedValue;\n        if (!isNullOrUndef(value)) {\n            label += value;\n        }\n        return label;\n    },\n    labelColor (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            borderColor: options.borderColor,\n            backgroundColor: options.backgroundColor,\n            borderWidth: options.borderWidth,\n            borderDash: options.borderDash,\n            borderDashOffset: options.borderDashOffset,\n            borderRadius: 0\n        };\n    },\n    labelTextColor () {\n        return this.options.bodyColor;\n    },\n    labelPointStyle (tooltipItem) {\n        const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n        const options = meta.controller.getStyle(tooltipItem.dataIndex);\n        return {\n            pointStyle: options.pointStyle,\n            rotation: options.rotation\n        };\n    },\n    afterLabel: noop,\n    afterBody: noop,\n    beforeFooter: noop,\n    footer: noop,\n    afterFooter: noop\n};\n function invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n    const result = callbacks[name].call(ctx, arg);\n    if (typeof result === 'undefined') {\n        return defaultCallbacks[name].call(ctx, arg);\n    }\n    return result;\n}\nclass Tooltip extends Element {\n static positioners = positioners;\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks  } = options;\n        const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n        const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n        const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks  } = options;\n        const bodyItems = [];\n        each(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n            pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks  } = options;\n        const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n        const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n        const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        each(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n            labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n            labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign , yAlign  } = this;\n        const { caretSize , cornerRadius  } = options;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(cornerRadius);\n        const { x: ptX , y: ptY  } = tooltipPoint;\n        const { width , height  } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === 'center') {\n            y2 = ptY + height / 2;\n            if (xAlign === 'left') {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === 'left') {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === 'right') {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === 'top') {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = 'middle';\n            titleFont = toFont(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColor = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight , boxWidth  } = options;\n        const bodyFont = toFont(options.bodyFont);\n        const colorX = getAlignedX(this, 'left', options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            drawPoint(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.fillStyle = labelColor.backgroundColor;\n            drawPoint(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;\n            ctx.strokeStyle = labelColor.borderColor;\n            ctx.setLineDash(labelColor.borderDash || []);\n            ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n            const borderRadius = toTRBLCorners(labelColor.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                addRoundedRectPath(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.beginPath();\n                addRoundedRectPath(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColor.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body  } = this;\n        const { bodySpacing , bodyAlign , displayColors , boxHeight , boxWidth , boxPadding  } = options;\n        const bodyFont = toFont(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = 'middle';\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        each(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            each(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            each(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        each(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = 'middle';\n            footerFont = toFont(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign , yAlign  } = this;\n        const { x , y  } = pt;\n        const { width , height  } = tooltipSize;\n        const { topLeft , topRight , bottomLeft , bottomRight  } = toTRBLCorners(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === 'top') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === 'center' && xAlign === 'right') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === 'bottom') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === 'center' && xAlign === 'left') {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = toPadding(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            overrideTextDirection(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            restoreTextDirection(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n getActiveElements() {\n        return this._active || [];\n    }\n setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map(({ datasetIndex , index  })=>{\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error('Cannot find a dataset at index ' + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !_elementsEqual(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n handleEvent(e, replay, inChartArea = true) {\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === 'mouseout') {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive.filter((i)=>this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined);\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n _positionChanged(active, e) {\n        const { caretX , caretY , options  } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n}\nvar plugin_tooltip = {\n    id: 'tooltip',\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins('beforeTooltipDraw', {\n                ...args,\n                cancelable: true\n            }) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins('afterTooltipDraw', args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: 'average',\n        backgroundColor: 'rgba(0,0,0,0.8)',\n        titleColor: '#fff',\n        titleFont: {\n            weight: 'bold'\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: 'left',\n        bodyColor: '#fff',\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: 'left',\n        footerColor: '#fff',\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: 'bold'\n        },\n        footerAlign: 'left',\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: '#fff',\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: 'rgba(0,0,0,0)',\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: 'easeOutQuart'\n        },\n        animations: {\n            numbers: {\n                type: 'number',\n                properties: [\n                    'x',\n                    'y',\n                    'width',\n                    'height',\n                    'caretX',\n                    'caretY'\n                ]\n            },\n            opacity: {\n                easing: 'linear',\n                duration: 200\n            }\n        },\n        callbacks: defaultCallbacks\n    },\n    defaultRoutes: {\n        bodyFont: 'font',\n        footerFont: 'font',\n        titleFont: 'font'\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== 'filter' && name !== 'itemSort' && name !== 'external',\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: 'animation'\n        }\n    },\n    additionalOptionScopes: [\n        'interaction'\n    ]\n};\n\nvar plugins = /*#__PURE__*/Object.freeze({\n__proto__: null,\nColors: plugin_colors,\nDecimation: plugin_decimation,\nFiller: index,\nLegend: plugin_legend,\nSubTitle: plugin_subtitle,\nTitle: plugin_title,\nTooltip: plugin_tooltip\n});\n\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === 'string') {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : _limitValue(Math.round(index), 0, max);\nfunction _getLabelForValue(value) {\n    const labels = this.getLabels();\n    if (value >= 0 && value < labels.length) {\n        return labels[value];\n    }\n    return value;\n}\nclass CategoryScale extends Scale {\n    static id = 'category';\n static defaults = {\n        ticks: {\n            callback: _getLabelForValue\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index , label  } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if (isNullOrUndef(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this.getMinMax(true);\n        if (this.options.bounds === 'ticks') {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return _getLabelForValue.call(this, value);\n    }\n configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== 'number') {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n}\n\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds , step , min , max , precision , count , maxTicks , maxDigits , includeBounds  } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin , max: rmax  } = dataRange;\n    const minDefined = !isNullOrUndef(min);\n    const maxDefined = !isNullOrUndef(max);\n    const countDefined = !isNullOrUndef(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!isNullOrUndef(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === 'ticks') {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));\n    factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n        if (maxDefined && tickValue > max) {\n            break;\n        }\n        ticks.push({\n            value: tickValue\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, { horizontal , minRotation  }) {\n    const rad = toRadians(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * ('' + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n         this._endValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        if (isNullOrUndef(raw)) {\n            return null;\n        }\n        if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero  } = this.options;\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let { min , max  } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = sign(min);\n            const maxSign = sign(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit , stepSize  } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === 'ticks') {\n            _setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n}\n\nclass LinearScale extends LinearScaleBase {\n    static id = 'linear';\n static defaults = {\n        ticks: {\n            callback: Ticks.formatters.numeric\n        }\n    };\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = isNumberFinite(min) ? min : 0;\n        this.max = isNumberFinite(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = toRadians(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\n\nconst log10Floor = (v)=>Math.floor(log10(v));\nconst changeExponent = (v, m)=>Math.pow(10, log10Floor(v) + m);\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, log10Floor(tickVal));\n    return remain === 1;\n}\nfunction steps(min, max, rangeExp) {\n    const rangeStep = Math.pow(10, rangeExp);\n    const start = Math.floor(min / rangeStep);\n    const end = Math.ceil(max / rangeStep);\n    return end - start;\n}\nfunction startExp(min, max) {\n    const range = max - min;\n    let rangeExp = log10Floor(range);\n    while(steps(min, max, rangeExp) > 10){\n        rangeExp++;\n    }\n    while(steps(min, max, rangeExp) < 10){\n        rangeExp--;\n    }\n    return Math.min(rangeExp, log10Floor(min));\n}\n function generateTicks(generationOptions, { min , max  }) {\n    min = finiteOrDefault(generationOptions.min, min);\n    const ticks = [];\n    const minExp = log10Floor(min);\n    let exp = startExp(min, max);\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    const stepSize = Math.pow(10, exp);\n    const base = minExp > exp ? Math.pow(10, minExp) : 0;\n    const start = Math.round((min - base) * precision) / precision;\n    const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n    let significand = Math.floor((start - offset) / Math.pow(10, exp));\n    let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n    while(value < max){\n        ticks.push({\n            value,\n            major: isMajor(value),\n            significand\n        });\n        if (significand >= 10) {\n            significand = significand < 15 ? 15 : 20;\n        } else {\n            significand++;\n        }\n        if (significand >= 20) {\n            exp++;\n            significand = 2;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n    }\n    const lastTick = finiteOrDefault(generationOptions.max, value);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(lastTick),\n        significand\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    static id = 'logarithmic';\n static defaults = {\n        ticks: {\n            callback: Ticks.formatters.logarithmic,\n            major: {\n                enabled: true\n            }\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.start = undefined;\n         this.end = undefined;\n         this._startValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return isNumberFinite(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(true);\n        this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n        this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {\n            this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined , maxDefined  } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(changeExponent(min, -1));\n                setMax(changeExponent(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(changeExponent(max, -1));\n        }\n        if (max <= 0) {\n            setMax(changeExponent(min, +1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === 'ticks') {\n            _setMinAndMaxByKey(ticks, this, 'value');\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n getLabelForValue(value) {\n        return value === undefined ? '0' : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n    }\n configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = log10(start);\n        this._valueRange = log10(this.max) - log10(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n}\n\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = toPadding(tickOpts.backdropPadding);\n        return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = isArray(label) ? label : [\n        label\n    ];\n    return {\n        w: _longestText(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\n function fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = toFont(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round(toDegrees(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction createPointLabelItem(scale, index, itemOpts) {\n    const outerDistance = scale.drawingArea;\n    const { extra , additionalAngle , padding , size  } = itemOpts;\n    const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n    const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n    const y = yForAngle(pointLabelPosition.y, size.h, angle);\n    const textAlign = getTextAlignForAngle(angle);\n    const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n    return {\n        visible: true,\n        x: pointLabelPosition.x,\n        y,\n        textAlign,\n        left,\n        top: y,\n        right: left + size.w,\n        bottom: y + size.h\n    };\n}\nfunction isNotOverlapped(item, area) {\n    if (!area) {\n        return true;\n    }\n    const { left , top , right , bottom  } = item;\n    const apexesInArea = _isPointInArea({\n        x: left,\n        y: top\n    }, area) || _isPointInArea({\n        x: left,\n        y: bottom\n    }, area) || _isPointInArea({\n        x: right,\n        y: top\n    }, area) || _isPointInArea({\n        x: right,\n        y: bottom\n    }, area);\n    return !apexesInArea;\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const { centerPointLabels , display  } = opts.pointLabels;\n    const itemOpts = {\n        extra: getTickBackdropHeight(opts) / 2,\n        additionalAngle: centerPointLabels ? PI / valueCount : 0\n    };\n    let area;\n    for(let i = 0; i < valueCount; i++){\n        itemOpts.padding = padding[i];\n        itemOpts.size = labelSizes[i];\n        const item = createPointLabelItem(scale, i, itemOpts);\n        items.push(item);\n        if (display === 'auto') {\n            item.visible = isNotOverlapped(item, area);\n            if (item.visible) {\n                area = item;\n            }\n        }\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return 'center';\n    } else if (angle < 180) {\n        return 'left';\n    }\n    return 'right';\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === 'right') {\n        x -= w;\n    } else if (align === 'center') {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabelBox(ctx, opts, item) {\n    const { left , top , right , bottom  } = item;\n    const { backdropColor  } = opts;\n    if (!isNullOrUndef(backdropColor)) {\n        const borderRadius = toTRBLCorners(opts.borderRadius);\n        const padding = toPadding(opts.backdropPadding);\n        ctx.fillStyle = backdropColor;\n        const backdropLeft = left - padding.left;\n        const backdropTop = top - padding.top;\n        const backdropWidth = right - left + padding.width;\n        const backdropHeight = bottom - top + padding.height;\n        if (Object.values(borderRadius).some((v)=>v !== 0)) {\n            ctx.beginPath();\n            addRoundedRectPath(ctx, {\n                x: backdropLeft,\n                y: backdropTop,\n                w: backdropWidth,\n                h: backdropHeight,\n                radius: borderRadius\n            });\n            ctx.fill();\n        } else {\n            ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n        }\n    }\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx , options: { pointLabels  }  } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const item = scale._pointLabelItems[i];\n        if (!item.visible) {\n            continue;\n        }\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        drawPointLabelBox(ctx, optsAtIndex, item);\n        const plFont = toFont(optsAtIndex.font);\n        const { x , y , textAlign  } = item;\n        renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: 'middle'\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx  } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color , lineWidth  } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(borderOpts.dash);\n    ctx.lineDashOffset = borderOpts.dashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return createContext(parent, {\n        label,\n        index,\n        type: 'pointLabel'\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    static id = 'radialLinear';\n static defaults = {\n        display: true,\n        animate: true,\n        position: 'chartArea',\n        angleLines: {\n            display: true,\n            lineWidth: 1,\n            borderDash: [],\n            borderDashOffset: 0.0\n        },\n        grid: {\n            circular: false\n        },\n        startAngle: 0,\n        ticks: {\n            showLabelBackdrop: true,\n            callback: Ticks.formatters.numeric\n        },\n        pointLabels: {\n            backdropColor: undefined,\n            backdropPadding: 2,\n            display: true,\n            font: {\n                size: 10\n            },\n            callback (label) {\n                return label;\n            },\n            padding: 5,\n            centerPointLabels: false\n        }\n    };\n    static defaultRoutes = {\n        'angleLines.color': 'borderColor',\n        'pointLabels.color': 'color',\n        'ticks.color': 'color'\n    };\n    static descriptors = {\n        angleLines: {\n            _fallback: 'grid'\n        }\n    };\n    constructor(cfg){\n        super(cfg);\n         this.xCenter = undefined;\n         this.yCenter = undefined;\n         this.drawingArea = undefined;\n         this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n    setDimensions() {\n        const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min , max  } = this.getMinMax(false);\n        this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n        this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = callback(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : '';\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = TAU / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if (isNullOrUndef(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if (isNullOrUndef(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n        const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left , top , right , bottom  } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n drawBackground() {\n        const { backgroundColor , grid: { circular  }  } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines , grid , border  } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0 || index === 0 && this.min < 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const context = this.getContext(index);\n                    const optsAtIndex = grid.setContext(context);\n                    const optsAtIndexBorder = border.setContext(context);\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color , lineWidth  } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n drawBorder() {}\n drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && this.min >= 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = toFont(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = toPadding(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            renderText(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color,\n                strokeColor: optsAtIndex.textStrokeColor,\n                strokeWidth: optsAtIndex.textStrokeWidth\n            });\n        });\n        ctx.restore();\n    }\n drawTitle() {}\n}\n\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\n const UNITS =  /* #__PURE__ */ Object.keys(INTERVALS);\n function sorter(a, b) {\n    return a - b;\n}\n function parse(scale, input) {\n    if (isNullOrUndef(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser , round , isoWeekday  } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === 'function') {\n        value = parser(value);\n    }\n    if (!isNumberFinite(value)) {\n        value = typeof parser === 'string' ? adapter.parse(value,  parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, 'isoWeek', isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\n function determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\n function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n function determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\n function addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo , hi  } = _lookup(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\n function setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\n function ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n     const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    static id = 'time';\n static defaults = {\n bounds: 'data',\n        adapters: {},\n        time: {\n            parser: false,\n            unit: false,\n            round: false,\n            isoWeekday: false,\n            minUnit: 'millisecond',\n            displayFormats: {}\n        },\n        ticks: {\n source: 'auto',\n            callback: false,\n            major: {\n                enabled: false\n            }\n        }\n    };\n constructor(props){\n        super(props);\n         this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n         this._unit = 'day';\n         this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n    init(scaleOpts, opts = {}) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n         const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        mergeIf(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || 'day';\n        let { min , max , minDefined , maxDefined  } = this.getUserBounds();\n function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === 'ticks' && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = _filterBetween(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n initOffsets(timestamps = []) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = _limitValue(start, 0, limit);\n        end = _limitValue(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n        const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n        const hasWeekday = isNumber(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, 'isoWeek', weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n        }\n        const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === 'ticks' || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort(sorter).map((x)=>+x);\n    }\n getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n format(value, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const fmt = format || formats[unit];\n        return this._adapter.format(value, fmt);\n    }\n _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formatter = options.ticks.callback;\n        if (formatter) {\n            return callback(formatter, [\n                time,\n                index,\n                ticks\n            ], this);\n        }\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n    }\n generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n normalize(values) {\n        return _arrayUnique(values.sort(sorter));\n    }\n}\n\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo , hi  } = _lookupByKey(table, 'pos', val));\n        }\n        ({ pos: prevSource , time: prevTarget  } = table[lo]);\n        ({ pos: nextSource , time: nextTarget  } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo , hi  } = _lookupByKey(table, 'time', val));\n        }\n        ({ time: prevSource , pos: prevTarget  } = table[lo]);\n        ({ time: nextSource , pos: nextTarget  } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    static id = 'timeseries';\n static defaults = TimeScale.defaults;\n constructor(props){\n        super(props);\n         this._table = [];\n         this._minPos = undefined;\n         this._tableRange = undefined;\n    }\n initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n buildLookupTable(timestamps) {\n        const { min , max  } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n _generate() {\n        const min = this.min;\n        const max = this.max;\n        let timestamps = super.getDataTimestamps();\n        if (!timestamps.includes(min) || !timestamps.length) {\n            timestamps.splice(0, 0, min);\n        }\n        if (!timestamps.includes(max) || timestamps.length === 1) {\n            timestamps.push(max);\n        }\n        return timestamps.sort((a, b)=>a - b);\n    }\n _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n}\n\nvar scales = /*#__PURE__*/Object.freeze({\n__proto__: null,\nCategoryScale: CategoryScale,\nLinearScale: LinearScale,\nLogarithmicScale: LogarithmicScale,\nRadialLinearScale: RadialLinearScale,\nTimeScale: TimeScale,\nTimeSeriesScale: TimeSeriesScale\n});\n\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n\nexport { Animation, Animations, ArcElement, BarController, BarElement, BasePlatform, BasicPlatform, BubbleController, CategoryScale, Chart, plugin_colors as Colors, DatasetController, plugin_decimation as Decimation, DomPlatform, DoughnutController, Element, index as Filler, Interaction, plugin_legend as Legend, LineController, LineElement, LinearScale, LogarithmicScale, PieController, PointElement, PolarAreaController, RadarController, RadialLinearScale, Scale, ScatterController, plugin_subtitle as SubTitle, Ticks, TimeScale, TimeSeriesScale, plugin_title as Title, plugin_tooltip as Tooltip, adapters as _adapters, _detectPlatform, animator, controllers, defaults, elements, layouts, plugins, registerables, registry, scales };\n//# sourceMappingURL=chart.js.map\n","import {Chart, registerables} from '../dist/chart.js';\n\nChart.register(...registerables);\n\nexport * from '../dist/chart.js';\nexport default Chart;\n"],"names":["activeEffectScope","activeEffect","EffectScope","constructor","detached","this","_active","effects","cleanups","parent","index","scopes","push","active","run","fn","currentEffectScope","on","off","stop","fromParent","i","l","length","last","pop","recordEffectScope","effect","scope","getCurrentScope","ReactiveEffect","trigger","scheduler","deps","_dirtyLevel","_trackId","_runnings","_shouldSchedule","_depsLength","dirty","pauseTracking","dep","computed","triggerComputed","resetTracking","v","lastShouldTrack","shouldTrack","lastEffect","preCleanupEffect","postCleanupEffect","onStop","value","effect2","cleanupDepEffect","trackId","get","delete","size","cleanup","pauseScheduleStack","trackStack","pauseScheduling","resetScheduling","queueEffectSchedulers","shift","trackEffect","debuggerEventExtraInfo","set","oldDep","triggerEffects","dirtyLevel","keys","tracking","allowRecurse","createDep","Map","targetMap","WeakMap","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","track","target","type","key","depsMap","newValue","oldValue","oldTarget","values","newLength","Number","forEach","key2","isNonTrackableKeys","builtInSymbols","Set","Object","getOwnPropertyNames","filter","map","arrayInstrumentations","createArrayInstrumentations","instrumentations","args","arr","toRaw","res","apply","hasOwnProperty","String","obj","BaseReactiveHandler","_isReadonly","_isShallow","receiver","isReadonly2","isShallow2","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","getPrototypeOf","targetIsArray","Reflect","has","isRef","readonly","reactive","MutableReactiveHandler","super","isOldValueReadonly","isReadonly","isShallow","hadKey","result","deleteProperty","ownKeys","ReadonlyReactiveHandler","mutableHandlers","readonlyHandlers","shallowReactiveHandlers","toShallow","getProto","rawTarget","rawKey","has2","wrap","toReadonly","toReactive","call","add","proto","get2","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations2","shallowInstrumentations2","readonlyInstrumentations2","shallowReadonlyInstrumentations2","iteratorMethods","mutableInstrumentations","readonlyInstrumentations","shallowInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","shallow","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","raw","markRaw","ComputedRefImpl","getter","_setter","isSSR","__v_isRef","_value","triggerRefValue","_cacheable","self","trackRefValue","_dirty","getterOrOptions","debugOptions","setter","onlyGetter","cRef","ref2","_a","newVal","r","ref","createRef","rawValue","RefImpl","__v_isShallow","_rawValue","useDirectValue","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","callWithErrorHandling","instance","err","handleError","callWithAsyncErrorHandling","catch","throwInDev","contextVNode","vnode","cur","exposedInstance","errorInfo","errorCapturedHooks","ec","appErrorHandler","appContext","config","errorHandler","logError","console","error","isFlushing","isFlushPending","queue","flushIndex","pendingPostFlushCbs","activePostFlushCbs","postFlushIndex","resolvedPromise","Promise","resolve","currentFlushPromise","nextTick","p","then","bind","findInsertionIndex","id","start","end","middle","middleJob","middleJobId","getId","pre","queueJob","job","includes","splice","queueFlush","flushJobs","invalidateJob","indexOf","queuePostFlushCb","cb","flushPreFlushCbs","seen","uid","flushPostFlushCbs","deduped","sort","a","b","Infinity","comparator","diff","emit","event","rawArgs","isUnmounted","props","isModelListener","startsWith","modelArg","slice","modifiersKey","number","trim","handlerName","handler","onceHandler","emitted","normalizeEmitsOptions","comp","asMixin","cache","emitsCache","cached","emits","normalized","hasExtends","extendEmits","raw2","normalizedFromExtend","mixins","extends","isEmitListener","options","replace","toLowerCase","currentRenderingInstance","currentScopeId","setCurrentRenderingInstance","prev","__scopeId","pushScopeId","popScopeId","withCtx","ctx","isNonScopedSlot","_n","renderFnWithContext","_d","setBlockTracking","prevInstance","_c","renderComponentRoot","Component","withProxy","propsOptions","slots","attrs","render","renderCache","data","setupState","inheritAttrs","fallthroughAttrs","shapeFlag","proxyToUse","thisProxy","normalizeVNode","render2","getFunctionalFallthrough","blockStack","createVNode","Comment","root","some","filterModelListeners","cloneVNode","dirs","concat","transition","shouldUpdateComponent","prevVNode","nextVNode","optimized","prevProps","children","prevChildren","component","nextProps","nextChildren","patchFlag","emitsOptions","$stable","hasPropsChanged","dynamicProps","nextKeys","updateHOCHostEl","el","subTree","suspense","activeBranch","COMPONENTS","resolveComponent","name","maybeSelfReference","resolveAsset","NULL_DYNAMIC_COMPONENT","for","warnMissing","currentInstance","selfName","getComponentName","registry","isSuspense","__isSuspense","queueEffectWithSuspense","pendingBranch","ssrContextKey","useSSRContext","inject","INITIAL_WATCHER_VALUE","watch","source","doWatch","immediate","deep","flush","once","onTrack","onTrigger","_cb","unwatch","reactiveGetter","source2","traverse","forceTrigger","isMultiSource","s","onCleanup","baseGetter","ssrCleanup","isInSSRComponentSetup","__watcherHandles","Array","fill","queuePostRenderEffect","instanceWatch","publicThis","createPathGetter","reset","setCurrentInstance","path","segments","split","depth","withDirectives","directives","getExposeProxy","bindings","dir","arg","modifiers","mounted","updated","invokeDirectiveHook","oldBindings","binding","hook","leaveCbKey","enterCbKey","useTransitionState","state","isMounted","isLeaving","isUnmounting","leavingVNodes","onMounted","onBeforeUnmount","TransitionHookValidator","Function","BaseTransitionPropsValidators","mode","appear","Boolean","persisted","onBeforeEnter","onEnter","onAfterEnter","onEnterCancelled","onBeforeLeave","onLeave","onAfterLeave","onLeaveCancelled","onBeforeAppear","onAppear","onAfterAppear","onAppearCancelled","BaseTransitionImpl","setup","getCurrentInstance","default","getTransitionRawChildren","child","hasFound","c","rawProps","emptyPlaceholder","innerChild","getKeepAliveChild","enterHooks","resolveTransitionHooks","setTransitionHooks","oldChild","oldInnerChild","isSameVNodeType","leavingHooks","afterLeave","update","delayLeave","earlyRemove","delayedLeave","leavingVNodesCache","getLeavingNodesForType","BaseTransition","create","callHook","callAsyncHook","every","hook2","hooks","beforeEnter","leavingVNode","enter","afterHook","cancelHook","called","cancelled","leave","remove","clone","vnode2","isKeepAlive","ssContent","ssFallback","keepComment","parentKey","ret","keyedFragmentCount","Fragment","isAsyncWrapper","__asyncLoader","__isKeepAlive","RegExp","matches","pattern","test","onActivated","registerKeepAliveHook","onDeactivated","wrappedHook","__wdc","current","isDeactivated","injectHook","injectToKeepAliveRoot","keepAliveRoot","injected","onUnmounted","resetShapeFlag","getInnerChild","prepend","__weh","unshift","createHook","lifecycle","onBeforeMount","onBeforeUpdate","onUpdated","onServerPrefetch","onRenderTriggered","onRenderTracked","onErrorCaptured","renderList","renderItem","from","item","getPublicInstance","isStatefulComponent","publicPropertiesMap","$","$el","$data","$props","$attrs","$slots","$refs","refs","$parent","$root","$emit","$options","resolveMergedOptions","$forceUpdate","f","$nextTick","n","$watch","hasSetupBinding","__isScriptSetup","PublicInstanceProxyHandlers","_","accessCache","normalizedProps","shouldCacheAccess","publicGetter","cssModule","globalProperties","__cssModules","defineProperty","descriptor","normalizePropsOrEmits","reduce","applyOptions","beforeCreate","dataOptions","computedOptions","methods","watchOptions","provide","provideOptions","injectOptions","created","beforeMount","beforeUpdate","activated","deactivated","beforeDestroy","beforeUnmount","destroyed","unmounted","renderTracked","renderTriggered","errorCaptured","serverPrefetch","expose","components","filters","checkDuplicateProperties","resolveInjections","methodHandler","opt","enumerable","configurable","createWatcher","provides","registerLifecycleHook","register","_hook","exposed","val","normalizeInject","h","base","extendsOptions","globalMixins","optionsCache","optionMergeStrategies","resolved","m","mergeOptions","to","strats","strat","internalOptionMergeStrats","mergeDataFn","mergeEmitsOrPropsOptions","mergeObjectOptions","mergeAsArray","mergeWatchOptions","mergeInject","merged","createAppContext","app","isNativeTag","NO","performance","warnHandler","compilerOptions","propsCache","uid$1","createAppAPI","hydrate","rootComponent","rootProps","context","installedPlugins","WeakSet","_uid","_component","_props","_container","_context","_instance","version","use","plugin","install","mixin","directive","mount","rootContainer","isHydrate","namespace","__vue_app__","unmount","runWithContext","lastApp","currentApp","parentProvides","defaultValue","treatDefaultAsFactory","arguments","internalObjectProto","createInternalObject","isInternalObject","initProps","isStateful","propsDefaults","setFullProps","updateProps","rawPrevProps","rawCurrentProps","hasAttrsChanged","kebabKey","resolvePropValue","propsToUpdate","camelizedKey","needCastKeys","rawCastValues","camelKey","castValues","isAbsent","hasDefault","skipFactory","normalizePropsOptions","extendProps","normalizedKey","validatePropName","prop","booleanIndex","getTypeIndex","stringIndex","getType","ctor","isSameType","expectedTypes","findIndex","t","isInternalKey","normalizeSlotValue","normalizeSlot","rawSlot","normalizeObjectSlots","rawSlots","_ctx","normalizeVNodeSlots","initSlots","updateSlots","needDeletionCheck","deletionComparisonTarget","setRef","rawRef","oldRawRef","parentSuspense","isUnmount","refValue","owner","oldRef","_isString","_isRef","doSet","existing","k","initFeatureFlags","__VUE_PROD_HYDRATION_MISMATCH_DETAILS__","createRenderer","baseCreateRenderer","createHydrationFns","__VUE__","insert","hostInsert","hostRemove","patchProp","hostPatchProp","createElement","hostCreateElement","createText","hostCreateText","createComment","hostCreateComment","setText","hostSetText","setElementText","hostSetElementText","parentNode","hostParentNode","nextSibling","hostNextSibling","setScopeId","hostSetScopeId","insertStaticContent","hostInsertStaticContent","patch","n1","n2","container","anchor","parentComponent","slotScopeIds","dynamicChildren","getNextHostNode","Text","processText","processCommentNode","Static","mountStaticNode","processFragment","processElement","processComponent","process","internals","moveStaticNode","removeStaticNode","mountElement","patchElement","vnodeHook","is","mountChildren","resolveChildrenNamespace","scopeId","unmountChildren","onVnodeBeforeMount","invokeVNodeHook","needCallTransitionHooks","needTransition","onVnodeMounted","parentVNode","cloneIfMounted","oldProps","newProps","toggleRecurse","onVnodeBeforeUpdate","patchBlockChildren","patchChildren","patchProps","class","style","onVnodeUpdated","oldChildren","newChildren","fallbackContainer","oldVNode","newVNode","fragmentStartAnchor","fragmentEndAnchor","fragmentSlotScopeIds","traverseStaticChildren","activate","mountComponent","updateComponent","initialVNode","createComponentInstance","renderer","setupComponent","asyncDep","registerDep","setupRenderEffect","placeholder","asyncResolved","updateComponentPreRender","componentUpdateFn","bu","u","nonHydratedAsyncRoot","locateNonHydratedAsyncRoot","originNext","nextTree","prevTree","bm","isAsyncWrapperVNode","hydrateNode","hydrateSubTree","scopedInitialVNode","c1","prevShapeFlag","c2","patchKeyedChildren","patchUnkeyedChildren","oldLength","commonLength","Math","min","nextChild","parentAnchor","l2","e1","e2","nextPos","s1","s2","keyToNewIndexMap","j","patched","toBePatched","moved","maxNewIndexSoFar","newIndexToOldIndexMap","prevChild","newIndex","increasingNewIndexSequence","getSequence","nextIndex","move","moveType","needTransition2","remove2","performLeave","doRemove","deactivate","shouldInvokeDirs","shouldInvokeVnodeHook","onVnodeBeforeUnmount","unmountComponent","onVnodeUnmounted","removeFragment","performRemove","bum","um","suspenseId","pendingId","_vnode","mt","mc","pc","pbc","o","createApp","currentNamespace","encoding","allowed","ch1","ch2","len","arrI","subComponent","isTeleport","__isTeleport","currentBlock","openBlock","disableTracking","closeBlock","isBlockTreeEnabled","setupBlock","createElementBlock","createBaseVNode","isVNode","__v_isVNode","normalizeKey","normalizeRef","ref_key","ref_for","isBlockNode","needFullChildrenNormalization","__v_skip","targetAnchor","staticCount","normalizeChildren","normalize","_createVNode","cloned","isClassComponent","__vccOpts","guardReactiveProps","klass","extraProps","mergeRef","cloneTransition","mergedProps","mergeProps","ce","createTextVNode","text","flag","memo","slot","slotFlag","toMerge","incoming","emptyAppContext","exposeProxy","setupContext","attrsProxy","slotsProxy","bc","da","rtg","rtc","sp","internalSetCurrentInstance","setInSSRSetupState","g","registerGlobalSetter","setters","unsetCurrentInstance","compile","installWithProxy","setupResult","setupStatefulComponent","createSetupContext","resolvedResult","handleSetupResult","e","finishComponentSetup","__ssrInlineRender","ssrRender","skipOptions","template","isCustomElement","delimiters","componentCompilerOptions","finalCompilerOptions","attrsProxyHandlers","includeInferred","displayName","__name","propsOrChildren","prototype","svgNS","mathmlNS","doc","document","templateContainer","nodeOps","insertBefore","removeChild","tag","createElementNS","multiple","setAttribute","createTextNode","node","nodeValue","textContent","querySelector","selector","content","before","previousSibling","lastChild","cloneNode","innerHTML","wrapper","firstChild","appendChild","TRANSITION","ANIMATION","vtcKey","Transition","resolveTransitionProps","DOMTransitionPropsValidators","css","duration","enterFromClass","enterActiveClass","enterToClass","appearFromClass","appearActiveClass","appearToClass","leaveFromClass","leaveActiveClass","leaveToClass","TransitionPropsValidators","h2","hasExplicitCallback","baseProps","durations","normalizeDuration","enterDuration","leaveDuration","finishEnter","isAppear","removeTransitionClass","finishLeave","_isLeaving","makeEnterHook","nextFrame","addTransitionClass","whenTransitionEnds","forceReflow","NumberOf","cls","classList","_vtc","requestAnimationFrame","endId","expectedType","explicitTimeout","_endId","resolveIfNotStale","setTimeout","timeout","propCount","getTransitionInfo","endEvent","ended","removeEventListener","onEnd","addEventListener","styles","window","getComputedStyle","getStyleProperties","transitionDelays","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationDurations","animationTimeout","max","hasTransform","toString","delays","d","toMs","body","offsetHeight","patchClass","isSVG","transitionClasses","join","removeAttribute","className","vShowOriginalDisplay","vShowHidden","CSS_VAR_TEXT","displayRE","patchStyle","isCssString","hasControlledDisplay","prevStyle","setStyle","cssVarText","cssText","display","importantRE","setProperty","prefixed","autoPrefix","prefixes","prefixCache","rawName","xlinkNS","patchAttr","removeAttributeNS","setAttributeNS","isBoolean","patchDOMProp","tagName","getAttribute","needRemove","veiKey","patchEvent","prevValue","nextValue","invokers","existingInvoker","parseName","invoker","createInvoker","optionsModifierRE","match","cachedNow","getNow","Date","now","initialValue","_vts","attached","patchStopImmediatePropagation","originalStop","stopImmediatePropagation","_stopped","isNativeOn","charCodeAt","shouldSetAsProp","_trueValue","_falseValue","HTMLElement","positionMap","newPositionMap","moveCbKey","TransitionGroupImpl","moveClass","hasCSSTransform","callPendingCbs","recordPosition","movedChildren","applyTranslation","transform","webkitTransform","transitionDuration","propertyName","cssTransitionProps","Element","getBoundingClientRect","oldPos","newPos","dx","left","dy","top","nodeType","getModelAssigner","onCompositionStart","composing","onCompositionEnd","dispatchEvent","Event","assignKey","vModelText","lazy","castToNumber","domValue","elValue","activeElement","systemModifiers","modifierGuards","stopPropagation","prevent","preventDefault","currentTarget","ctrl","ctrlKey","shiftKey","alt","altKey","meta","metaKey","button","right","exact","withModifiers","_withMods","cacheKey","guard","rendererOptions","ensureRenderer","containerOrSelector","normalizeContainer","resolveRootNamespace","SVGElement","MathMLElement","makeMap","str","expectsLowerCase","EMPTY_OBJ","EMPTY_ARR","NOOP","isOn","extend","assign","hasOwn","isArray","isMap","toTypeString","isSet","isDate","isRegExp","isFunction","isString","isSymbol","isObject","isPromise","objectToString","toRawType","isPlainObject","isIntegerKey","parseInt","isReservedProp","cacheStringFunction","hit","camelizeRE","camelize","toUpperCase","hyphenateRE","hyphenate","capitalize","charAt","toHandlerKey","hasChanged","invokeArrayFns","fns","def","writable","looseToNumber","parseFloat","isNaN","toNumber","NaN","_globalThis","getGlobalThis","globalThis","GLOBALS_ALLOWED","isGloballyAllowed","normalizeStyle","parseStringStyle","listDelimiterRE","propertyDelimiterRE","styleCommentRE","tmp","normalizeClass","specialBooleanAttrs","isSpecialBooleanAttr","includeBooleanAttr","looseCompareArrays","equal","looseEqual","aValidType","bValidType","getTime","aKeysCount","bKeysCount","aHasKey","bHasKey","looseIndexOf","toDisplayString","JSON","stringify","replacer","_key","entries","val2","stringifySymbol","description","exports","sfc","isCallable","tryToString","$TypeError","TypeError","module","argument","$String","toIndexedObject","toAbsoluteIndex","lengthOfArrayLike","createMethod","IS_INCLUDES","$this","fromIndex","O","DESCRIPTORS","getOwnPropertyDescriptor","SILENT_ON_NON_WRITABLE_LENGTH_SET","undefined","uncurryThis","stringSlice","it","getOwnPropertyDescriptorModule","definePropertyModule","exceptions","createPropertyDescriptor","object","bitmap","makeBuiltIn","defineGlobalProperty","simple","global","unsafe","nonConfigurable","nonWritable","fails","EXISTS","MAX_SAFE_INTEGER","navigator","userAgent","Deno","versions","v8","createNonEnumerableProperty","defineBuiltIn","copyConstructorProperties","isForced","FORCED","targetProperty","sourceProperty","TARGET","GLOBAL","STATIC","stat","dontCallGetSet","forced","sham","exec","NATIVE_BIND","FunctionPrototype","getDescriptor","PROPER","CONFIGURABLE","uncurryThisWithBind","aFunction","aCallable","isNullOrUndefined","V","P","func","check","toObject","classof","$Object","propertyIsEnumerable","store","functionToString","inspectSource","NATIVE_WEAK_MAP","shared","sharedKey","hiddenKeys","OBJECT_ALREADY_INITIALIZED","enforce","getterFor","TYPE","metadata","facade","STATE","documentAll","all","replacement","feature","detection","POLYFILL","NATIVE","string","getBuiltIn","isPrototypeOf","USE_SYMBOL_AS_UID","$Symbol","toLength","CONFIGURABLE_FUNCTION_NAME","InternalStateModule","enforceInternalState","getInternalState","CONFIGURABLE_LENGTH","TEMPLATE","arity","ceil","floor","trunc","x","IE8_DOM_DEFINE","V8_PROTOTYPE_DEFINE_BUG","anObject","toPropertyKey","$defineProperty","$getOwnPropertyDescriptor","ENUMERABLE","WRITABLE","Attributes","propertyIsEnumerableModule","internalObjectKeys","enumBugKeys","getOwnPropertySymbols","names","$propertyIsEnumerable","NASHORN_BUG","input","pref","valueOf","getOwnPropertyNamesModule","getOwnPropertySymbolsModule","IS_PURE","SHARED","copyright","license","V8_VERSION","symbol","toIntegerOrInfinity","integer","IndexedObject","requireObjectCoercible","getMethod","ordinaryToPrimitive","wellKnownSymbol","TO_PRIMITIVE","exoticToPrim","toPrimitive","postfix","random","NATIVE_SYMBOL","WellKnownSymbolsStore","createWellKnownSymbol","withoutSetter","setArrayLength","doesNotExceedSafeInteger","INCORRECT_TO_LENGTH","properErrorOnNonWritableLength","argCount","round","lim","p2b","n2b","b2n","n2p","map$1","A","B","C","D","E","F","hex","h1","eq","isShort","hexParse","alpha","hexString","HUE_RE","hsl2rgbn","hsv2rgbn","hwb2rgbn","w","rgb","hueValue","rgb2hsl","range","calln","hsl2rgb","hwb2rgb","hsv2rgb","hue","hueParse","p1","p2","rotate","deg","hslString","Z","Y","X","W","U","T","S","R","Q","N","M","L","K","G","H","I","J","names$1","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","unpack","unpacked","tkeys","ok","nk","nameParse","transparent","RGB_RE","rgbParse","rgbString","pow","interpolate","rgb1","rgb2","modHSL","ratio","fromObject","functionParse","Color","_rgb","_valid","valid","mix","color","weight","w2","w1","clearer","greyscale","opaquer","negate","lighten","darken","saturate","desaturate","noop","isNullOrUndef","isNumberFinite","isFinite","finiteOrDefault","valueOrDefault","toPercentage","dimension","endsWith","toDimension","each","loopable","reverse","_elementsEqual","a0","a1","ilen","v0","v1","datasetIndex","klen","isValidKey","_merger","tval","sval","merge","sources","merger","mergeIf","_mergerIf","keyResolvers","y","_splitKey","parts","part","_getKeyResolver","resolveObjectKey","resolver","_capitalize","defined","setsEqual","_isClickEvent","PI","TAU","PITAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","almostEquals","epsilon","abs","niceNum","roundedRange","niceRange","fraction","niceFraction","_factorize","sqrt","isNumber","almostWhole","rounded","_setMinAndMaxByKey","array","property","toRadians","degrees","toDegrees","radians","_decimalPlaces","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","angle","atan2","distance","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_int16Range","_isBetween","_lookup","table","cmp","mid","hi","lo","_lookupByKey","ti","_rlookupByKey","_filterBetween","arrayEvents","listenArrayEvents","listener","_chartjs","listeners","unlistenArrayEvents","stub","_arrayUnique","items","requestAnimFrame","throttled","argsToUse","ticking","debounce","delay","clearTimeout","_toLeftRightCenter","align","_alignStartEnd","_textX","rtl","_getStartAndCountOfVisiblePoints","points","animationsDisabled","pointCount","count","_sorted","iScale","_parsed","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","_scaleRangesChanged","xScale","yScale","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","changed","atEdge","elasticIn","sin","elasticOut","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","cos","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","isPatternOrGradient","getHoverColor","numbers","colors","applyAnimationsDefaults","defaults","easing","loop","describe","_fallback","_indexable","_scriptable","properties","animation","resize","show","animations","visible","hide","applyLayoutsDefaults","autoPadding","padding","bottom","intlCache","getNumberFormat","locale","formatter","Intl","NumberFormat","formatNumber","num","format","formatters","numeric","tickValue","ticks","chart","notation","delta","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","remain","significand","Ticks","applyScaleDefaults","offset","beginAtZero","bounds","clip","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","tickColor","border","dash","dashOffset","width","title","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","minor","major","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","route","overrides","descriptors","getScope$1","Defaults","_descriptors","_appliers","backgroundColor","borderColor","datasets","devicePixelRatio","platform","getDevicePixelRatio","elements","events","font","family","lineHeight","hover","hoverBackgroundColor","hoverBorderColor","hoverColor","indexAxis","interaction","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","override","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","local","appliers","toFontString","_measureText","gc","longest","textWidth","measureText","_longestText","arrayOfThings","garbageCollect","save","jlen","thing","nestedThing","restore","gcLen","_alignPixel","pixel","currentDevicePixelRatio","halfWidth","clearCanvas","canvas","getContext","resetTransform","clearRect","height","drawPoint","drawPointLegend","xOffset","yOffset","cornerRadius","xOffsetW","yOffsetW","pointStyle","rotation","radius","rad","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","lineTo","SQRT1_2","rect","borderWidth","stroke","_isPointInArea","point","area","margin","clipArea","unclipArea","_steppedLineTo","previous","flip","midpoint","_bezierCurveTo","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","setRenderOpts","opts","translation","fillStyle","textAlign","textBaseline","decorateText","line","strikethrough","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","strokeStyle","decorationWidth","drawBackdrop","oldColor","fillRect","renderText","lines","strokeWidth","strokeColor","backdrop","strokeText","maxWidth","fillText","addRoundedRectPath","topLeft","bottomLeft","bottomRight","topRight","LINE_HEIGHT","FONT_STYLE","toLineHeight","numberOrZero","_readValueToProps","objProps","read","toTRBL","toTRBLCorners","toPadding","toFont","fallback","warn","inputs","info","cacheable","_addGrace","minmax","change","keepZero","createContext","parentContext","_createResolver","rootScopes","getTarget","finalRootScopes","_resolve","toStringTag","_scopes","_rootScopes","_getTarget","_keys","_cached","_resolveWithPrefixes","getKeysFromAllScopes","storage","_storage","_attachContext","subProxy","descriptorDefaults","_proxy","_subProxy","_stack","setContext","_resolveWithContext","allKeys","scriptable","indexable","_allKeys","isScriptable","isIndexable","readKey","prefix","needsSubResolver","_resolveScriptable","_resolveArray","getValue","Error","createSubResolver","resolveFallback","getScope","addScopes","parentScopes","parentFallback","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","_parseObjectDataRadialScale","_parsing","parsed","parse","EPSILON","getPoint","skip","getValueAxis","splineCurve","firstPoint","middlePoint","afterPoint","d01","d12","s01","s12","fa","fb","monotoneAdjust","deltaK","mK","pointsLen","alphaK","betaK","tauK","squaredMagnitude","pointCurrent","pointAfter","monotoneCompute","valueAxis","pointBefore","iPixel","vPixel","splineCurveMonotone","slopeDelta","capControlPoint","pt","capBezierPoints","inArea","inAreaPrev","inAreaNext","_updateBezierControlPoints","controlPoints","spanGaps","cubicInterpolationMode","tension","_isDomSupported","_getParentNode","domNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","element","ownerDocument","defaultView","getStyle","getPropertyValue","positions","getPositionedStyle","suffix","pos","useOffsetPos","shadowRoot","getCanvasPosition","touches","offsetX","offsetY","box","clientX","clientY","getRelativePosition","borderBox","boxSizing","paddings","borders","getContainerSize","maxHeight","containerStyle","containerBorder","containerPadding","clientWidth","clientHeight","round1","getMaximumSize","bbWidth","bbHeight","aspectRatio","margins","containerSize","maintainHeight","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","supportsEventListenerOptions","passiveSupported","passive","readUsedSize","_pointInLine","_steppedInterpolation","_bezierInterpolation","cp1","cp2","getRightToLeftAdapter","rectX","setWidth","xPlus","leftForLtr","itemWidth","getLeftToRightAdapter","_itemWidth","getRtlAdapter","overrideTextDirection","direction","original","getPropertyPriority","prevTextDirection","restoreTextDirection","propertyFn","between","compare","normalizeSegment","getSegment","segment","startBound","endBound","_boundSegment","inside","subStart","startIsBefore","endIsBefore","shouldStart","shouldStop","_boundSegments","sub","findStartAndEnd","solidSegments","_computeSegments","segmentOptions","_loop","splitByStyles","completeLoop","_fullLoop","doSplitByStyles","chartContext","_chart","baseStyle","readStyle","_datasetIndex","addStyle","st","p0","p0DataIndex","p1DataIndex","styleChanged","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","Animator","_request","_charts","_running","_lastDate","_notify","anims","date","callbacks","numSteps","initial","currentStep","_refresh","_update","remaining","running","draw","_total","tick","_getAnims","charts","complete","progress","listen","acc","_duration","cancel","animator","interpolators","boolean","factor","c0","Animation","cfg","currentValue","_fn","_easing","_start","_target","_prop","_from","_to","_promises","elapsed","wait","promises","rej","Animations","_properties","configure","animationOptions","animatedProps","option","_animateOptions","newOptions","resolveTargetOptions","_createAnimations","$shared","awaitAll","$animations","anim","scaleClip","allowedOverflow","defaultClip","toClip","disabled","getSortedDatasetIndices","filterVisible","metasets","_getSortedDatasetMetas","applyStack","stack","dsIndex","singleMode","otherValue","convertObjectDataToArray","vScale","iAxisKey","vAxisKey","adata","isStacked","stacked","getStackKey","indexScale","valueScale","NEGATIVE_INFINITY","getOrCreateStack","stacks","stackKey","indexValue","subStack","getLastIndexInStack","positive","getMatchingVisibleMetas","updateStacks","controller","_cachedMeta","_stacks","iAxis","vAxis","itemStacks","_top","_bottom","visualValues","_visualValues","getFirstScaleId","createDatasetContext","dataset","createDataContext","dataIndex","clearStacks","isDirectUpdateMode","cloneIfNotShared","createStack","canStack","hidden","_stacked","DatasetController","static","_cachedDataOpts","getMeta","_type","_data","_objectData","_sharedOptions","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","datasetElementType","dataElementType","initialize","linkScales","addElements","isPluginEnabled","updateIndex","getDataset","chooseId","xid","xAxisID","yid","yAxisID","rid","rAxisID","iid","iAxisID","vid","vAxisID","getScaleForId","rScale","getDatasetMeta","scaleID","_getOtherScale","_destroy","_dataCheck","buildOrUpdateElements","resetNewElements","stackChanged","oldStacked","_resyncElements","scopeKeys","datasetScopeKeys","getOptionScopes","createResolver","sorted","parseArrayData","parseObjectData","parsePrimitiveData","isNotInOrderComparedToPrev","labels","getLabels","singleScale","xAxisKey","yAxisKey","getParsed","getDataElement","updateRangeFromParsed","parsedValue","getMinMax","otherScale","otherMin","otherMax","_skip","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","chartArea","resolveDatasetElementOptions","resolveDataElementOptions","_resolveElementOptions","elementType","sharing","datasetElementScopeKeys","resolveNamedOptions","freeze","_resolveAnimations","datasetAnimationScopeKeys","getSharedOptions","includeOptions","sharedOptions","_animationsDisabled","_getSharedOptions","firstOpts","previouslySharedOptions","updateSharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","arg1","arg2","numMeta","numData","_insertElements","_removeElements","updateElements","removed","_sync","_dataChanges","_onDataPush","_onDataPop","_onDataShift","_onDataSplice","newCount","_onDataUnshift","getAllScaleValues","_cache","$bar","visibleMetas","computeMinSampleSize","curr","_length","updateMinAndPrev","getPixelForTick","computeFitCategoryTraits","ruler","stackCount","thickness","barThickness","categoryPercentage","barPercentage","chunk","pixels","computeFlexCategoryTraits","percent","parseFloatBar","entry","startValue","endValue","barStart","barEnd","_custom","parseValue","parseArrayOrPrimitive","isFloatBar","custom","barSign","actualBase","isHorizontal","borderProps","horizontal","setBorderSkipped","edge","borderSkipped","enableBorderRadius","parseEdge","swap","startEnd","orig","v2","setInflateAmount","inflateAmount","BarController","grouped","_index_","_value_","bars","getBasePixel","_getRuler","vpixels","head","_calculateBarValuePixels","ipixels","_calculateBarIndexPixels","center","_getStacks","skipNull","_getStackCount","_getStackIndex","_startPixel","_endPixel","baseValue","minBarLength","floating","getDataVisibility","startPixel","getPixelForDecimal","endPixel","getValueForPixel","halfGrid","getLineWidthForValue","maxBarThickness","stackIndex","rects","BubbleController","getRatioAndOffset","circumference","cutout","ratioX","ratioY","startAngle","endAngle","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","DoughnutController","animateRotate","animateScale","spacing","legend","generateLabels","fontColor","legendItem","toggleDataVisibility","innerRadius","outerRadius","_getRotation","_getCircumference","_getRotationExtents","isDatasetVisible","arcs","getMaxBorderWidth","getMaxOffset","maxSize","chartWeight","_getRingWeight","maxRadius","radiusLength","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","calculateCircumference","animationOpts","centerX","centerY","metaData","borderAlign","hoverBorderWidth","hoverOffset","ringWeightOffset","LineController","_dataset","_decimated","animated","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","lastPoint","updateControlPoints","PolarAreaController","angleLines","circular","pointLabels","_updateRadius","minSize","cutoutPercentage","getVisibleDatasetCount","xCenter","yCenter","datasetStartAngle","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","PieController","RadarController","pointPosition","getPointPositionForValue","ScatterController","getElement","controllers","__proto__","DateAdapterBase","members","init","formats","startOf","endOf","adapters","_date","binarySearch","metaset","lookupMethod","_reversePixels","getRange","evaluateInteractionItems","position","getSortedVisibleDatasetMetas","getDistanceMetricForAxis","useX","useY","deltaX","deltaY","getIntersectItems","useFinalPosition","isPointInArea","evaluationFunc","inRange","getNearestRadialItems","getProps","getNearestCartesianItems","distanceMetric","minDistance","getCenterPoint","pointInArea","getNearestItems","getAxisItems","rangeMethod","intersectsItem","Interaction","modes","nearest","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","wrapBoxes","boxes","layoutBoxes","stackWeight","buildStacks","layouts","placed","setLayoutDims","params","vBoxMaxWidth","hBoxMaxHeight","layout","fullSize","availableWidth","availableHeight","buildLayoutBoxes","centerHorizontal","centerVertical","leftAndTop","rightAndBottom","vertical","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","heightChanged","same","other","handleMaxPadding","updatePos","getMargins","marginForPositions","fitBoxes","refitBoxes","refit","setBoxDims","placeBoxes","userPadding","addBox","_layers","z","removeBox","layoutItem","minPadding","verticalBoxes","horizontalBoxes","beforeLayout","visibleVerticalBoxCount","BasePlatform","acquireContext","releaseContext","isAttached","updateConfig","BasicPlatform","EXPANDO_KEY","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","initCanvas","renderHeight","renderWidth","displayWidth","displayHeight","eventListenerOptions","addListener","removeListener","fromNativeEvent","native","nodeListContains","nodeList","contains","createAttachObserver","observer","MutationObserver","addedNodes","removedNodes","observe","childList","subtree","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","listenDevicePixelRatioChanges","unlistenDevicePixelRatioChanges","createResizeObserver","ResizeObserver","contentRect","releaseObserver","disconnect","createProxyAndListen","DomPlatform","proxies","$proxies","handlers","attach","detach","isConnected","_detectPlatform","OffscreenCanvas","tooltipPosition","hasValue","final","tickOpts","determinedMaxTicks","determineMaxTicks","ticksLimit","maxTicksLimit","majorIndices","enabled","getMajorIndices","numMajorIndices","first","newTicks","skipMajors","calculateSpacing","avgMajorSpacing","_tickSize","maxScale","maxChart","_maxLength","evenMajorSpacing","getEvenSpacing","factors","majorStart","majorEnd","reverseAlign","offsetFromEdge","getTicksLimit","ticksLength","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","lineValue","caches","getTickMarkLength","getTitleHeight","createScaleContext","createTickContext","titleAlign","titleArgs","titleX","titleY","positionAxisID","Scale","_margins","paddingTop","paddingBottom","paddingLeft","paddingRight","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_dataLimitsCached","suggestedMin","suggestedMax","metas","getTicks","xLabels","yLabels","getLabelItems","_computeLabelItems","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","reversePixels","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","numTicks","maxLabelDiagonal","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","asin","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","isFullSize","_computeLabelSizes","widths","heights","tickFont","fontString","nestedLabel","widestLabelSize","highestLabelSize","_resolveTickFontOptions","valueAt","idx","decimal","getDecimalForPixel","getBaseValue","optionTicks","rot","_computeGridLineItems","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","limit","step","optsAtIndex","optsAtIndexBorder","lineColor","tickBorderDash","tickBorderDashOffset","tickAndPadding","hTickAndPadding","lineCount","textOffset","_getXAxisLabelAlignment","_getYAxisLabelAlignment","halfCount","tickTextAlign","labelPadding","_computeLabelArea","drawBackground","drawGrid","drawLine","setLineDash","lineDashOffset","drawBorder","lastLineWidth","drawLabels","renderTextOptions","drawTitle","tz","gz","bz","axisID","_maxDigits","fontSize","TypedRegistry","isForType","parentScope","isIChartComponent","registerDefaults","unregister","itemDefaults","defaultRoutes","routeDefaults","routes","propertyParts","sourceName","sourceScope","Registry","_typedRegistries","_each","addControllers","addPlugins","addScales","getController","_get","getPlugin","getScale","removeControllers","removeElements","removePlugins","removeScales","typedRegistry","reg","_getRegistryForType","_exec","itemReg","camelMethod","PluginService","_init","notify","_createDescriptors","cancelable","invalidate","_oldCache","_notifyStateChanges","allPlugins","createDescriptors","previousDescriptors","localIds","getOpts","pluginOpts","pluginScopeKeys","getIndexAxis","datasetDefaults","datasetOptions","getAxisFromDefaultScaleID","getDefaultScaleIDFromAxis","idMatchesAxis","axisFromPosition","determineAxis","scaleOptions","getAxisFromDataset","retrieveAxisFromDatasets","boundDs","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","defaultId","defaultScaleOptions","defaultID","initOptions","initData","initConfig","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","_config","_scopeCache","_resolverCache","clearCache","datasetType","additionalOptionScopes","_cachedScopes","mainScope","resetCache","keyLists","chartOptionScopes","subPrefixes","getResolver","needContext","subResolver","resolverCache","hasFunction","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","getCanvas","getElementById","instances","getChart","moveNumericKeys","intKey","determineLastEvent","lastEvent","inChartArea","isClick","getSizeForArea","field","getDatasetArea","Chart","invalidatePlugins","userConfig","initialCanvas","existingChart","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","_doResize","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","newSize","newRatio","onResize","ensureScalesHaveIDs","scalesOptions","axisOptions","buildOrUpdateScales","scaleOpts","isRadial","dposition","dtype","scaleType","scaleClass","hasUpdated","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","buildOrUpdateControllers","newControllers","order","ControllerClass","_resetElements","animsDisabled","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","existingEvents","newEvents","unbindEvents","changes","_getUniformDataChanges","datasetCount","makeSet","changeSet","noArea","_idx","_updateDataset","layers","_drawDatasets","_drawDataset","useClip","getElementsAtEventForMode","setDatasetVisibility","_updateVisibility","_stop","destroy","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","_add","_remove","updateHoverStyle","getActiveElements","setActiveElements","activeElements","lastActive","pluginId","replay","hoverOptions","eventFilter","_handleEvent","_getActiveElements","clipArc","pixelMargin","angleMargin","toRadiusCorners","parseBorderRadius$1","angleDelta","borderRadius","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","outerStart","outerEnd","innerStart","innerEnd","rThetaToXY","theta","pathArc","innerR","spacingOffset","noSpacingInnerRadius","noSpacingOuterRadius","avNogSpacingRadius","adjustedAngle","beta","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","drawArc","fullCircles","inner","lineJoin","ArcElement","chartX","chartY","rAdjust","betweenAngles","withinRadius","halfAngle","halfRadius","fix","radiusOffset","lineCap","getLineMethod","stepped","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","pathSegment","lineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","useFastPath","_getInterpolationMethod","strokePathWithCache","_path","Path2D","strokePathDirect","segmentMethod","usePath2D","LineElement","_points","_segments","_pointsUpdated","_interpolate","interpolated","inRange$1","hitRadius","PointElement","hoverRadius","mouseX","mouseY","inXRange","inYRange","getBarBounds","bar","half","skipOrLimit","parseBorderWidth","maxW","maxH","parseBorderRadius","maxR","enableBorder","boundingRects","outer","skipX","skipY","skipBoth","hasRadius","addNormalRectPath","inflateRect","amount","refRect","BarElement","addRectPath","BORDER_COLORS","BACKGROUND_COLORS","getBorderColor","getBackgroundColor","colorizeDefaultDataset","colorizeDoughnutDataset","colorizePolarAreaDataset","getColorizer","containsColorsDefinitions","containsColorsDefinition","plugin_colors","forceOverride","_args","chartOptions","colorizer","lttbDecimation","samples","decimated","bucketWidth","sampledIndex","endIndex","maxAreaPoint","maxArea","nextA","avgY","avgRangeStart","avgRangeEnd","avgRangeLength","rangeOffs","rangeTo","pointAx","pointAy","minMaxDecimation","minIndex","maxIndex","startIndex","xMin","xMax","lastIndex","intermediateIndex1","intermediateIndex2","cleanDecimatedDataset","cleanDecimatedData","getStartAndCountOfVisiblePointsSimplified","plugin_decimation","algorithm","beforeElementsUpdate","xAxis","threshold","tpoints","_findSegmentEnd","_getBounds","targetSegments","tgt","subBounds","fillSources","fillSource","_getEdge","_pointsFromSegments","boundary","linePoints","_createBoundaryLine","_shouldApplyFill","_resolveTarget","propagate","visited","_decodeFill","parseFillOption","decodeTargetIndex","firstCh","_getTargetPixel","_getTargetValue","fillOption","_buildStackLine","sourcePoints","linesBelow","getLinesBelow","addPointsBelow","below","sourcePoint","postponed","findPoint","pointValue","firstValue","lastValue","simpleArc","getLineByIndex","computeBoundary","computeCircularBoundary","computeLinearBoundary","_drawfill","lineOpts","above","doFill","clipVertical","clipY","lineLoop","src","notShape","clipBounds","interpolatedLineTo","targetLoop","interpolatedPoint","afterDatasetsUpdate","$filler","beforeDraw","drawTime","beforeDatasetsDraw","beforeDatasetDraw","getBoxSize","labelOpts","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","itemsEqual","Legend","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","col","calculateItemSize","adjustHitBoxes","rtlHelper","hitbox","_draw","defaultColor","halfFontSize","cursor","drawLegendBox","lineDash","drawOptions","SQRT2","yBoxTop","xBoxLeft","textDirection","realX","fontLineHeight","calculateLegendItemHeight","titleFont","titlePadding","topPaddingPlusHalfFontSize","_getLegendItemAt","hitBox","lh","handleEvent","isListened","hoveredItem","sameItem","calculateItemWidth","calculateItemHeight","legendItemText","plugin_legend","_element","afterEvent","ci","useBorderRadius","Title","_padding","textSize","_drawArgs","fontOpts","createTitle","titleBlock","plugin_title","plugin_subtitle","positioners","average","xSet","xAverage","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","createTooltipItem","formattedValue","getTooltipSize","tooltip","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","bodyLineHeight","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineYAlign","doesNotFitWithAlign","xAlign","caret","caretSize","caretPadding","determineXAlign","yAlign","chartWidth","determineAlignment","alignX","alignY","paddingAndSize","getBackgroundPoint","alignment","getAlignedX","getBeforeAfterBodyLines","createTooltipContext","tooltipItems","overrideCallbacks","defaultCallbacks","beforeTitle","labelCount","afterTitle","beforeLabel","tooltipItem","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","invokeCallbackWithFallback","Tooltip","opacity","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","getTitle","getBeforeBody","getBody","bodyItems","scoped","getAfterBody","getFooter","_createItems","itemSort","positionAndSize","backgroundPoint","external","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","titleColor","_drawColorBox","colorX","rtlColorX","yOffSet","colorY","multiKeyBackground","outerX","innerX","strokeRect","drawBody","bodyAlign","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","drawFooter","footerAlign","footerColor","tooltipSize","quadraticCurveTo","_updateAnimationTarget","animX","animY","_willRender","hasTooltipContent","globalAlpha","positionChanged","_positionChanged","_ignoreReplayEvents","plugin_tooltip","afterInit","afterDraw","Colors","Decimation","Filler","SubTitle","addIfString","addedLabels","findOrAddLabel","lastIndexOf","_getLabelForValue","CategoryScale","_startValue","_valueRange","_addedLabels","added","generateTicks$1","generationOptions","dataRange","MIN_SPACING","precision","maxTicks","maxDigits","includeBounds","unit","maxSpaces","rmin","rmax","countDefined","minSpacing","niceMin","niceMax","numSpaces","decimalPlaces","relativeLabelSize","LinearScaleBase","_endValue","handleTickRangeOptions","setMin","setMax","minSign","maxSign","getTickLimit","stepSize","computeTickLimit","numericGeneratorOptions","LinearScale","log10Floor","changeExponent","isMajor","tickVal","steps","rangeExp","rangeStep","startExp","generateTicks","minExp","exp","lastTick","LogarithmicScale","_zero","getTickBackdropHeight","measureLabelSize","determineLimits","fitWithPointLabels","limits","valueCount","_pointLabels","pointLabelOpts","additionalAngle","centerPointLabels","getPointLabelContext","getPointPosition","drawingArea","plFont","hLimits","vLimits","updateLimits","setCenterPoint","_pointLabelItems","buildPointLabelItems","createPointLabelItem","itemOpts","outerDistance","extra","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","isNotOverlapped","apexesInArea","drawPointLabelBox","backdropLeft","backdropTop","backdropWidth","backdropHeight","drawPointLabels","pathRadiusLine","drawRadiusLine","gridLineOpts","createPointLabelContext","RadialLinearScale","animate","leftMovement","rightMovement","topMovement","bottomMovement","angleMultiplier","scalingFactor","getValueForDistanceFromCenter","scaledDistance","pointLabel","distanceFromCenter","getBasePosition","getPointLabelPosition","INTERVALS","millisecond","common","second","minute","hour","day","week","month","quarter","year","UNITS","sorter","adapter","_adapter","parser","isoWeekday","_parseOpts","determineUnitForAutoTicks","minUnit","capacity","interval","determineUnitForFormatting","determineMajorUnit","addTick","time","timestamps","timestamp","setMajorTicks","majorUnit","ticksFromTimestamps","TimeScale","displayFormats","_unit","_majorUnit","_offsets","_normalized","_applyBounds","_getLabelBounds","getLabelTimestamps","timeOpts","_generate","_getLabelCapacity","initOffsets","offsetAfterAutoskip","getDecimalForValue","weekday","hasWeekday","getDataTimestamps","tooltipFormat","datetime","fmt","_tickFormatFunction","minorFormat","majorFormat","offsets","_getLabelSize","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","prevSource","nextSource","prevTarget","nextTarget","span","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","registerables"],"sourceRoot":""}